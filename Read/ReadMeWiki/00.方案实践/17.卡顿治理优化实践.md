#### 目录介绍
- 01.卡顿基础介绍
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念
    - 1.4 设计目标
- 02.治理卡顿的流程
    - 2.1 排查卡顿流程
    - 2.2 排查卡顿工具
    - 2.3 卡顿根本原因
- 03.UI卡顿
    - 3.1 View卡顿点
    - 
- 04.线程卡顿
    - 4.1 卡顿实践思路
- 05.过渡绘制卡顿
    - 5.1 



### 02.治理卡顿的流程
#### 2.1 排查卡顿流程
- 优化卡顿的步骤
    - 监控卡顿的发生 ---> 准确定位到哪个模块(甚至哪个方法导致了卡) ---> 分析代码并解决卡顿
- 监控卡顿的发生
    - 主要使用工具监控
- 定位到卡顿的点
    - 待完善
- 分析代码并解决卡顿
    - UI卡顿
    - 线程卡顿
    - 过渡绘制卡顿



#### 2.2 排查卡顿工具
- 卡顿一些工具
    - Systrace方法
    - Android CPU Profiler工具分析卡顿
    - 线上性能监控方法熟悉
    - FPS帧率检测



#### 2.3 卡顿根本原因
- 视图刷新原理:
    - View 的 requestLayout 和 ViewRootImpl##setView 最终都会调用 ViewRootImpl 的 requestLayout 方法，然后通过 scheduleTraversals 方法向 Choreographer 提交一个绘制任务，然后再通过 DisplayEventReceiver 向底层请求 vsync 垂直同步信号，当 vsync 信号来的时候，会通过 JNI 回调回来，在通过 Handler 往消息队列 post 一个异步任务，最终是 ViewRootImpl 去执行绘制任务，最后调用 performTraversals 方法，完成绘制。
- 卡顿的根本原因:
    - 从刷新原理来看卡顿的根本原理是有两个地方会造成掉帧:
    - 一个是主线程有其它耗时操作，导致doFrame 没有机会在 vsync 信号发出之后 16 毫秒内调用；
    - 还有一个就是当前doFrame方法耗时，绘制太久，下一个 vsync 信号来的时候这一帧还没画完，造成掉帧。





### 02.复杂的视图树
- 如果视图树复杂，会使整个Traversal过程变长。
    - 因此，我们在开发过程中要控制视图树的复杂程度。减少不必要的层级嵌套。比如使用RelativeLayout可以减少复杂布局的嵌套。
- 频繁的触发 requestLayout()
    - 就可能会导致在一帧的周期内，频繁的发生布局计算，这也会导致整个Traversal过程变长。
    - 有的ViewGroup类型的控件，比如RelativeLayout，在一帧的周期内会通过两次layout()操作来计算确认子View的位置，这种少量的操作并不会引起能够被注意到的性能问题。
    - 但是如果在一帧的周期内频繁的发生layout()计算，就会导致严重的性能，每次计算都是要消耗时间的！
    - 而requestLayout()操作，会向ViewRootImpl中一个名为mLayoutRequesters的List集合里添加需要重新Layout的View，这些View将在下一帧中全部重新layout()一遍。通常在一个控件加载之后，如果没什么变化的话，它不会在每次的刷新中都重新layout()一次，因为这是一个费时的计算过程。所以，如果每一帧都有许多View需要进行layout()操作，可想而知你的界面将会卡到爆！卡到爆！需要注意，setLayoutParams()最终也会调用requestLayout()，所以也不能烂用！


### 03.UI卡顿
#### 3.1 View卡顿点
- 产生卡顿原因有很多，主要有以下几点：
    - 布局Layout过于复杂，无法在16ms内完成渲染。
    - 同一时间动画执行的次数过多，导致CPU和GPU负载过重。
    - View过渡绘制，导致某些像素在同一帧时间内被绘制多次。
    - 在UI线程中做了稍微耗时的操作。
    - GC回收时暂停时间过长或者频繁的GC产生大量的暂停时间。




### 04.UI线程被阻塞
- 如果UI线程受到阻塞，显而易见的是，我们的Traversal过程也将受阻塞！画面卡顿是妥妥的发生啊。这就是为什么大家一直在强调不要在UI线程做耗时操作的原因。通常UI线程的阻塞和以下原因脱不了关系。
    - 在UI线程中进行IO读写数据的操作。这是一个很费时的过程好吗？千万别这么干。如果不想获得一个卡到爆的App的话，把IO操作统统放到子线程中去。
    - 在UI线程中进行复杂的运算操作。运算本身是一个耗时的操作，当然简单的运算几乎瞬间完成，所以不会让你感受到它在耗时。但是对于十分复杂的运算，对时间的消耗是十分辣眼睛的！如果不想获得一个卡到爆的App的话，把复杂的运算操作放到子线程中去。
    - 在UI线程中进行复杂的数据处理。我说的是比如数据的加密、解密、编码等等。这些操作都需要进行复杂运算，特别是在数据比较复杂的时候。如果不想获得一个卡到爆的App的话，把复杂数据的处理工作放到子线程中去。
    - 频繁的发生GC，导致UI线程被频繁中断。在Java中，发生GC(垃圾回收)意味着Stop-The-World，就是说其它线程全部会被暂停啊。好可怕！正常的GC导致偶然的画面卡顿是可以接受的，但是频繁发生就让人很蛋疼了！频繁GC的罪魁祸首是内存抖动。简单的说就是在短时间内频繁的创建大量对象，导致达到GC的阀值，然后GC就发生了。如果不想获得一个卡到爆的App的话，把内存的管理做好，即使这是Java。



### 05.内存抖动
- 什么是内存抖动？
    - 是由于短时间内有大量对象进出Young Generiation区导致的，它伴随着频繁的GC。在Java内存管理机制中我提到过内存抖动会引起频繁的GC，从而使UI线程被频繁阻塞，导致画面卡顿。
- 避免发生内存抖动的几点建议：
    - 尽量避免在循环体内创建对象，应该把对象创建移到循环体外。
    - 注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。
    - 当需要大量使用Bitmap的时候，试着把它们缓存在数组中实现复用。
    - 对于能够复用的对象，同理可以使用对象池将它们缓存起来。
- 内存抖动是由于大量对象在短时间内被配置而引起的，所以要做的就是谨慎对待那些可能会大量创建对象的情况。
    - 这块可以看我的这个开源项目，有效使用对象池避免对象大量创建。[图片缩放控件](https://github.com/yangchong211/YCGallery)



### 01.概述
#### 1.1 项目背景
- 通过简要的语言描述项目背景以及要达成的业务目标。

#### 1.2 设计目标
- 需求的背后往往会带来技术的重构/优化，或者单纯的完成需求，如果有必要，需要从技术角度给出方案设计的目标
- 比如对于图片下载需求，需要完成相关的功能，那么设计目标主要有完成异步下载、存储、缓存设计、图片解码、渲染等功能。
- 比如对于优化需求，目标可以是达到一个什么效果？可以是帧率的、Crash率的、卡顿的等。
- 比如对于重构需求，目标可以是加强扩展、解决问题、提升效率等。



### 02.方案设计
- 方案设计是技术文档的最核心部分，主要包括了整体架构和功能设计，这里需要体现：
- 设计的初衷：概要描述方案设计的思考，可以是为了扩展性的考虑，可以是提升性能
关键技术点的思考：描述关键技术选型的思考，比如要解耦，业内解耦方案能有router、Target-Action等，讲清楚选择的思考
- 技术上的折中/取舍：在做技术设计的时候，往往要的很多，但时间有限，那么这个需要讲一下折中与取舍，以及接下来的规划、计划



#### 2.1 整体架构
- 整体架构的组成需要有一张完成的架构设计图，描述清楚具体的分层以及层与层之间的关系
- 比如传统的开发会分为三层，展示层、逻辑层、数据层
    - 展示层的设计：视图的构成、视图间的耦合关系、具体的交互逻辑
    - 逻辑层的设计：支撑展示层所需要的数据、从数据层获取数据的加工、业务相关逻辑（比如轮询服务）
    - 数据层的设计：数据的获取方式以及存储方式，文件、数据库、本地、网络



#### 2.2 功能设计
- 功能设计包含但不限于以下几个部分：逻辑流程图、接口设计图、与外部的模块间依赖关系

#### 2.2.1 关键流程图
- 设计中的最复杂、最关键的逻辑需要画出流程图，实在画不出的流程图需要用语言描述清楚。
- 关键流程需要有逻辑流程图，帮助其他同学理解功能的关键节点逻辑


##### 2.2.2 接口设计图
- 通过UML类图来展示类间关系，描述清楚接口设计的一些思考原则
    - 提供的接口，往往接口设计为了完成相关逻辑



##### 2.2.3 模块间依赖关系
- 描述清楚和哪些模块存在依赖关系以及原因，比如首页依赖于购物车模块，需要解释清楚要强耦合，有没有办法解耦
    - App内部模块间依赖
    - App外部依赖


#### 2.3 UI/动效设计
- 客户端开发有很大一部分精力在UI/动效上，对于复杂的静态UI和复杂动效，需要给出实现方案和选型逻辑
- 静态UI
    - 只有复杂的UI才需要给出设计方案，例如核心页面大重构、复杂的协调布局等
- 复杂动效
    - 复杂的动效是端上容易踩坑的关键点，需要给出实现方案的对比、选型等，为验证动效可行性，可以给出动效Demo



### 03.其他设计（Optional）
- 以下部分是可选项，主要是从异常、兼容性、性能、稳定性、灰度、降级等维护来设计。


#### 3.1 性能设计
- 有些业务项目可能会考虑性能，比如列表页，卡顿、流畅度怎么样？如何评估？
- 有些技术项目可能也会考虑性能，比如数据库设计，检索性能如何？是否有瓶颈，如何评估？


#### 3.2 稳定性设计
- 大的项目需要考虑性能如何保障？
    - 比如方案 Review
    - 比如自测Case Review，加强自测
    - 比如单测


#### 3.3 灰度设计
- 核心关键功能需要有A/B设计
- 比如UIWebview替换为WKWebview，其中存在很多不确定因素，需要做好灰度设计


#### 3.4 降级设计
- 在做一些新技术尝试时，需要考虑降级设计
    - 比如RN、swift、weex引入对原有业务造成影响的，需要有兜底，可降级
    - 参考资料
    - 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


#### 3.5 异常设计
- 大部分业务需求都会涉及到异常处理，在关心主流程的同时需要关注异常场景怎么保证正确性？
    - 比如用户操作中途退出、网络异常、数据被清理等


#### 3.6 兼容性设计
- 业务逻辑一般不会涉及到兼容性，但UI/动效需求容易遇到兼容性问题，也是提测时需要让QA关注的
    - 比如独立端/嵌入端、高低版本API适配等


### 04.排期与计划
- 排期计划主要针对周期较长项目的时间补充，对于小型项目不需要，例如：
    - 正常的版本业务需求，5pd以下，不需要给出排期计划；5pd或者以上，可以简单描述一下排期和提测时间
    - 跨版本的大型业务需求、重构专项等，需要给出详细的排期计划
    - 研发自驱的技术优化项目，需要给出详细的排期计划


### 05.参考资料
- 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。
- https://blog.csdn.net/u011578734/article/details/109582595





