#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.ANR基础分析
    - 2.1 究竟什么是ANR
    - 2.2 造成ANR的原因分类
    - 2.3 ANR产生需要的条件
    - 2.4 ANR触发场景
    - 2.5 四大组件ANR
    - 2.6 触发ANR的步骤
- 03.ANR流程分析
    - 3.1 触发ANR的步骤
    - 3.2 Activity的ANR流程
    - 3.3 Service的ANR分析
    - 3.4 ANR后系统执行流程
    - 3.5 那些极端情况不会ANR
    - 3.6 理解ANR静默和弹窗
    - 3.7 处理ANR信息收集操作
- 04.ANR监控设计思路
    - 4.1 ANR监控整体思路
    - 4.2 目前流行方案
    - 4.3 
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计
- 07.其他说明介绍
    - 7.1 参考链接



### 01.整体概述
#### 1.1 项目背景
#### 1.2 遇到问题
#### 1.3 基础概念介绍
#### 1.4 设计目标
#### 1.5 产生收益分析


### 02.ANR基础分析
#### 2.1 究竟什么是ANR
- ANR的简单理解
    - ANR Activity not responding(页面没有响应) 
    - ANR Application not responding 应用没有响应
- ANR(Application Not responding)，是指应用程序未响应。
    - Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。



#### 2.2 造成ANR的原因分类
- 造成ANR的原因一般有两种：
    - 当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）
    - 当前的事件正在处理，但没有及时完成



#### 2.3 ANR产生需要的条件
- ANR的产生需要满足三个条件
    - 主线程：只有应用程序进程的主线程响应超时才会产生ANR；
    - 超时时间：产生ANR的上下文不同，超时时间也会不同，但只要在这个时间上限内没有响应就会ANR；
    - 输入事件/特定操作：输入事件是指按键、触屏等设备输入事件，特定操作是指BroadcastReceiver和Service的生命周期中的各个函数，产生ANR的上下文不同，导致ANR的原因也会不同；


#### 2.4 ANR触发场景
- 分别有哪些场景
    - 主线程，被阻塞5秒钟以上，就会抛出ANR对话框。不同的组件发生ANR的时间不一样，Activity是5秒，BroadCastReceiver是10秒，Service是20秒（均为前台）。
    - 点击事件(按键和触摸事件)5s内没被处理: Input event dispatching timed out
- 那些操作会引发ANR
    - Activity，Fragment中暴力相应点击事件有可能会导致ANR
    - 断点调试时，程序可能会出现ANR无限应
    - 主线程做了耗时操作，比如查询数据库数据导致ANR


#### 2.5 四大组件ANR
- service 前台20s后台200s未完成启动： Timeout executing service
    - Service Timeout是位于”ActivityManager”线程中的AMS.MainHandler收到SERVICE_TIMEOUT_MSG消息时触发。
    - 对于Service有两类:
        - 对于前台服务，则超时为SERVICE_TIMEOUT = 20s；
        - 对于后台服务，则超时为SERVICE_BACKGROUND_TIMEOUT = 200s
- BroadcastReceiver的事件(onReceive方法)在规定时间内没处理完：Timeout of broadcast BroadcastRecord
    - 对于前台广播，则超时为BROADCAST_FG_TIMEOUT = 10s；
    - 对于后台广播，则超时为BROADCAST_BG_TIMEOUT = 60s
    - 以BroadcastReviver为例，在onReceive()方法执行10秒内没发生第一种ANR(也就是在这个过程中没有输入事件或输入事件还没到5s)才会发生Receiver timeout，否则将先发生事件无相应ANR，所以onReceive()是有可能执行不到10s就发生ANR的，所以不要在onReceive()方法里面干活
- ContentProvider的publish在10s内没进行完：timeout publishing content providers
- Activity 界面如果5秒未响应：Activity not responding
    - 这种是特别常见的场景


### 03.ANR流程分析
#### 3.1 触发ANR的步骤
- 四大组件触发ANR的步骤
    - 大概是：埋下注册超时 ----> 触发超时 ----> 引发超时ANR



#### 3.3 Service的ANR分析
##### 3.3.1 埋下注册超时
- 调用startService，在Service进程attach到system_server进程的过程中会调用realStartServiceLocked()方法来注册超时
- 具体看ActiveServices类中的realStartServiceLocked()方法源码
    ``` java
    private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException {
        ...
        //发送delay消息
        bumpServiceExecutingLocked(r, execInFg, "create");
        try {
            ...
            //最终执行服务的onCreate()方法
            app.thread.scheduleCreateService(r, r.serviceInfo,
                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                    app.repProcState);
        } catch (DeadObjectException e) {
            mAm.appDiedLocked(app);
            throw e;
        } finally {
        }
    }
    ```
    - 接着往下看 bumpServiceExecutingLocked 方法源码，如下所示：
    ``` java
    private final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) {
        if (r.executeNesting == 0) {
            if (r.app != null) {
                if (timeoutNeeded && r.app.executingServices.size() == 1) {
                    scheduleServiceTimeoutLocked(r.app);
                }
            }
        } else if (r.app != null && fg && !r.app.execServicesFg) {
            if (timeoutNeeded) {
                scheduleServiceTimeoutLocked(r.app);
            }
        }
    }
    ```
    - 接着看 scheduleServiceTimeoutLocked 方法源码，这里面才是处理超时时间的具体逻辑，通过handler发送延迟消息。
    ``` java
    void scheduleServiceTimeoutLocked(ProcessRecord proc) {
        Message msg = mAm.mHandler.obtainMessage(
                ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj = proc;
        mAm.mHandler.sendMessageDelayed(msg,
                proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
    }
    ```
- 然后来梳理一下整个流程
    - ----> ActiveServices 类 realStartServiceLocked 方法
    - ----> ActiveServices 类 bumpServiceExecutingLocked 方法
    - ----> ActiveServices 类 scheduleServiceTimeoutLocked 方法 ， handler发送延迟消息


##### 3.3.2 触发超时
- 触发超时分析
    - 在system_server进程AS.realStartServiceLocked()调用的过程会埋下注册超时, 超时没有启动完成则会超时。
    - 那么什么时候会触发超时的引线呢? 经过Binder等层层调用进入目标进程的主线程handleCreateService()的过程。
- 具体看ActivityThread类中的handleCreateService方法
    ``` java
    private void handleCreateService(CreateServiceData data) {
        try {
            //创建ContextImpl对象，直接new创建的
            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
            context.setOuterContext(service);
            //创建Application对象，反射创建的
            Application app = packageInfo.makeApplication(false, mInstrumentation);
            service.attach(context, this, data.info.name, data.token, app,
                    ActivityManagerNative.getDefault());
            //调用服务onCreate()方法 
            service.onCreate();
            //触发超时的核心代码
            ActivityManager.getService().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        } catch (Exception e) {
        }
    }
    ```
    - 然后看一下ActivityManagerService类中的serviceDoneExecuting源码
    ``` java
    public void serviceDoneExecuting(IBinder token, int type, int startId, int res) {
        synchronized(this) {
            if (!(token instanceof ServiceRecord)) {
                Slog.e(TAG, "serviceDoneExecuting: Invalid service token=" + token);
                throw new IllegalArgumentException("Invalid service token");
            }
            mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);
        }
    }
    ```
    - 然后再看一下ActiveServices类中的serviceDoneExecutingLocked方法源码。该方法的主要工作是当service启动完成，则移除服务超时消息SERVICE_TIMEOUT_MSG。
    ``` java
    private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) {
        if (r.executeNesting <= 0) {
            if (r.app != null) {
                r.app.execServicesFg = false;
                r.app.executingServices.remove(r);
                if (r.app.executingServices.size() == 0) {
                    //当前服务所在进程中没有正在执行的service
                    mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);
        }
    }
    ```
- 然后来梳理一下整个流程
    - ----> ActivityThread 类 handleCreateService 方法 
    - ----> ActivityManagerService 类 serviceDoneExecuting 方法
    - ----> ActiveServices 类 serviceDoneExecutingLocked 方法 



##### 3.3.3 引发超时ANR
- 如何引发超时ANR
    - 介绍了埋下注册超时和触发超时的过程, 如果在超时倒计时结束之前成功拆卸注册超时,那么就没有引发ANR的机会。
    - 但总有些极端情况下无法即时拆除注册超时,导致触发超时了, 其结果就是App发生ANR。
- 在system_server进程中有一个Handler线程, 名叫”ActivityManager”
    - 当倒计时结束便会向该Handler线程发送 一条信息SERVICE_TIMEOUT_MSG
- 在ActivityManagerService类中的handleMessage方法中
    ``` java
    final class MainHandler extends Handler {
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case SERVICE_TIMEOUT_MSG: {
                    mServices.serviceTimeout((ProcessRecord)msg.obj);
                } break;
            }
        }
    }
    ```
    - 然后看一下ActiveServices类的serviceTimeout方法
    ``` java
    void serviceTimeout(ProcessRecord proc) {
        if (anrMessage != null) {
            //当存在timeout的service，则执行ANR
            mAm.appNotResponding(proc, null, null, false, anrMessage);
        }
    }
    ```
- 然后来梳理一下整个流程
    - ----> ActivityManagerService 类 handleMessage 方法 
    - ----> ActiveServices 类 serviceTimeout 方法



#### 3.4 ANR后系统执行流程
- ANR后流程如下
    - APP发生ANR
    - 进程接收异常终止信号，开始写入进程ANR信息（当时场景，包含当前线程所有堆栈信息、CPU/IO的使用情况等）；
    - 弹出ANR提示框，提示用户关闭APP或者继续等待；（不同ROM表现不同，有的手机厂商会去掉这个提示框）
- appNotResponding介绍
    - 无论ANR的来源是哪里，最终都会走到ProcessRecord中的appNotResponding，这个方法包括了ANR的主要流程。



#### 3.5 那些极端情况不会ANR
- 具体可以看appNotResponding方法中的下面代码。会发现有一些条件直接执行了return。
    ``` java
    void appNotResponding(String activityShortComponentName, ApplicationInfo aInfo,
            String parentShortComponentName, WindowProcessController parentProcess,
            boolean aboveSystem, String annotation) {
        synchronized (mService) {
            // PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.
            if (mService.mAtmInternal.isShuttingDown()) {
                Slog.i(TAG, "During shutdown skipping ANR: " + this + " " + annotation);
                return;
            } else if (isNotResponding()) {
                Slog.i(TAG, "Skipping duplicate ANR: " + this + " " + annotation);
                return;
            } else if (isCrashing()) {
                Slog.i(TAG, "Crashing app skipping ANR: " + this + " " + annotation);
                return;
            } else if (killedByAm) {
                Slog.i(TAG, "App already killed by AM skipping ANR: " + this + " " + annotation);
                return;
            } else if (killed) {
                Slog.i(TAG, "Skipping died app ANR: " + this + " " + annotation);
                return;
            }
        }
    }
    ```
- 有哪些极端的情况不会ANR
    - 一长串if else，给出了几种比较极端的情况，会直接return，而不会产生一个ANR。
    - 这些情况包括：进程正在处于正在关闭的状态，正在crash的状态，被kill的状态，或者相同进程已经处在ANR的流程中。


#### 3.6 理解ANR静默和弹窗
- 看下面的源码分析，还是appNotResponding方法。
    - 大概的意思是，通过isSilentAnr()判断是否是静默ANR，如果是那么则直接kill杀死app。其实就是后台ANR。
    - 如果是前台，则是通过handler发送一个消息，创建anr弹窗对象，赋值给message的obj对象。
    ``` java
    void appNotResponding(String activityShortComponentName, ApplicationInfo aInfo,
            String parentShortComponentName, WindowProcessController parentProcess,
            boolean aboveSystem, String annotation) {
        synchronized (mService) {
            if (isSilentAnr() && !isDebugging()) {
                kill("bg anr", true);
                return;
            }
            makeAppNotRespondingLocked(activityShortComponentName,
                    annotation != null ? "ANR " + annotation : "ANR", info.toString());
            if (mService.mUiHandler != null) {
                Message msg = Message.obtain();
                msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;
                msg.obj = new AppNotRespondingDialog.Data(this, aInfo, aboveSystem);
                mService.mUiHandler.sendMessage(msg);
            }
        }
    }
    ```
- 那么究竟是怎么判断是后台服务呢？
    - 除非另有配置，否则在后台进程中吞下anr并杀死进程。非私有访问仅用于测试。
    ``` java
    boolean isSilentAnr() {
        return !getShowBackground() && !isInterestingForBackgroundTraces();
    }
    ```
- 再来看看处理弹窗展示的逻辑，具体看ActivityManagerService类的handleMessage方法。what是：SHOW_NOT_RESPONDING_UI_MSG
    ``` java
    final class UiHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case SHOW_NOT_RESPONDING_UI_MSG: {
                mAppErrors.handleShowAnrUi(msg);
                ensureBootCompleted();
            } 
        }
    }
    ```


#### 3.7 处理ANR信息收集操作
- 为了方便定位，因此需要收集ANR信息。下面代码还是appNotResponding方法，主要是收集信息的重要代码。
    - dump很多信息到ANR Trace文件里，下面的逻辑就是选择需要dump的进程。
    - ANR Trace文件是包含许多进程的Trace信息的，因为产生ANR的原因有可能是其他的进程抢占了太多资源
    ```
    void appNotResponding(String activityShortComponentName, ApplicationInfo aInfo,
            String parentShortComponentName, WindowProcessController parentProcess,
            boolean aboveSystem, String annotation) {
            firstPids.add(pid);
    
            // Don't dump other PIDs if it's a background ANR
            if (!isSilentAnr()) {
                int parentPid = pid;
                if (parentProcess != null && parentProcess.getPid() > 0) {
                    parentPid = parentProcess.getPid();
                }
                if (parentPid != pid) firstPids.add(parentPid);
    
                if (MY_PID != pid && MY_PID != parentPid) firstPids.add(MY_PID);
    
                for (int i = getLruProcessList().size() - 1; i >= 0; i--) {
                    ProcessRecord r = getLruProcessList().get(i);
                    if (r != null && r.thread != null) {
                        int myPid = r.pid;
                        if (myPid > 0 && myPid != pid && myPid != parentPid && myPid != MY_PID) {
                            if (r.isPersistent()) {
                                firstPids.add(myPid);
                                if (DEBUG_ANR) Slog.i(TAG, "Adding persistent proc: " + r);
                            } else if (r.treatLikeActivity) {
                                firstPids.add(myPid);
                                if (DEBUG_ANR) Slog.i(TAG, "Adding likely IME: " + r);
                            } else {
                                lastPids.put(myPid, Boolean.TRUE);
                                if (DEBUG_ANR) Slog.i(TAG, "Adding ANR proc: " + r);
                            }
                        }
                    }
                }
            }
        }
    
        // don't dump native PIDs for background ANRs unless it is the process of interest
        String[] nativeProcs = null;
        if (isSilentAnr()) {
            for (int i = 0; i < NATIVE_STACKS_OF_INTEREST.length; i++) {
                if (NATIVE_STACKS_OF_INTEREST[i].equals(processName)) {
                    nativeProcs = new String[] { processName };
                    break;
                }
            }
        } else {
            nativeProcs = NATIVE_STACKS_OF_INTEREST;
        }
    
        int[] pids = nativeProcs == null ? null : Process.getPidsForCommands(nativeProcs);
        ArrayList<Integer> nativePids = null;
    
        if (pids != null) {
            nativePids = new ArrayList<>(pids.length);
            for (int i : pids) {
                nativePids.add(i);
            }
        }
    }
    ```
- 选择需要dump的进程的逻辑需要大概说下
    - 需要被dump的进程被分为了firstPids、nativePids以及extraPids三类。
    - 拿到需要dump的所有进程的pid后，AMS开始按照firstPids、nativePids、extraPids的顺序dump这些进程的堆栈
    ``` java
    File tracesFile = ActivityManagerService.dumpStackTraces(firstPids,
            (isSilentAnr()) ? null : processCpuTracker, (isSilentAnr()) ? null : lastPids,
            nativePids);
    ```





- 使用looper可以拦截崩溃和anr吗
    - 可以实现拦截UI线程的崩溃，耗时性能监控。但是也并不能够拦截所有的异常。如果在Activity的onCreate出现崩溃，导致Activity创建失败，那么就会显示黑屏。
    - fork出app进程后，在ActivityThread中，在main方法的最后调用了 Looper.loop()，在这个方法中处理主线程的任务调度，一旦执行完这个方法就意味着APP被退出了。
    - 果主线程发生了异常，就会退出循环，意味着APP崩溃，所以我们我们需要进行try-catch，避免APP退出，再启动一个 Looper.loop() 去执行主线程任务，就不会退出。



### 01.概述
#### 1.1 项目背景
- 通过简要的语言描述项目背景以及要达成的业务目标。




#### 1.2 设计目标
- 需求的背后往往会带来技术的重构/优化，或者单纯的完成需求，如果有必要，需要从技术角度给出方案设计的目标
- 比如对于图片下载需求，需要完成相关的功能，那么设计目标主要有完成异步下载、存储、缓存设计、图片解码、渲染等功能。
- 比如对于优化需求，目标可以是达到一个什么效果？可以是帧率的、Crash率的、卡顿的等。
- 比如对于重构需求，目标可以是加强扩展、解决问题、提升效率等。



### 02.方案设计
- 方案设计是技术文档的最核心部分，主要包括了整体架构和功能设计，这里需要体现：
- 设计的初衷：概要描述方案设计的思考，可以是为了扩展性的考虑，可以是提升性能
关键技术点的思考：描述关键技术选型的思考，比如要解耦，业内解耦方案能有router、Target-Action等，讲清楚选择的思考
- 技术上的折中/取舍：在做技术设计的时候，往往要的很多，但时间有限，那么这个需要讲一下折中与取舍，以及接下来的规划、计划



#### 2.1 整体架构
- 整体架构的组成需要有一张完成的架构设计图，描述清楚具体的分层以及层与层之间的关系
- 比如传统的开发会分为三层，展示层、逻辑层、数据层
    - 展示层的设计：视图的构成、视图间的耦合关系、具体的交互逻辑
    - 逻辑层的设计：支撑展示层所需要的数据、从数据层获取数据的加工、业务相关逻辑（比如轮询服务）
    - 数据层的设计：数据的获取方式以及存储方式，文件、数据库、本地、网络



#### 2.2 功能设计
- 功能设计包含但不限于以下几个部分：逻辑流程图、接口设计图、与外部的模块间依赖关系

#### 2.2.1 关键流程图
- 设计中的最复杂、最关键的逻辑需要画出流程图，实在画不出的流程图需要用语言描述清楚。
- 关键流程需要有逻辑流程图，帮助其他同学理解功能的关键节点逻辑


##### 2.2.2 接口设计图
- 通过UML类图来展示类间关系，描述清楚接口设计的一些思考原则
    - 提供的接口，往往接口设计为了完成相关逻辑



##### 2.2.3 模块间依赖关系
- 描述清楚和哪些模块存在依赖关系以及原因，比如首页依赖于购物车模块，需要解释清楚要强耦合，有没有办法解耦
    - App内部模块间依赖
    - App外部依赖


#### 2.3 UI/动效设计
- 客户端开发有很大一部分精力在UI/动效上，对于复杂的静态UI和复杂动效，需要给出实现方案和选型逻辑
- 静态UI
    - 只有复杂的UI才需要给出设计方案，例如核心页面大重构、复杂的协调布局等
- 复杂动效
    - 复杂的动效是端上容易踩坑的关键点，需要给出实现方案的对比、选型等，为验证动效可行性，可以给出动效Demo



### 03.其他设计（Optional）
- 以下部分是可选项，主要是从异常、兼容性、性能、稳定性、灰度、降级等维护来设计。


#### 3.1 性能设计
- 有些业务项目可能会考虑性能，比如列表页，卡顿、流畅度怎么样？如何评估？
- 有些技术项目可能也会考虑性能，比如数据库设计，检索性能如何？是否有瓶颈，如何评估？


#### 3.2 稳定性设计
- 大的项目需要考虑性能如何保障？
    - 比如方案 Review
    - 比如自测Case Review，加强自测
    - 比如单测


#### 3.3 灰度设计
- 核心关键功能需要有A/B设计
- 比如UIWebview替换为WKWebview，其中存在很多不确定因素，需要做好灰度设计


#### 3.4 降级设计
- 在做一些新技术尝试时，需要考虑降级设计
    - 比如RN、swift、weex引入对原有业务造成影响的，需要有兜底，可降级
    - 参考资料
    - 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


#### 3.5 异常设计
- 大部分业务需求都会涉及到异常处理，在关心主流程的同时需要关注异常场景怎么保证正确性？
    - 比如用户操作中途退出、网络异常、数据被清理等


#### 3.6 兼容性设计
- 业务逻辑一般不会涉及到兼容性，但UI/动效需求容易遇到兼容性问题，也是提测时需要让QA关注的
    - 比如独立端/嵌入端、高低版本API适配等


### 04.排期与计划
- 排期计划主要针对周期较长项目的时间补充，对于小型项目不需要，例如：
    - 正常的版本业务需求，5pd以下，不需要给出排期计划；5pd或者以上，可以简单描述一下排期和提测时间
    - 跨版本的大型业务需求、重构专项等，需要给出详细的排期计划
    - 研发自驱的技术优化项目，需要给出详细的排期计划


### 05.参考资料
- 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。
- 微信ANR监测方案
    - https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg
- 理解Android ANR的触发原理
    - http://gityuan.com/2016/07/02/android-anr/
- 微信Android客户端的ANR监控方案
    - https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg
- 今日头条 ANR 优化实践系列
    - https://juejin.cn/post/6947986170135445535
    - https://juejin.cn/post/6942665216781975582



