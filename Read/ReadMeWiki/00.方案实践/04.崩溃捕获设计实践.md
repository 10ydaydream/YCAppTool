#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.App崩溃流程
    - 2.1 为何崩溃
    - 2.2 Java崩溃流程
    - 2.3 Native崩溃流程
    - 2.4 崩溃日志处理
    - 2.5 崩溃流程分析
- 03.崩溃处理入口
    - 3.1 Java处理异常入口
    - 3.2 异常处理常用api
    - 3.3 注意事项说明
    - 3.5 理解异常栈轨迹链
    - 3.6 StackTraceElement
- 04.崩溃监听思路
    - 4.1 实现崩溃监听
    - 4.2 处理捕获异常
    - 4.4 崩溃日志收集
    - 4.7 日志发送邮箱
    - 4.8 崩溃重启实践
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计
- 07.其他说明介绍
    - 7.1 参考链接






### 02.App崩溃流程
#### 2.1 为何崩溃
- 线程中抛出异常以后的处理逻辑
    - 一旦线程出现抛出异常，并且我们没有捕捉的情况下，JVM将调用Thread中的dispatchUncaughtException方法把异常传递给线程的未捕获异常处理器。
- 既然Android遇到异常会发生崩溃，然后找一些哪里用到设置setDefaultUncaughtExceptionHandler，即可定位到RuntimeInit类。
    - 即在这个里面设置异常捕获handler，发生异常之后，会杀死应用app。



#### 2.2 处理崩溃流程
##### 2.2.1 崩溃的大概流程
- 然后看一下RuntimeInit类，由于是java代码，所以首先找main方法入口。代码如下所示
    ``` java
    public static final void main(String[] argv) {
        commonInit();
    }
    ```
- 然后再来看一下commonInit()方法，看看里面做了什么操作？
    - 可以发现这里调用了setDefaultUncaughtExceptionHandler方法，设置了自定义的Handler类
    ``` java
    protected static final void commonInit() {
        Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler));
    }
    ```
- 接着看一下KillApplicationHandler类，可以发现该类实现了Thread.UncaughtExceptionHandler 接口
    - 这个就是杀死app逻辑具体的代码。可以看到当出现异常的时候，在finally中会退出进程操作。
    ``` java
    private static class KillApplicationHandler implements Thread.UncaughtExceptionHandler {
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            try {
                ActivityManager.getService().handleApplicationCrash(
                        mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e));
            } finally {
                Process.killProcess(Process.myPid());
                System.exit(10);
            }
        }
    }
    ```
- 得出结论
    - 其实在fork出app进程的时候，系统已经为app设置了一个异常处理，并且最终崩溃后会直接导致执行该handler的finally方法最后杀死app直接退出app。如果你要自己处理，你可以自己实现Thread.UncaughtExceptionHandler。


##### 2.2.2 崩溃日志的记录
- 在KillApplicationHandler类中的uncaughtException方法，可以看到ActivityManager.getService().handleApplicationCrash被调用，那么这个是用来做什么的呢？
    - ActivityManager.getService().handleApplicationCrash-->ActivityManagerService.handleApplicationCrash-->handleApplicationCrashInner方法
- 从下面可以看出,若传入app为null时,processName就设置为system_server
    ``` java
    public void handleApplicationCrash(IBinder app, ApplicationErrorReport.ParcelableCrashInfo crashInfo) {
        ProcessRecord r = findAppProcess(app, "Crash");
        final String processName = app == null ? "system_server" : (r == null ? "unknown" : r.processName);
        handleApplicationCrashInner("crash", r, processName, crashInfo);
    }
    ```
- 然后接着看一下handleApplicationCrashInner方法做了什么
    - 调用addErrorToDropBox将应用crash，进行封装输出。那么主要输出什么内容呢，待完善中……
    ``` java
    void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName,
            ApplicationErrorReport.CrashInfo crashInfo) {
        addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
        mAppErrors.crashApplication(r, crashInfo);
    }
    ```



#### 2.3 Native崩溃流程
- native_crash，顾名思义，就是native层发生的crash。其实他是通过一个NativeCrashListener线程去监控的。
    ```
    final class NativeCrashListener extends Thread {
        @Override
        public void run() {
            try {
                //1.一直循环地读peerFd文件,若发生存在,则进入consumeNativeCrashData
                while (true) {
                    try {
                        if (peerFd != null) {
                            //2.进入native crash数据处理流程
                            consumeNativeCrashData(peerFd);
                        }
                    } 
                }
            }
        }

        void consumeNativeCrashData(FileDescriptor fd) {
            try {
                    //3.启动NativeCrashReporter作为上报错误的新线程
                    final String reportString = new String(os.toByteArray(), "UTF-8");
                    (new NativeCrashReporter(pr, signal, reportString)).start();
            } catch (Exception e) {
            }
        }
    }
    ```
- 上报native_crash的线程-->NativeCrashReporter:
    ``` java
    class NativeCrashReporter extends Thread {
        @Override
        public void run() {
            try {
                //1.包装崩溃信息
                CrashInfo ci = new CrashInfo();
                //2.转到ams中处理,跟普通crash一致,只是类型不一样
                mAm.handleApplicationCrashInner("native_crash", mApp, mApp.processName, ci);
            } catch (Exception e) {
            }
        }
    }
    ```
- native crash跟到这里就结束了，后面的流程就是跟application crash一样，都会走到addErrorToDropBox中，这个最后在说。



#### 2.4 崩溃日志处理
- 为什么说addErrorToDropBox是殊途同归呢，因为无论是crash、native_crash、ANR或是wtf，最终都是来到这里，交由它去处理。那下面我们就来揭开它的神秘面纱吧。
    ``` java
    public void addErrorToDropBox(……) {
        //只有这几种类型的错误,才会进行上传
        final boolean shouldReport = ("anr".equals(eventType)
                || "crash".equals(eventType)
                || "native_crash".equals(eventType)
                || "watchdog".equals(eventType));
        //1.如果DropBoxManager没有初始化,或不是要上传的类型,则直接返回
        if (dbox == null || !dbox.isTagEnabled(dropboxTag)&& !shouldReport)
            return;
        //2.添加一些头部log信息 
        //3.添加崩溃进程和界面的信息
        //4.添加进程的状态到dropbox中
        //5.将dataFile文件定入dropbox中,一般只有anr时,会将traces文件通过该参数传递进来者,其他类型都不传.
        //6.如果是crash类型,会传入crashInfo,此时将其写入dropbox中
        if (shouldReport) {
            synchronized (mErrorListenerLock) {
                try {
                    //7.关键,在这里可以添加一个application error的接口，用来实现应用层接收崩溃信息
                    mIApplicationErrorListener.onError(fEventType,
                            packageName, fProcessName, subject, dropboxTag + "-" + uuid, crashInfo);
                } 
            }
        }
    }
    ```


#### 2.5 系统崩溃分析



### 03.崩溃处理入口
#### 3.1 Java处理异常入口
- UncaughtExceptionHandler接口，官方介绍为：
    ``` java
    @FunctionalInterface
    public interface UncaughtExceptionHandler {
        void uncaughtException(Thread t, Throwable e);
    }
    ```
    - Interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception.
    - When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.
- 翻译后大概的意思是
    - UncaughtExceptionHandler接口用于处理因为一个未捕获的异常而导致一个线程突然终止问题。
    - 当一个线程因为一个未捕获的异常即将终止时，Java虚拟机将通过调用getUncaughtExceptionHandler() 函数去查询该线程的UncaughtExceptionHandler并调用处理器的 uncaughtException方法将线程及异常信息通过参数的形式传递进去。如果一个线程没有明确设置一个UncaughtExceptionHandler，那么ThreadGroup对象将会代替UncaughtExceptionHandler完成该行为。如果ThreadGroup没有明确指定处理该异常，ThreadGroup将转发给默认的处理未捕获的异常的处理器。
- 线程出现未捕获异常后，JVM将调用Thread中的dispatchUncaughtException方法把异常传递给线程的未捕获异常处理器。
    ``` java
    public final void dispatchUncaughtException(Throwable e) {
        getUncaughtExceptionHandler().uncaughtException(this, e);
    }
    public UncaughtExceptionHandler getUncaughtExceptionHandler() {
        return uncaughtExceptionHandler != null ? uncaughtExceptionHandler : group;
    }
    ```


#### 3.2 异常处理常用api
##### 3.2.1 设置uncaughtExceptionPreHandler
- Thread中存在两个UncaughtExceptionHandler。一个是静态的defaultUncaughtExceptionHandler，另一个是非静态uncaughtExceptionHandler。
    ``` java
    private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
    private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
    ```
- defaultUncaughtExceptionHandler:设置一个静态的默认的UncaughtExceptionHandler。来自所有线程中的Exception在抛出并且未捕获的情况下，都会从此路过。进程fork的时候设置的就是这个静态的defaultUncaughtExceptionHandler，管辖范围为整个进程。
- uncaughtExceptionHandler:为单个线程设置一个属于线程自己的uncaughtExceptionHandler，辖范围比较小。
    ``` java
    //为单个线程设置一个属于线程自己的uncaughtExceptionHandler，捕获单个线程异常。设置后，线程可以完全控制它对未捕获到的异常作出响应的处理。
    thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            System.out.println("捕获单个线程："+t.toString() + " throwable : " + e.getMessage());
        }
    });
    //所有线程中的Exception在抛出并且未捕获的情况下，都会从此路过
    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            System.out.println("捕获所有线程："+t.toString() + " throwable : " + e.getMessage());
        }
    });
    ```


##### 3.2.2 没有设置uncaughtExceptionPreHandler
- 没有设置uncaughtExceptionHandler怎么办？如果没有设置uncaughtExceptionHandler，将使用线程所在的线程组来处理这个未捕获异常。线程组ThreadGroup实现了UncaughtExceptionHandler，所以可以用来处理未捕获异常。ThreadGroup类定义：
    ``` java
    private ThreadGroup group;
    //可以发现ThreadGroup类是集成Thread.UncaughtExceptionHandler接口的
    class ThreadGroup implements Thread.UncaughtExceptionHandler{}
    ```
- 然后看一下ThreadGroup中实现uncaughtException(Thread t, Throwable e)方法，代码如下
    - 默认情况下，线程组处理未捕获异常的逻辑是，首先将异常消息通知给父线程组，然后尝试利用一个默认的defaultUncaughtExceptionHandler来处理异常，
    - 如果没有默认的异常处理器则将错误信息输出到System.err。也就是JVM提供给我们设置每个线程的具体的未捕获异常处理器，也提供了设置默认异常处理器的方法。
    ``` java
    public void uncaughtException(Thread t, Throwable e) {
        if (parent != null) {
            parent.uncaughtException(t, e);
        } else {
            //返回线程由于未捕获到异常而突然终止时调用的默认处理程序。如果返回值为 null，则没有默认处理程序。
            Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();
            if (ueh != null) {
                ueh.uncaughtException(t, e);
            } 
        }
    }
    ```





#### 3.3 注意事项说明
- 难道要为每一个线程创建UncaughtExceptionHandler吗？
    - 应用程序通常都会创建很多线程，如果为每一个线程都设置一次 UncaughtExceptionHandler 未免太过麻烦。
    - 既然出现未处理异常后 JVM 最终都会调 getDefaultUncaughtExceptionHandler()，那么我们可以在应用启动时设置一个默认的未捕获异常处理器。即调用Thread.setDefaultUncaughtExceptionHandler(handler)
- setDefaultUncaughtExceptionHandler被调用多次如何理解？
    - Thread.setDefaultUncaughtExceptionHandler(handler) 方法如果被多次调用的话，会以最后一次传递的 handler 为准。
    - 所以如果用了第三方的统计模块，可能会出现失灵的情况。对于这种情况，在设置默认 handler 之前，可以先通过 getDefaultUncaughtExceptionHandler() 方法获取并保留旧的 handler，然后在默认 handler 的uncaughtException 方法中调用其他 handler 的 uncaughtException 方法，保证都会收到异常信息。


#### 3.5 理解异常栈轨迹链
- 来看一个简单的崩溃日志，如下所示：
    - 那么这个崩溃日志，是怎么形成的崩溃异常链的？
    ``` java
    Process: com.com.yc.ycandroidtool, PID: 16060
    java.lang.NullPointerException: Attempt to invoke virtual method 'void android.app.Activity.finish()' on a null object reference
        at com.com.yc.toollib.crash.CrashTestActivity.onClick(CrashTestActivity.java:48)
        at android.view.View.performClick(View.java:7187)
        at android.view.View.performClickInternal(View.java:7164)
        at android.view.View.access$3500(View.java:813)
        at android.view.View$PerformClick.run(View.java:27626)
        at android.os.Handler.handleCallback(Handler.java:883)
        at android.os.Handler.dispatchMessage(Handler.java:100)
        at android.os.Looper.loop(Looper.java:230)
        at android.app.ActivityThread.main(ActivityThread.java:7742)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1034)
    ```
- 在这个崩溃日志，可以发现
    - ZygoteInit.main ---->  RuntimeInit ----> ActivityThread.main ---->  Handler.dispatchMessage ---> View.performClick ---> CrashTestActivity.onClick
    - 观察可知，这个崩溃信息则是记录着app从启动到崩溃中的流程日志。



#### 3.6 StackTraceElement
- 此类在 java.lang 包下
    - public final class StackTraceElement extends Object implements Serializable
        - 堆栈跟踪元素，它由 Throwable.getStackTrace() 返回。每个元素表示单独的一个【堆栈帧】。
        - 所有的堆栈帧（堆栈顶部的那个堆栈帧除外）都表示一个【方法调用】。堆栈顶部的帧表示【生成堆栈跟踪的执行点】。通常，这是创建对应于堆栈跟踪的 throwable 的点。
- 构造方法
    - public StackTraceElement(String declaringClass, String methodName, String fileName, int lineNumber)
        - 创建表示指定【执行点】的【堆栈跟踪元素】。参数：
        - declaringClass - 类的完全限定名，该类包含由堆栈跟踪元素所表示的执行点
        - methodName - 方法名，该方法包含由堆栈跟踪元素所表示的执行点
        - fileName - 文件名，该文件包含由堆栈跟踪元素所表示的执行点；如果该信息不可用，则该参数为 null
        - lineNumber - 源代码行的行号，该代码行包含由堆栈跟踪元素所表示的执行点；如果此信息不可用，则该参数为负数。值 -2 表示包含执行点的方法是一个本机方法
- 普通方法
    - String getClassName() 返回类的完全限定名，该类包含由该堆栈跟踪元素所表示的执行点。
    - String getFileName() 返回源文件名，该文件包含由该堆栈跟踪元素所表示的执行点。
    - int getLineNumber() 返回源行的行号，该行包含由该堆栈该跟踪元素所表示的执行点。
    - String getMethodName() 返回方法名，此方法包含由该堆栈跟踪元素所表示的执行点。
    - boolean isNativeMethod() 如果包含由该堆栈跟踪元素所表示的执行点的方法是一个本机方法，则返回 true。
- 重写的Object的方法
    - boolean equals(Object obj) 如果指定的对象是另一个 StackTraceElement 实例，并且该对象表示的【执行点】与该实例的相同，则返回 ture。
    - int hashCode() 返回此堆栈跟踪元素的哈希码值。
    - String toString() 返回表示该堆栈跟踪元素的字符串。




### 04.崩溃监听思路
#### 4.1 实现崩溃监听
- handler将会报告线程终止和不明原因异常这个情况，如果没有自定义handler， 线程管理组就被默认为报告异常的handler。
    - ThreadHandler 这个类就是实现了UncaughtExceptionHandler这个接口，伪代码代码如下所示
    ``` java
    public class ThreadHandler implements Thread.UncaughtExceptionHandler {
        private Thread.UncaughtExceptionHandler mDefaultHandler;
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            if (mDefaultHandler != null) {
                //当给定的线程因为发生了未捕获的异常而导致终止时将通过该方法将线程对象和异常对象传递进来。
                mDefaultHandler.uncaughtException(t, e);
            } else {
                //否则自己处理
            }
        }
        public void init(Application ctx) {
            mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();
            Thread.setDefaultUncaughtExceptionHandler(this);
        }
    }
    ```



#### 4.2 处理捕获异常



#### 4.4 崩溃日志收集
##### 4.4.1 收集信息说明
- 收集崩溃时的基本信息
    - 进程（前台进程还是后台进程）
    - 线程（是否是 UI 线程）
    - 崩溃堆栈（具体崩溃在系统的代码，还是我们自己的代码里面）
    - 崩溃堆栈类型（Java 崩溃、Native 崩溃 or ANR）
- 收集崩溃时的系统信息
    - 机型、系统、厂商、CPU、ABI、Linux 版本等。（寻找共性）
    - Logcat。（包括应用、系统的运行日志，其中会记录 App 运行的一些基本情况）
- 收集崩溃时的内存信息（OOM、ANR、虚拟内存耗尽等，很多崩溃都跟内存有直接关系）
    - 系统剩余内存。（系统可用内存很小 – 低于 MemTotal 的 10%时，OOM、大量 GC、系统频繁自杀拉起等问题都非常容易出现）
    - 虚拟内存（但是很多类似OOM、tgkill 等问题都是虚拟内存不足导致的）
    - 应用使用内存（得出应用本身内存的占用大小和分布）
    - 线程数
- 收集崩溃时的应用信息
    - 崩溃场景（崩溃发生在哪个 Activity 或 Fragment，发生在哪个业务中）
    - 关键操作路径（记录关键的用户操作路径，这对我们复现崩溃会有比较大的帮助）
    - 其他自定义信息（不同应用关心的重点不一样。例如运行时间、是否加载了补丁、是否是全新安装或升级等）


##### 4.4.2 收集日志详细说明
- Logcat。这里包括应用、系统的运行日志。
    - 由于系统权限问题，获取到的 Logcat可能只包含与当前 App 相关的。其中系统的 event logcat 会记录 App 运行的一些基本情况，记录在文件 /system/etc/event-log-tags 中。
    ``` java
    system logcat:
    10-25 17:13:47.788 21430 21430 D dalvikvm: Trying to load lib ...
    event logcat:
    10-25 17:13:47.788 21430 21430 I am_on_resume_called: 生命周期
    10-25 17:13:47.788 21430 21430 I am_low_memory: 系统内存不足
    10-25 17:13:47.788 21430 21430 I am_destroy_activity: 销毁 Activty
    10-25 17:13:47.888 21430 21430 I am_anr: ANR 以及原因
    10-25 17:13:47.888 21430 21430 I am_kill: APP 被杀以及原因
    ```
    - 机型、系统、厂商、CPU、ABI、Linux 版本等。–> 寻找共性
    - 设备状态：是否 root、是否是模拟器。一些问题是由 Xposed 或多开软件造成，对这部分问题我们要区别对待。
- 内存信息
    - OOM、ANR、虚拟内存耗尽等，很多崩溃都跟内存有直接关系。
    - 系统剩余内存。关于系统内存状态，可以直接读取文件 /proc/meminfo。当系统可用内存很小（低于 MemTotal 的 10%）时，OOM、大量 GC、系统频繁自杀拉起等问题都非常容易出现。
    - 应用使用内存。包括 Java 内存、RSS（Resident Set Size）、PSS（Proportional Set Size），我们可以得出应用本身内存的占用大小和分布。PSS 和 RSS 通过 /proc/self/smap 计算，可以进一步得到例如 apk、dex、so 等更加详细的分类统计。
    - 虚拟内存。虚拟内存可以通过 /proc/self/status 得到，通过 /proc/self/maps 文件可以得到具体的分布情况。有时候我们一般不太重视虚拟内存，但是很多类似OOM、tgkill 等问题都是虚拟内存不足导致的。
        ``` java
        opened files count 812:
        0 -> /dev/null
        1 -> /dev/log/main4
        2 -> /dev/binder
        3 -> /data/data/com.crash.sample/files/test.config
        ```
    - 线程数。当前线程数大小可以通过上面的 status 文件得到，一个线程可能就占 2MB 的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据我的经验来说，如果线程数超过 400 个就比较危险。需要将所有的线程id 以及对应的线程名输出到日志中，进一步排查是否出现了线程相关的问题。
        ``` java
        threads count 412:
        1820 com.sample.crashsdk
        1844 ReferenceQueueD
        1869 FinalizerDaemon
        ```

#### 4.7 日志发送邮箱



#### 4.8 崩溃重启实践
- 第一种方式，开启一个新的服务KillSelfService，用来重启本APP。
    ``` java
    CrashToolUtils.reStartApp1(App.this,1000);
    ```
- 第二种方式，使用闹钟延时，然后重启app
    ``` java
    CrashToolUtils.reStartApp2(App.this,1000, MainActivity.class);
    ```
- 第三种方式，检索获取项目中LauncherActivity，然后设置该activity的flag和component启动app
    ``` java
    CrashToolUtils.reStartApp3(AppManager.getAppManager().currentActivity());
    ```





### 01.概述
#### 1.1 项目背景
- 通过简要的语言描述项目背景以及要达成的业务目标。

#### 1.2 设计目标
- 需求的背后往往会带来技术的重构/优化，或者单纯的完成需求，如果有必要，需要从技术角度给出方案设计的目标
- 比如对于图片下载需求，需要完成相关的功能，那么设计目标主要有完成异步下载、存储、缓存设计、图片解码、渲染等功能。
- 比如对于优化需求，目标可以是达到一个什么效果？可以是帧率的、Crash率的、卡顿的等。
- 比如对于重构需求，目标可以是加强扩展、解决问题、提升效率等。



### 02.方案设计
- 方案设计是技术文档的最核心部分，主要包括了整体架构和功能设计，这里需要体现：
- 设计的初衷：概要描述方案设计的思考，可以是为了扩展性的考虑，可以是提升性能
关键技术点的思考：描述关键技术选型的思考，比如要解耦，业内解耦方案能有router、Target-Action等，讲清楚选择的思考
- 技术上的折中/取舍：在做技术设计的时候，往往要的很多，但时间有限，那么这个需要讲一下折中与取舍，以及接下来的规划、计划



#### 2.1 整体架构
- 整体架构的组成需要有一张完成的架构设计图，描述清楚具体的分层以及层与层之间的关系
- 比如传统的开发会分为三层，展示层、逻辑层、数据层
    - 展示层的设计：视图的构成、视图间的耦合关系、具体的交互逻辑
    - 逻辑层的设计：支撑展示层所需要的数据、从数据层获取数据的加工、业务相关逻辑（比如轮询服务）
    - 数据层的设计：数据的获取方式以及存储方式，文件、数据库、本地、网络



#### 2.2 功能设计
- 功能设计包含但不限于以下几个部分：逻辑流程图、接口设计图、与外部的模块间依赖关系

#### 2.2.1 关键流程图
- 设计中的最复杂、最关键的逻辑需要画出流程图，实在画不出的流程图需要用语言描述清楚。
- 关键流程需要有逻辑流程图，帮助其他同学理解功能的关键节点逻辑


##### 2.2.2 接口设计图
- 通过UML类图来展示类间关系，描述清楚接口设计的一些思考原则
    - 提供的接口，往往接口设计为了完成相关逻辑



##### 2.2.3 模块间依赖关系
- 描述清楚和哪些模块存在依赖关系以及原因，比如首页依赖于购物车模块，需要解释清楚要强耦合，有没有办法解耦
    - App内部模块间依赖
    - App外部依赖


#### 2.3 UI/动效设计
- 客户端开发有很大一部分精力在UI/动效上，对于复杂的静态UI和复杂动效，需要给出实现方案和选型逻辑
- 静态UI
    - 只有复杂的UI才需要给出设计方案，例如核心页面大重构、复杂的协调布局等
- 复杂动效
    - 复杂的动效是端上容易踩坑的关键点，需要给出实现方案的对比、选型等，为验证动效可行性，可以给出动效Demo



### 03.其他设计（Optional）
- 以下部分是可选项，主要是从异常、兼容性、性能、稳定性、灰度、降级等维护来设计。


#### 3.1 性能设计
- 有些业务项目可能会考虑性能，比如列表页，卡顿、流畅度怎么样？如何评估？
- 有些技术项目可能也会考虑性能，比如数据库设计，检索性能如何？是否有瓶颈，如何评估？


#### 3.2 稳定性设计
- 大的项目需要考虑性能如何保障？
    - 比如方案 Review
    - 比如自测Case Review，加强自测
    - 比如单测


#### 3.3 灰度设计
- 核心关键功能需要有A/B设计
- 比如UIWebview替换为WKWebview，其中存在很多不确定因素，需要做好灰度设计


#### 3.4 降级设计
- 在做一些新技术尝试时，需要考虑降级设计
    - 比如RN、swift、weex引入对原有业务造成影响的，需要有兜底，可降级
    - 参考资料
    - 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


#### 3.5 异常设计
- 大部分业务需求都会涉及到异常处理，在关心主流程的同时需要关注异常场景怎么保证正确性？
    - 比如用户操作中途退出、网络异常、数据被清理等


#### 3.6 兼容性设计
- 业务逻辑一般不会涉及到兼容性，但UI/动效需求容易遇到兼容性问题，也是提测时需要让QA关注的
    - 比如独立端/嵌入端、高低版本API适配等


### 04.排期与计划
- 排期计划主要针对周期较长项目的时间补充，对于小型项目不需要，例如：
    - 正常的版本业务需求，5pd以下，不需要给出排期计划；5pd或者以上，可以简单描述一下排期和提测时间
    - 跨版本的大型业务需求、重构专项等，需要给出详细的排期计划
    - 研发自驱的技术优化项目，需要给出详细的排期计划


### 05.参考资料
- 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。





#### 参考博客
- native crash收集流程分析
    - https://www.jianshu.com/p/77a53d7b642e
- 鹰眼Android平台崩溃监控实践
    - https://mp.weixin.qq.com/s/YSrXx_oTJkp0kRDF6XvzdQ
- Android程序Crash时的异常上报
    - https://blog.csdn.net/singwhatiwanna/article/details/17289479
- Java全局异常处理
    - https://www.lagou.com/lgeduarticle/107790.html
- 手把手讲解 Android Hook入门Demo
    - https://www.jianshu.com/p/74c12164ffca?tdsourcetag=s_pcqq_aiomsg
- 反射优化
    - https://segmentfault.com/a/1190000020986852?utm_source=sf-related



#### 参考项目
- 爱奇艺
    - https://github.com/iqiyi/xCrash
    - https://github.com/JZ-Darkal/AndroidHttpCapture



