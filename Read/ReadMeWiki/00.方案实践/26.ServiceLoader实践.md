#### 目录介绍
- 概述
    - 项目背景
    - 设计目标
- 方案设计
    - 整体架构
        - 架构设计图
        - UML设计图
    - 功能设计
        - 关键流程图
        - 接口设计图
        - 模块间依赖关系
- 其他设计（Optional）
    - 性能设计
    - 稳定性设计
    - 灰度设计
    - 降级设计
    - 异常设计
- 排期与计划
    - 排期节点
    - 落实反馈



思考一下问题
1.项目业务组件依赖sdk组件，如何使用组件中功能且减少代码耦合性？
2.使用注解表记类，编译期扫描class文件如何生成SPI配置⽂件，又如何生成ServiceRegistry类？
举一个案例
比如想实现一个推送的功能，不管是在那个组件中能快速使用，减少耦合性。核心还是用到接口+实现类+反射创建对象的形式。
注解类：ServiceProvider，ServiceProviderInterface。注意注解标注是运行时……
定义推送的接口：PushServiceProvider，使用注解ServiceProviderInterface标记
定义推送接口实现类：PushServiceImpl，接口具体实现类，使用注解ServiceProvider标记
apt生成类：PushService接口委托类，ServiceRegistry
SPI机制是什么
SPI ，全称为 Service Provider Interface，是一种服务发现机制。
它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类，一般用来启用框架扩展和替换组件。
作用是什么
解耦合：把接口的具体实现类的全名写成配置文件，然后进行读取，生成具体的实现类对象，进行服务的调用，从而实现解耦。
SPI机制原理
1.使用@ServiceProvider来标注该类提供哪些服务接口，标识服务的优先级与别名(加载时可通过别名指定加载某个服务)
2.在构建过程中，java代码编译完成之后，执行自定义的gradle任务，扫描所有class，生成SPI配置文件，存放接口、接口实现类(服务)与实现类优先级信息
3.解析SPI配置文件，通过Javapoet生成ServiceRegistry.java，将配置文件中接口与实现类的映射关系转译成代码，生成静态代码块可在类加载时自动完成 服务的注册
4.把ServiceRegistry.java编译成class文件，被ClassLoader加载后可在ServiceLoader中正常引用完成服务的创建
遇到的问题
1.ServiceRegistry是如何解析生成该编译文件的，这块还要在熟悉下apt，找到项目中具体的实现代码分析下。
2.比如在PushService代码中，成员位置调用ServiceLoader.laod创建接口实现类对象，如果不是单利创建对象，那么会不会多次调用load创建多次对象？是否可以改成在静态final形式或者在静态代码块中调用？
SPI原理图

问题解答说明
1.如何扫描所有class？
写一个plugin插件，开启一个task任务，然后去加载代码文件目录或者jar，遍历取后缀名为.class的字节码并存储到list集合中。
2.委派代理的作用？
接口+接口实现类+接口委派类，调用的时候使用委派类，而具体的实现逻辑细节在实现类中。主要是起到代码隔离和解耦合的操作。
3.如何生成apt代码？
使用javaopet库，然后通过拼接类的路径，类的修饰符，返回值，参数等多个元素，最后用jarvFile写到指定的目录文件。
4.ServiceLoader.laod多次会怎样？
会创建多个对象。所以这个一般都是保持单利的形式
5.如何实现priority优先级？
首先获取ServiceProvider注解，然后通过注解拿到里面的参数。然后遍历所有被注解标记的类，最后把优先级写到file文件中。


