#### 目录介绍
- 01.磁盘沙盒的概述
    - 1.1 项目背景说明
    - 1.2 沙盒作用
    - 1.3 设计目标
- 02.Android存储概念
    - 2.1 存储划分介绍
    - 2.2 机身内部存储
    - 2.3 机身外部存储
    - 2.4 SD卡外部存储
    - 2.5 总结和梳理下
- 03.方案基础设计
    - 3.1 整体架构图
    - 3.2 UML设计图
    - 3.3 关键流程图
    - 3.4 接口设计图
    - 3.5 模块间依赖关系
- 04.一些技术要点说明
    - 4.1 使用队列管理Fragment栈
    - 4.2 File文件列表
    - 4.3 不同版本访问权限
    - 4.4 访问文件操作
    - 4.5 10和11权限说明
    - 4.6 分享文件给第三方
    - 4.7 打开图片资源
- 05.其他设计实践说明
    - 5.1 性能设计
    - 5.2 稳定性设计
    - 5.3 灰度设计
    - 5.4 降级设计
    - 5.5 异常设计


### 01.磁盘沙盒的概述
#### 1.1 项目背景说明
- app展示在数据量多且刷新频繁的情况下，为提升用户体验，通常会对上次已有数据做内存缓存或磁盘缓存，以达到快速展示数据的目的。缓存的数据变化是否正确、缓存是否起到对应作用是QA需要重点测试的对象。
- android缓存路径查看方法有哪些呢？将手机打开开发者模式并连接电脑，在pc控制台输入cd /data/data/目录，使用adb主要是方便测试(删除，查看，导出都比较麻烦)。
- 如何简单快速，傻瓜式的查看缓存文件，操作缓存文件，那么该项目小工具就非常有必要呢！采用可视化界面读取缓存数据，方便操作，直观也简单。


#### 1.2 沙盒作用
- 可以通过该工具查看缓存文件
    - 快速查看`data/data/包名`目录下的缓存文件。
    - 快速查看`/sdcard/Android/data/包名`下存储文件。
- 对缓存文件处理
    - 支持查看file文件列表数据，打开缓存文件查看数据详情。还可以删除缓存对应的文件或者文件夹，并且友好支持分享到外部。
    - 能够查看缓存文件修改的信息，修改的时间，缓存文件的大小，获取文件的路径等等。都是在可视化界面上处理。


#### 1.3 设计目标
- 可视化界面展示
    - 
- 多种处理文件操作
    - 针对file文件夹，或者file文件，长按可以出现弹窗，让测试选择是否删除文件。
    - 点击file文件夹，则拿到对应的文件列表，然后展示。点击file直到是具体文件(文本，图片，db，json等非file文件夹)跳转详情。
- 一键接入该工具
    - FileExplorerActivity.startActivity(MainActivity.this);


### 02.Android存储基本概念
#### 2.1 存储划分介绍
- 存储划分介绍
    - 手机空间存储划分为两部分：1、机身存储；2、SD卡外部存储
    - 机身存储划分为两部分：1、内部存储；2、外部存储
- 机身内部存储
    - 放到data/data目录下的缓存文件，一般使用adb无法查看该路径文件，私有的。程序卸载后，该目录也会被删除。
- 机身外部存储
    - 放到/storage/emulated/0/目录下的文件，有共享目录，还有App外部私有目录，还有其他目录。App卸载的时候，相应的app创建的文件也会被删除。
- SD卡外部存储
    - 放到sd库中目录下文件，外部开放的文件，可以查看。


#### 2.2 机身内部存储
- 想一下平时使用的持久化方案：这些文件都是默认放在内部存储里。
    - SharedPreferences---->适用于存储小文件
    - 数据库---->存储结构比较复杂的大文件
- 如果包名为：com.yc.helper，则对应的内部存储目录为：/data/data/com.yc.helper/
    - 第一个"/"表示根目录，其后每个"/"表示目录分割符。内部存储里给每个应用按照其包名各自划分了目录
    - 每个App的内部存储空间仅允许自己访问(除非有更高的权限，如root)，程序卸载后，该目录也会被删除。
- 机身内部存储一般存储那些文件呢？大概有以下这些
    - cache-->存放缓存文件
    - code_cache-->存放运行时代码优化等产生的缓存
    - databases-->存放数据库文件
    - files-->存放一般文件
    - lib-->存放App依赖的so库 是软链接，指向/data/app/ 某个子目录下
    - shared_prefs-->存放 SharedPreferences 文件
- 那么怎么通过代码访问到这些路径的文件呢？代码如下所示
    ``` java
    context.getCacheDir().getAbsolutePath()
    context.getCodeCacheDir().getAbsolutePath()
    //databases 直接通过getDatabasePath(name)获取
    context.getFilesDir().getAbsolutePath()
    //lib，暂时还不知道怎么获取该路径
    //shared_prefs 直接通过SharedPreferences获取
    ```


#### 2.3 机身外部存储
- 存放位置，主要有那些？如下所示，根目录下几个需要关注的目录：
    - /data/        这个是前面说的私有文件
    - /sdcard/      /sdcard/是软链接，指向/storage/self/primary
    - /storage/     /storage/self/primary/是软链接，指向/storage/emulated/0/
- 也就是说/sdcard/、/storage/self/primary/ 真正指向的是/storage/emulated/0/
    - 下面这个是用adb查看 /storage/emulated/0 路径资源
    ``` java
    a51x:/storage $ ls
    emulated  self
    a51x:/storage $ cd emulated/                                                   
    a51x:/storage/emulated $ ls
    ls: .: Permission denied
    1|a51x:/storage/emulated $ cd 0
    a51x:/storage/emulated/0 $ ls
    //省略 /storage/emulated/0 下的文件
    ```
- 然后来看下 /storage/emulated/0/ 存储的资源有哪些？如下，分为三部分：
- 第一种：共享存储空间
    - 也就是所有App共享的部分，比如相册、音乐、铃声、文档等：
    - DCIM/ 和 Pictures/-->存储图片
    - DCIM/、Movies/ 和 Pictures-->存储视频
    - Alarms/、Audiobooks/、Music/、Notifications/、Podcasts/ 和 Ringtones/-->存储音频文件
    - Download/-->下载的文件
    - Documents-->存储如.pdf类型等文件
- 第二种：App外部私有目录
    - Android/data/--->存储各个App的外部私有目录。
    - 与内部存储类似，命名方式是：Android/data/xx------>xx指应用的包名。如：/sdcard/Android/data/com.yc.helper
- 第三种：其它目录
    - 比如各个App在/sdcard/目录下创建的目录，如支付宝创建的目录：alipay/，高德创建的目录：amap/，腾讯创建的目录：com.tencent.xx/等。
- 那么怎么通过代码访问到这些路径的文件呢？代码如下所示
    - 第一种：通过ContentProvider访问，共享存储空间中的图片，视频，音频，文档等资源
    - 第二种：可以看出再/sdcard/Android/data/目录下生成了com.yc.helper/目录，该目录下有两个子目录分别是：files/、cache/。当然也可以选择创建其它目录。App卸载的时候，两者都会被清除。
    ``` java
    context.getExternalCacheDir().getAbsolutePath();
    context.getExternalFilesDir(null).getAbsolutePath();
    ```
    - 第三种：只要拿到根目录，就可以遍历寻找其它子目录/文件。


#### 2.4 SD卡外部存储
- 当给设备插入SD卡后，查看其目录：/sdcard/ ---> 依然指向/storage/self/primary，继续来看/storage/:
    - 可以看出，多了sdcard1，软链接指向了/storage/77E4-07E7/。
    ``` java
    
    ```
- 访问方式，跟获取外部存储-App私有目录方式一样。
    ``` java
    File[] fileList = context.getExternalFilesDirs(null);
    ```
    - 返回File对象数组，当有多个外部存储时候，存储在数组里。返回的数组有两个元素，一个是自带外部存储存储，另一个是插入的SD卡。


#### 2.5 总结和梳理下
- Android存储有三种：手机内部存储、手机自带外部存储、SD卡扩展外部存储等。
- 内部存储与外部存储里的App私有目录
    - 相同点：
        - 1、属于App专属，App自身访问两者无需任何权限。
        - 2、App卸载后，两者皆被删除。
        - 3、两者目录下增加的文件最终会被统计到"设置->存储和缓存"里。
    - 不同点：
        - /data/data/com.yc.helper/ 位于内部存储，一般用于存储容量较小的，私密性较强的文件。
        - 而/sdcard/Android/data/com.yc.helper/ 位于外部存储，作为App私有目录，一般用于存储容量较大的文件，即使删除了也不影响App正常功能。
- 在设置里的"存储与缓存"项，有清除数据和清除缓存，两者有何区别？
    - 当点击"清除数据" 时：
        - 内部存储/data/data/com.yc.helper/cache/、 /data/data/com.yc.helper/code_cache/目录会被清空
        - 外部存储/sdcard/Android/data/com.yc.helper/cache/ 会被清空
    - 当点击"清除缓存" 时：
        - 内部存储/data/data/com.yc.helper/下除了lib/，其余子目录皆被删除
        - 外部存储/sdcard/Android/data/com.yc.helper/被清空
        - 这种情况，相当于删除用户sp，数据库文件，相当于重置了app



### 04.一些技术要点说明
#### 4.1 使用队列管理Fragment栈
- 该磁盘沙盒file工具页面的组成部分是这样的
    - FileExplorerActivity + FileExplorerFragment(多个，file列表页面) + TextDetailFragment(一个，file详情页面)
- 针对磁盘file文件列表`FileExplorerFragment`页面，点击file文件item
    - 如果是文件夹则是继续打开跳转到file文件列表`FileExplorerFragment`页面，否则跳转到文件详情页面
- 处理任务栈返回逻辑。举个例子现在列表`FileExplorerFragment`当作B，文件详情页面当作C，宿主Activity当作A。也就是说，点击返回键，依次关闭了fragment直到没有，回到宿主activity页面。再次点击返回键，则关闭activity！
    - 可能存在的任务栈是：打开A1->打开B1->打开C1
    - 那么点击返回键按钮，返回关闭的顺序则是：关闭C1->关闭B1->关闭A1
- Fragment回退栈处理方式
    - 第一种方案：创建一个栈(先进后出)，打开一个`FileExplorerFragment`列表页面(`push`一个`fragment`对象到队列中)，关闭一个列表页面(`remove`最上面那个`fragment`对象，然后调用`FragmentManager`中`popBackStack`操作关闭`fragment`)
    - 第二种方案：通过fragmentManager获取所有fragment对象，返回一个list，当点击返回的时候，调用popBackStack移除最上面一个
- 具体处理该场景中回退逻辑
    - 首先定义一个双端队列ArrayDeque，用来存储和移除元素。内部使用数组实现，可以当作栈来使用，功能非常强大。
    - 当开启一个fragment页面的时候，调用push(相当于addFirst在栈顶添加元素)来存储fragment对象。代码如下所示
        ``` java
        public void showContent(Class<? extends Fragment> target, Bundle bundle) {
            try {
                Fragment fragment = target.newInstance();
                if (bundle != null) {
                    fragment.setArguments(bundle);
                }
                FragmentManager fm = getSupportFragmentManager();
                FragmentTransaction fragmentTransaction = fm.beginTransaction();
                fragmentTransaction.add(android.R.id.content, fragment);
                //push等同于addFirst，添加到第一个
                mFragments.push(fragment);
                //add等同于addLast，添加到最后
                //mFragments.add(fragment);
                fragmentTransaction.addToBackStack("");
                //将fragment提交到任务栈中
                fragmentTransaction.commit();
            } catch (InstantiationException exception) {
                FileExplorerUtils.logError(TAG + exception.toString());
            } catch (IllegalAccessException exception) {
                FileExplorerUtils.logError(TAG + exception.toString());
            }
        }
        ```
    - 当关闭一个fragment页面的时候，调用removeFirst(相当于弹出栈顶的元素)移除fragment对象。代码如下所示
        ``` java
        @Override
        public void onBackPressed() {
            if (!mFragments.isEmpty()) {
                Fragment fragment = mFragments.getFirst();
                if (fragment!=null){
                    //移除最上面的一个
                    mFragments.removeFirst();
                }
                super.onBackPressed();
                //如果fragment栈为空，则直接关闭activity
                if (mFragments.isEmpty()) {
                    finish();
                }
            } else {
                super.onBackPressed();
            }
        }
      
        /**
         * 回退fragment任务栈操作
         * @param fragment                  fragment
         */
        public void doBack(Fragment fragment) {
            if (mFragments.contains(fragment)) {
                mFragments.remove(fragment);
                FragmentManager fm = getSupportFragmentManager();
                //回退fragment操作
                fm.popBackStack();
                if (mFragments.isEmpty()) {
                    //如果fragment栈为空，则直接关闭宿主activity
                    finish();
                }
            }
        }
        ```


### 4.3 File文件列表




#### 4.4 不同版本访问权限
- Android 6.0 之前访问方式
    - Android 6.0 之前是无需申请动态权限的，在AndroidManifest.xml 里声明存储权限。就可以访问共享存储空间、其它目录下的文件。
    ``` java
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    ```
- Android 6.0 之后的访问方式
    - Android 6.0 后需要动态申请权限，除了在AndroidManifest.xml 里声明存储权限外，还需要在代码里动态申请。
    ``` java
    //申请权限
    if (ContextCompat.checkSelfPermission(mActivity,
            Manifest.permission.WRITE_EXTERNAL_STORAGE)
            != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(mActivity,
                new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, CODE);
    } 
    ```




#### 4.5 访问文件操作
- 权限申请成功后，即可对自带外部存储之共享存储空间和其它目录进行访问。分别以共享存储空间和其它目录为例，阐述访问方式：
- 访问媒体文件(共享存储空间)。目的是拿到媒体文件的路径，有两种方式获取路径：
    - 以图片为例，假设图片存储在/sdcard/Pictures/目录下。路径：/storage/emulated/0/Pictures/yc.png，拿到路径后就可以解析并获取Bitmap。
    ``` java
    //获取目录：/storage/emulated/0/
    File rootFile = Environment.getExternalStorageDirectory();
    String imagePath = rootFile.getAbsolutePath() + File.separator + Environment.DIRECTORY_PICTURES + File.separator + "yc.png";
    Bitmap bitmap = BitmapFactory.decodeFile(imagePath);
    ```
    - 通过MediaStore获取路径
    ``` java
    ContentResolver contentResolver = context.getContentResolver();
    Cursor cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);
    while(cursor.moveToNext()) {
        String imagePath = cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));
        Bitmap bitmap = BitmapFactory.decodeFile(imagePath);
        break;
    }
    ```
- 访问文档和其它文件(共享存储空间)。
    - 直接构造路径。与媒体文件一样，可以直接构造路径访问。
- 访问其它目录
    - 直接构造路径。与媒体文件一样，可以直接构造路径访问。
- 总结一下共同点
    - 访问目录/文件可通过如下两个方法：1、通过路径访问。路径可以直接构造也可以通过MediaStore获取。 2、通过Uri访问。Uri可以通过MediaStore或者SAF(存储访问框架，通过intent调用startActivity访问)获取。



#### 4.6 10和11权限说明
- Android10权限改变
    - 比如能够直接在/sdcard/目录下创建目录/文件。可以看出/sdcard/目录下，如淘宝、qq、qq浏览器、微博、支付宝等都自己建了目录。
    - 这么看来，导致目录结构很乱，而且App卸载后，对应的目录并没有删除，于是就是遗留了很多"垃圾"文件，久而久之不处理，用户的存储空间越来越小。
- 之前文件创建弊端如下
    - 卸载App也不能删除该目录下的文件
    - 在设置里"清除数据"或者"清除缓存"并不能删除该目录下的文件
    - App可以随意修改其它目录下的文件，如修改别的App创建的文件等，不安全
- 为什么要在/sdcard/目录下新建app存储的目录
    - 此处新建的目录不会被设置里的App存储用量统计，让用户"看起来"自己的App占用的存储空间很小。还有就是方便操作文件



#### 4.5 分享文件给第三方
- https://www.jianshu.com/p/d71afdf9c90a



#### 4.7 打开图片资源
- 首先判断文件，是否是图片资源，如果是图片资源，则跳转到打开图片详情。目前只是根据文件的后缀名来判断(对文件名称以.进行裁剪获取后缀名)是否是图片。
    ``` java
    if (FileExplorerUtils.isImage(fileInfo)) {
        Bundle bundle = new Bundle();
        bundle.putSerializable("file_key", fileInfo);
        showContent(ImageDetailFragment.class, bundle);
    } 
    ```
- 打开图片跳转详情，这里面为了避免打开大图OOM，因此需要对图片进行压缩，目前该工具主要是内存压缩和尺寸缩放方式。大概的原理如下
    - 例如，我们的原图是一张 2700 * 1900 像素的照片，加载到内存就需要 19.6M 内存空间，但是，我们需要把它展示在一个列表页中，组件可展示尺寸为 270 * 190，这时，我们实际上只需要一张原图的低分辨率的缩略图即可（与图片显示所对应的 UI 控件匹配），那么实际上 270 * 190 像素的图片，只需要 0.2M 的内存即可。这个采用缩放比压缩。
    - 加载图片，先加载到内存，再进行操作吗，可以如果先加载到内存，好像也不太对，这样只接占用了 19.6M + 0.2M 2份内存了，而我们想要的是，在原图不加载到内存中，只接将缩放后的图片加载到内存中，可以实现吗？
    - 进行内存压缩，要将BitmapFactory.Options的inJustDecodeBounds属性设置为true，解析一次图片。注意这个地方是核心，这个解析图片并没有生成bitmap对象(也就是说没有为它分配内存控件)，而仅仅是拿到它的宽高等属性。
    - 然后将BitmapFactory.Options连同期望的宽度和高度一起传递到到calculateInSampleSize方法中，就可以得到合适的inSampleSize值了。这一步会压缩图片。之后再解析一次图片，使用新获取到的inSampleSize值，并把inJustDecodeBounds设置为false，就可以得到压缩后的图片了。




- Android-10、11-存储完全适配(上)
- https://www.jianshu.com/p/3cbb7febbfa3
- http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=797158127
- https://www.jianshu.com/p/d71afdf9c90a

