#### 目录介绍
- 01.磁盘沙盒的概述
    - 1.1 项目背景说明
    - 1.2 沙盒作用
    - 1.3 设计目标
- 02.方案基础设计
    - 2.1 整体架构图
    - 2.2 UML设计图
    - 2.3 关键流程图
    - 2.4 接口设计图
    - 2.5 模块间依赖关系
- 04.一些技术要点说明
    - 4.1 使用队列管理Fragment栈
    - 4.2 存储的基础概念
    - 4.3 File文件列表
    - 4.4 分享文件给第三方
- 05.其他设计实践说明
    - 5.1 性能设计
    - 5.2 稳定性设计
    - 5.3 灰度设计
    - 5.4 降级设计
    - 5.5 异常设计


### 01.磁盘沙盒的概述
#### 1.1 项目背景说明


#### 1.2 沙盒作用


#### 1.3 设计目标


### 04.一些技术要点说明
#### 4.4 使用队列管理Fragment栈
- 该磁盘沙盒file工具页面的组成部分是这样的
    - FileExplorerActivity + FileExplorerFragment(多个，file列表页面) + TextDetailFragment(一个，file详情页面)
- 针对磁盘file文件列表`FileExplorerFragment`页面，点击file文件item
    - 如果是文件夹则是继续打开跳转到file文件列表`FileExplorerFragment`页面，否则跳转到文件详情页面
- 处理任务栈返回逻辑。举个例子现在列表`FileExplorerFragment`当作B，文件详情页面当作C，宿主Activity当作A。也就是说，点击返回键，依次关闭了fragment直到没有，回到宿主activity页面。再次点击返回键，则关闭activity！
    - 可能存在的任务栈是：打开A1->打开B1->打开C1
    - 那么点击返回键按钮，返回关闭的顺序则是：关闭C1->关闭B1->关闭A1
- Fragment回退栈处理方式
    - 第一种方案：创建一个栈(先进后出)，打开一个`FileExplorerFragment`列表页面(`push`一个`fragment`对象到队列中)，关闭一个列表页面(`remove`最上面那个`fragment`对象，然后调用`FragmentManager`中`popBackStack`操作关闭`fragment`)
    - 第二种方案：通过fragmentManager获取所有fragment对象，返回一个list，当点击返回的时候，调用popBackStack移除最上面一个
- 具体处理该场景中回退逻辑
    - 首先定义一个双端队列ArrayDeque，用来存储和移除元素。内部使用数组实现，可以当作栈来使用，功能非常强大。
    - 当开启一个fragment页面的时候，调用push(相当于addFirst在栈顶添加元素)来存储fragment对象。代码如下所示
        ``` java
        public void showContent(Class<? extends Fragment> target, Bundle bundle) {
            try {
                Fragment fragment = target.newInstance();
                if (bundle != null) {
                    fragment.setArguments(bundle);
                }
                FragmentManager fm = getSupportFragmentManager();
                FragmentTransaction fragmentTransaction = fm.beginTransaction();
                fragmentTransaction.add(android.R.id.content, fragment);
                //push等同于addFirst，添加到第一个
                mFragments.push(fragment);
                //add等同于addLast，添加到最后
                //mFragments.add(fragment);
                fragmentTransaction.addToBackStack("");
                //将fragment提交到任务栈中
                fragmentTransaction.commit();
            } catch (InstantiationException exception) {
                FileExplorerUtils.logError(TAG + exception.toString());
            } catch (IllegalAccessException exception) {
                FileExplorerUtils.logError(TAG + exception.toString());
            }
        }
        ```
    - 当关闭一个fragment页面的时候，调用removeFirst(相当于弹出栈顶的元素)移除fragment对象。代码如下所示
        ``` java
        @Override
        public void onBackPressed() {
            if (!mFragments.isEmpty()) {
                Fragment fragment = mFragments.getFirst();
                if (fragment!=null){
                    //移除最上面的一个
                    mFragments.removeFirst();
                }
                super.onBackPressed();
                //如果fragment栈为空，则直接关闭activity
                if (mFragments.isEmpty()) {
                    finish();
                }
            } else {
                super.onBackPressed();
            }
        }
      
        /**
         * 回退fragment任务栈操作
         * @param fragment                  fragment
         */
        public void doBack(Fragment fragment) {
            if (mFragments.contains(fragment)) {
                mFragments.remove(fragment);
                FragmentManager fm = getSupportFragmentManager();
                //回退fragment操作
                fm.popBackStack();
                if (mFragments.isEmpty()) {
                    //如果fragment栈为空，则直接关闭宿主activity
                    finish();
                }
            }
        }
        ```



#### 4.5 分享文件给第三方
- https://www.jianshu.com/p/d71afdf9c90a














