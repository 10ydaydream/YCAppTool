#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 思考问题
    - 1.3 常见方式
    - 1.4 设计目标
    - 1.5 收益分析
- 02.代码安全例子
    - 2.1 条件判断代码
    - 2.2 异常不要携带重要信息
    - 2.3 序列化安全问题
    - 2.4 三方库lib中类安全
    - 2.5 反射代码安全
    - 2.9 作弊器攻击问题
- 03.作弊器的监控
    - 3.1 监控介绍
    - 3.2 Xposed的Java层检测
    - 3.3 Xposed的Native层检测
- 04.作弊器的治理
    - 4.1 治理业务背景
    - 4.2 第一阶段
    - 4.3 第二阶段
- 05.Xposed必备知识
    - 5.1 Android系统启动流程
    - 5.2 APP启动流程
    - 5.3 Xposed框架概述
    - 5.4 如何Hook Android系统
- 06.方案基础设计
    - 6.1 整体架构图
    - 6.2 UML设计图
    - 6.3 关键流程图
    - 6.4 接口设计图
    - 6.5 模块间依赖关系
- 07.其他设计说明
    - 7.1 性能设计
    - 7.2 稳定性设计
    - 7.3 灰度设计
    - 7.4 降级设计
    - 7.5 异常设计



### 02.代码安全例子
#### 2.1 条件判断代码
- 首先，我们一起来看一段不起眼的条件判断代码，这里可能有什么问题吗？你可能会纳闷，这是再常见不过的一个条件判断了，能有什么安全隐患？
    ```
    // a, b, c 都是 int 类型的数值
    if (a + b < c) {
    // …
    }
    ```
    - 这里的隐患是数值类型需要防范溢出，否则这不仅仅可能会带来逻辑错误，在特定情况下可能导致严重的安全漏洞。
    - 从语言特性来说，Java 和 JVM 提供了很多基础性的改进，相比于传统的 C、C++等语言，对于数组越界等处理要完善的多，原生的避免了缓冲区溢出等攻击方式，提高了软件的安全性。但这并不代表完全杜绝了问题，Java 程序可能调用本地代码，也就是 JNI 技术，错误的数值可能导致 C/C++ 层面的数据越界等问题，这是很危险的。
- 所以，上面的条件判断，需要判断其数值范围，例如，写成类似下面结构。
    ```
    if (a < c – b)
    ```


#### 2.2 异常不要携带重要信息
- 再来看一个例子，请看下面的一段异常处理代码：
    ```
    try {
        // 业务代码
    } catch (Exception e) {
        throw new RuntimeException(hostname + port + “ doesn’t response”);
    }
    ```
- 这段代码将敏感信息包含在异常消息中，试想，如果是一个应用，异常也没有良好的包装起来，很有可能就把内部信息暴露给终端客户。
- 对于安全标准特别高的系统，甚至可能要求敏感信息被使用后，要立即明确在内存中销毁，以免被探测；或者避免在发生 core dump 时，意外暴露。



#### 2.3 序列化安全问题
- Java 提供了序列化等创新的特性，广泛使用在远程调用等方面，但也带来了复杂的安全问题。直到今天，序列化仍然是个安全问题频发的场景，通常建议：
    - 敏感信息不要被序列化！在编码中，建议使用 transient 关键字将其保护起来。
    - 反序列化中，建议在 readObject 中实现与对象构件过程相同的安全检查和数据检查。
- 另外，在 JDK 9 中，Java引入了过滤器机制，以保证反序列化过程中数据都要经过基本验证才可以使用。
    - 其原理是通过黑名单和白名单，限定安全或者不安全的类型，并且你可以进行定制，然后通过环境变量灵活进行配置，会更加具体的使用你可以参考 ObjectInputFilter。



#### 2.4 三方库lib中类安全
- 看到很多第三方库，比如gson，rxJava等库，几乎大多数类都是用finial修饰的。这个是为什么呢？
- 当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
- 很多类，不想被开发者继承，为了内部安全。同时也避免反射攻击，所以就用finial修饰。这也是一种保证类安全的有效做法。



#### 2.9 作弊器攻击问题



### 03.作弊器的监控
#### 3.1 监控介绍
- 关于作弊器的监控，目前主要由安全SDK实现，分别监控手机是否安装了作弊器（例如Xposed）和我们APP运行时是否受作弊器的影响，将这些数据上报到后台。
- 不同的作弊器，监控的方法是不同的，随着作弊器技术的提升，相关的监控维度也在不断的扩大。
- 这里以Xposed作弊器的监控方法为例子。Xposed的监控分为Java层和Native层。


#### 3.2 Xposed的Java层检测
- 判断是否安装Xposed Installer相关的软件包
    - 最简单的检测，我们调用Android提供的PackageManager的API来遍历系统中App的安装情况来辨别是否有安装Xposed Installer相关的软件包。
    - 通常情况下使用Xposed Installer框架都会屏蔽对其的检测，即Hook掉PackageManager的getInstalledApplications方法的返回值，以便过滤掉de.robv.android.xposed.installer来躲避这种检测。
    ``` java
    PackageManager packageManager = context.getPackageManager();
    List applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);
    for (ApplicationInfo applicationInfo: applicationInfoList) {
        if (applicationInfo.packageName.equals("de.robv.android.xposed.installer")) {
            // is Xposed TODO... }
        }
    ```
- 自造异常读取栈。
    - Xposed Installer框架对每个由Zygote孵化的App进程都会介入，因此在程序方法异常栈中就会出现Xposed相关的“身影”，我们可以通过自造异常Catch来读取异常堆栈的形式，用以检查其中是否存在Xposed的调用方法。
    ```
    /**
     * 通过主动抛出异常，检查堆栈信息来判断是否存在XP框架
     * @return
     */
    public static boolean isXposedExistByThrow() {
        try {
            throw new Exception("gg");
        } catch (Throwable e) {
            return isXposedExists(e);
        }
    }
    ```


#### 3.3 Xposed的Native层检测
- 为了有效提搞检测准确率，就须做到Java和Native层同时检测。
    - 每个App在系统中都有对应的加载库列表，这些加载库列表在/proc/下对应的pid/maps文件中描述，在Native层读取/proc/self/maps文件不失为检测Xposed Installer的有效办法之一。
    - 由于Xposed Installer通常只能Hook Java层，因此在Native层使用C来解析/proc/self/maps文件，搜检App自身加载的库中是否存在XposedBridge.jar、相关的Dex、Jar和So库等文件。
    ``` c
    bool is_xposed() 
    {
       bool rel = false;
       FILE *fp = NULL;
       char* filepath = "/proc/self/maps";
       string xp_name = "XposedBridge.jar";
       fp = fopen(filepath,"r")) 
       while (!feof(fp))                                 
       {
           fgets(strLine,BUFFER_SIZE,fp);                    
           origin_str = strLine;
           str = trim(origin_str);
           if (contain(str,xp_name))
           {
               rel = true; //检测到Xposed模块
               break;
           }
       }
    }
    ```


### 04.作弊器的治理
#### 4.1 治理业务背景
- 治理主要从作弊器对我们具体业务场景的影响做防御。


#### 4.2 第一阶段



#### 4.3 第二阶段
- 梳理项目中有哪些没有被混淆的类，探讨这些类是否可以被混淆。因为作弊器获取行程信息的入口就是从没有被混淆的Xxx类下手的。
- 与安全SDK的同事沟通，提升作弊器的检测的准确性，并与产品一起商讨如何处置目前的作弊用户。


### 05.Xposed必备知识
- Xposed技术的核心之一就是Hook Android系统启动流程和APP启动流程，为了方便各位能更好的理解后面要讲解的Xposed，接下来先讲解Android系统启动流程和APP启动流程。



#### 5.1 Android系统启动流程
- 将Android系统的启动分成八层（或者说八个大步骤）
    - 按下电源时引导芯片从代码从预定义的地方（固化在在Rom）开始执行，加载引导程序BootLoaer到RAM。
    - BootLoader程序把系统OS拉起来并运行。
    - Linux内核启动，这里面我们最关心的是init进程的启动，它是所有用户进程的鼻祖。
    - 初始化init进程，这里面最重要的是启动Zygote进程，它是所有APP 进程的鼻祖（或者说是Java进程）。
    - 初始化Zygote进程，创建运行APP所需要的服务，例如Java虚拟机、注册JNI方法以及启动SystemServer进程。
    - 初始化SystemServer进程，这里最重要的就是启动Binder线程池以及一些核心服务，比如PMS、WMS、AMS等。
    - AMS是管理Android 四大组件的核心服务，系统启动后会让AMS将系统桌面（也就是Launcher）加载出来。
    - Launcher作为所有APP 的入口，点击Launcher上的图标后就会启动APP（如果APP进程不在，会先Fork Zygote进程来创建新进程）。
- Hook系统要点
    - 上述流程中最关键的节点是启动Zygote，因为APP进程都是由Zygote进程孵化(fork)而来的，fork时不仅仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库，所以只要Hook了Zygote进程，就可以对手机里所有的APP实现全局注入攻击。


#### 5.2 APP启动流程
- APP启动流程可以分三个阶段：
    - Launcher请求AMS阶段。
    - AMS到ApplicationThread的调用过程。
    - ActivityThread启动Activity过程。
- Xposed Hook的是第三个阶段
    - ActivityThread启动Activity的过程。因为在ActivityThread启动Activity的过程中，可以获取到当前Activity的所有信息以及Activity所在的进程信息。比如：
    ``` java
    ClassLoader
    packageName
    processName
    applicationInfo
    ```
- 通过获取上述信息，就可以在目标进程中执行任意操作，比如显示一个弹窗或者修改、获取任意方法的返回值。上述信息被封装在AppBindData中。关于AppBindData的初始化，下面看下流程图：
    - 图31.3
- 从上述的流程图中可以得出，获取目标APP核心信息最佳点就是ActivityThread里的bindApplication方法，这也是Xposed Hook的点。


#### 5.3 Xposed框架概述
- Xposed原理简介
    - Xposed是一个针对Android平台的动态劫持项目，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持，Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码。框架核心思想在于将java层普通函数注册成本地JNI方法，以此来变相实现hook机制。
- Xposed工作原理图
    - 31.4


#### 5.4 如何Hook Android系统
- 主要分两步实现：
    - 选择Hook点，Hook系统方法
    - 替换系统文件
- Hook系统方法
    - init进程→init.rc→app_process(app_main.cpp) →启动Zygote进程→ZygoteInit的main() →startSystemServer() →fork出system_server子进程。
    ```
    app_main.cpp
    ......
    if (zygote) {
        // 这里调用AndroidRuntime类的Start方法，里面会做如下几件重要的事情：
        // 1、初始化JNI接口，2、创建Java虚拟机，3、注册JNI方法，4、调用ZygoteInit类初始化SystemServer进程
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
    } else if (className) {
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
    }
    ```
    - 概括起来编译生成自定义app_process→ 把原先调用ZygoteInit.main()处 改为调用XposedInit.main() → Hook资源和一些准备工作 → 调用系统原本启动Zygote的方法。
- 替换系统文件
    - 因为替换流程非常复杂，这里不做详细分析。给大家一个结论，替换流程如下：XposedInstaller下载补丁包 → 获取root权限 → 解压复制update-binary文件到特定目录 → 文件执行时会调用flash-script.sh脚本，将app_process、Xposedbridge.jar、so库等写到系统私有目录。






### 01.概述
#### 1.1 项目背景
- 通过简要的语言描述项目背景以及要达成的业务目标。

#### 1.2 设计目标
- 需求的背后往往会带来技术的重构/优化，或者单纯的完成需求，如果有必要，需要从技术角度给出方案设计的目标
- 比如对于图片下载需求，需要完成相关的功能，那么设计目标主要有完成异步下载、存储、缓存设计、图片解码、渲染等功能。
- 比如对于优化需求，目标可以是达到一个什么效果？可以是帧率的、Crash率的、卡顿的等。
- 比如对于重构需求，目标可以是加强扩展、解决问题、提升效率等。



### 02.方案设计
- 方案设计是技术文档的最核心部分，主要包括了整体架构和功能设计，这里需要体现：
- 设计的初衷：概要描述方案设计的思考，可以是为了扩展性的考虑，可以是提升性能
关键技术点的思考：描述关键技术选型的思考，比如要解耦，业内解耦方案能有router、Target-Action等，讲清楚选择的思考
- 技术上的折中/取舍：在做技术设计的时候，往往要的很多，但时间有限，那么这个需要讲一下折中与取舍，以及接下来的规划、计划



#### 2.1 整体架构
- 整体架构的组成需要有一张完成的架构设计图，描述清楚具体的分层以及层与层之间的关系
- 比如传统的开发会分为三层，展示层、逻辑层、数据层
    - 展示层的设计：视图的构成、视图间的耦合关系、具体的交互逻辑
    - 逻辑层的设计：支撑展示层所需要的数据、从数据层获取数据的加工、业务相关逻辑（比如轮询服务）
    - 数据层的设计：数据的获取方式以及存储方式，文件、数据库、本地、网络



#### 2.2 功能设计
- 功能设计包含但不限于以下几个部分：逻辑流程图、接口设计图、与外部的模块间依赖关系

#### 2.2.1 关键流程图
- 设计中的最复杂、最关键的逻辑需要画出流程图，实在画不出的流程图需要用语言描述清楚。
- 关键流程需要有逻辑流程图，帮助其他同学理解功能的关键节点逻辑


##### 2.2.2 接口设计图
- 通过UML类图来展示类间关系，描述清楚接口设计的一些思考原则
    - 提供的接口，往往接口设计为了完成相关逻辑



##### 2.2.3 模块间依赖关系
- 描述清楚和哪些模块存在依赖关系以及原因，比如首页依赖于购物车模块，需要解释清楚要强耦合，有没有办法解耦
    - App内部模块间依赖
    - App外部依赖


#### 2.3 UI/动效设计
- 客户端开发有很大一部分精力在UI/动效上，对于复杂的静态UI和复杂动效，需要给出实现方案和选型逻辑
- 静态UI
    - 只有复杂的UI才需要给出设计方案，例如核心页面大重构、复杂的协调布局等
- 复杂动效
    - 复杂的动效是端上容易踩坑的关键点，需要给出实现方案的对比、选型等，为验证动效可行性，可以给出动效Demo



### 03.其他设计（Optional）
- 以下部分是可选项，主要是从异常、兼容性、性能、稳定性、灰度、降级等维护来设计。


#### 3.1 性能设计
- 有些业务项目可能会考虑性能，比如列表页，卡顿、流畅度怎么样？如何评估？
- 有些技术项目可能也会考虑性能，比如数据库设计，检索性能如何？是否有瓶颈，如何评估？


#### 3.2 稳定性设计
- 大的项目需要考虑性能如何保障？
    - 比如方案 Review
    - 比如自测Case Review，加强自测
    - 比如单测


#### 3.3 灰度设计
- 核心关键功能需要有A/B设计
- 比如UIWebview替换为WKWebview，其中存在很多不确定因素，需要做好灰度设计


#### 3.4 降级设计
- 在做一些新技术尝试时，需要考虑降级设计
    - 比如RN、swift、weex引入对原有业务造成影响的，需要有兜底，可降级
    - 参考资料
    - 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


#### 3.5 异常设计
- 大部分业务需求都会涉及到异常处理，在关心主流程的同时需要关注异常场景怎么保证正确性？
    - 比如用户操作中途退出、网络异常、数据被清理等


#### 3.6 兼容性设计
- 业务逻辑一般不会涉及到兼容性，但UI/动效需求容易遇到兼容性问题，也是提测时需要让QA关注的
    - 比如独立端/嵌入端、高低版本API适配等


### 04.排期与计划
- 排期计划主要针对周期较长项目的时间补充，对于小型项目不需要，例如：
    - 正常的版本业务需求，5pd以下，不需要给出排期计划；5pd或者以上，可以简单描述一下排期和提测时间
    - 跨版本的大型业务需求、重构专项等，需要给出详细的排期计划
    - 研发自驱的技术优化项目，需要给出详细的排期计划


### 05.参考资料
- 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


### 参考
- Android 黑科技保活实现原理揭秘
    - https://weishu.me/2020/01/16/a-keep-alive-method-on-android/



