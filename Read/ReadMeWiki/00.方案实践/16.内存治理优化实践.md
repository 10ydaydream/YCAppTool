#### 目录介绍
- 01.卡顿基础介绍
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念
    - 1.4 设计目标
    - 1.5 收益分析
- 02.内存分析
    - 2.1 内存分析工具
    - 2.2 内存分析指标
    - 2.3 内存优化思路
- 03.内存泄漏治理
    - 3.1 什么是内存泄漏
    - 3.3 常见内存泄漏案例
- 04.其他优化治理
    - 4.7 ComponentCallback优化
    - 4.8 四种引用优化
- 方案设计
    - 整体架构
        - 架构设计图
        - UML设计图
    - 功能设计
        - 关键流程图
        - 接口设计图
        - 模块间依赖关系
- 其他设计（Optional）
    - 性能设计
    - 稳定性设计
    - 灰度设计
    - 降级设计
    - 异常设计
- 排期与计划
    - 排期节点
    - 落实反馈


### 01.卡顿基础介绍
#### 1.1 项目背景
- 内存治理背景
    - 在所有的App中，内存泄露问题一直存在，泄露或多或少而已，对于使用时间比较小的应用来说，即便存在内存泄露也没那么危险，因为出现OOM的概率较低，但是内存泄露问题对于长时间运行的App来说是致命的，如何解决内存泄露就是是我们工作的重点方向。


#### 1.2 遇到问题



#### 1.3 基础概念
- 泄露的原因有非常多，如果用一句话概括就是引用了不再需要的内存信息，如果详细划分可以归为一下几种类别
    - 内部类和匿名内部类导致的内存泄露，这种是最常见的，也是最容易忽略的问题，尤其在这种GUI编程中，存在大量的callback回调
    - 多线程导致的内存泄露，本质上是线程的生命周期太长了，页面销毁的时候线程有可能还在运行
    - 单例问题，本质上也是生命周期太长导致的
- 对于内存泄露，现在有很多的工具能帮助我们定位和分析问题，你们为什么线上还是有内存泄露问题呢？
    - 线上的真实使用环境比较复杂，有很多的场景不一定在线下完全覆盖到
    - 虽然线下也有自动化工具上报问题，但是很多人都忽略了内存泄露问题，不重视和不及时是掩埋线下问题的根本原因


#### 1.4 设计目标
- 对于以上问题，我们给出我们自己的解法吧，方案设计核心思路如下
    - 建立线下内存自动化分析工具，解决过多的人力投入
    - 建立问题解决闭环机制，打通问题的发现、上报、处理、解决问题等多个链路，闭环解决问题
    - 建立内存泄露度量体现，数据和结果度量内存质量问题


#### 1.5 收益分析

### 02.内存分析
#### 2.1 内存分析工具
- Android最常见的是：Leakcanary
    - leakCanary是Square开源框架，是一个Android和Java的内存泄露检测库，如果检测到某个 activity 有内存泄露，LeakCanary 就是自动地显示一个通知，所以可以把它理解为傻瓜式的内存泄露检测工具。通过它可以大幅度减少开发中遇到的oom问题，大大提高APP的质量。
- java相关工具是：Memory Analyzer
    - 是一款开源的JAVA内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于Eclipse RCP(Rich Client Platform)，可以下载RCP的独立版本或者Eclipse的插件。
    - http://www.eclipse.org/mat/


#### 2.2 内存分析指标



#### 2.3 内存优化思路


### 03.内存泄漏治理
#### 3.1 什么是内存泄漏
- 对象没有跟着生命周期被回收
    - 一些对象有着有限的声明周期，当这些对象所要做的事情完成了，我们希望它们会被垃圾回收器回收掉。
    - 但是如果有一系列对这个对象的引用存在，那么在我们期待这个对象生命周期结束时被垃圾回收器回收的时候，它是不会被回收的。它还会占用内存，这就造成了内存泄露。持续累加，内存很快被耗尽。
- 举一个内存泄漏案例
    - 比如：当Activity的onDestroy()方法被调用后，Activity以及它涉及到的View和相关的Bitmap都应该被回收掉。
    - 但是，如果有一个后台线程持有这个Activity的引用，那么该Activity所占用的内存就不能被回收，这最终将会导致内存耗尽引发OOM而让应用crash掉。
- 它是造成应用程序OOM的主要原因之一。
    - 由于android系统为每个应用程序分配的内存有限，当一个应用中产生的内存泄漏比较多时，就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就可能造成App会OOM。



#### 3.3 常见内存泄漏案例
##### 3.3.1 错误使用单例造成的内存泄漏
- 造成内存泄漏原因分析
    - 在平时开发中单例设计模式是我们经常使用的一种设计模式，而在开发中单例经常需要持有Context对象，如果持有的Context对象生命周期与单例生命周期更短时，或导致Context无法被释放回收，则有可能造成内存泄漏。
- 解决办法：
    - 要保证Context和Application的生命周期一样，修改后代码如下：this.mContext = context.getApplicationContext();
    - 如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。


##### 3.3.2 Handler使用不当造成内存泄漏
- 造成内存泄漏原因分析
    - 通过内部类的方式创建mHandler对象，此时mHandler会隐式地持有一个外部类对象引用这里就是Activity，当执行postDelayed方法时，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，MessageQueue是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。
- 解决Handler内存泄露主要2点
    - 注意要在Activity销毁的时候移除Messages。或者推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。


##### 3.3.3 Thread未关闭造成内存泄漏
- 线程内存泄漏场景
    - 当在开启一个子线程用于执行一个耗时操作后，此时如果改变配置（例如横竖屏切换）导致了Activity重新创建，一般来说旧Activity就将交给GC进行回收。
    - 但如果创建的线程被声明为非静态内部类或者匿名类，那么线程会保持有旧Activity的隐式引用。当线程的run()方法还没有执行结束时，线程是不会被销毁的，因此导致所引用的旧的Activity也不会被销毁，并且与该Activity相关的所有资源文件也不会被回收，因此造成严重的内存泄露。
- 因此总结来看， 线程产生内存泄露的主要原因有两点：
    - 1.线程生命周期的不可控。Activity中的Thread和AsyncTask并不会因为Activity销毁而销毁，Thread会一直等到run()执行结束才会停止，AsyncTask的doInBackground()方法同理
    - 2.非静态的内部类和匿名类会隐式地持有一个外部类的引用
- 解决线程内存泄漏方案
    - 想要避免因为 Thread 造成内存泄漏，可以在 Activity 退出后主动停止 Thread
- 如果想保持Thread继续运行，可以按以下步骤来：
    - 1.将线程改为静态内部类，切断Activity对于Thread的强引用
    - 2.在线程内部采用弱引用保存Context引用，切断Thread对于Activity的强引用



##### 3.3.4 错误使用静态变量导致引用后无法销毁
- 在平时开发中，有时候我们创建了一个工具类。
    - 比如分享工具类，十分方便多处调用，因此使用静态方法是十分方便的。但是创建的对象，建议不要全局化，全局化的变量必须加上static。这样会引起内存泄漏！
- 使用场景。在Activity中引用后，关闭该Activity会导致内存泄漏
    ```
    DoShareUtil.showFullScreenShareView(PNewsContentActivity.this, title, title, shareurl, logo);
    ```
- 解决办法
    - 静态方法中，创建对象或变量，不要全局化，全局化后的变量或者对象会导致内存泄漏。    


##### 3.3.5 非静态内部类创建静态实例造成内存泄漏
- 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法
- 问题代码
    ```
    private static TestResource mResource = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //省略
        if(mResource == null){
            mResource = new TestResource();
        }
    }
    class TestResource {
         //里面代码引用上下文，Activity.this会导致内存泄漏
    }
    ```
- 解决办法
    - 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。
- 分析问题
    - 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。



##### 3.3.6 不需要用的监听未移除会发生内存泄露
- 问题代码
    ```
    //add监听，放到集合里面
    tv.getViewTreeObserver().addOnWindowFocusChangeListener(this);
    ```
- 解决办法。关于注册监听这种，最后注册+销毁是成对的出现。
    ```
    //计算完后，一定要移除这个监听
    tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this);
    ```


##### 3.3.7 资源未关闭造成的内存泄漏
- 有哪些资源容易造成泄漏
    - BroadcastReceiver，ContentObserver，FileObserver，Cursor，Callback，Anim动画等在 Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则这个 Activity 类会被 system 强引用，不会被内存回收。
- 注意事项和建议
    - 值得注意的是，关闭的语句必须在finally中进行关闭，否则有可能因为异常未关闭资源，致使activity泄漏。
- 举一个具体的案例
    - 比如我们在Activity中注册广播，如果在Activity销毁后不取消注册，那么这个广播会一直存在系统中，同上面所说的非静态内部类一样持有Activity引用，导致内存泄露。因此注册广播后在Activity销毁后一定要取消注册。



##### 3.3.8 静态集合使用不当导致的内存泄漏
- 具体的问题说明
    - 有时候我们需要把一些对象加入到集合容器（例如ArrayList）中，当不再需要当中某些对象时，如果不把该对象的引用从集合中清理掉，也会使得GC无法回收该对象。如果集合是static类型的话，那内存泄漏情况就会更为严重。
- 解决办法思考
    - 因此，当不再需要某对象时，需要主动将之从集合中移除。




### 04.其他优化治理
#### 4.7 ComponentCallback优化
- 关于ComponentCallback2，是一个细粒度的内存回收管理回调。
    - 开发者应该实现onTrimMemory(int)方法，细粒度release 内存，参数可以体现不同程度的内存可用情况
    - 响应onTrimMemory回调：开发者的app会直接受益，有利于用户体验，系统更有可能让app存活的更持久。
    - 不响应onTrimMemory回调：系统更有可能kill 进程
- 具体看glide源码如何做到释放内存



#### 4.8 四种引用优化
- 引用类型有哪些种
    - 强引用：默认的引用方式，不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
    - 软引用（SoftReference）：如果一个对象只被软引用指向，只有内存空间不足够时，垃圾回收器才会回收它；
    - 弱引用（WeakReference）：如果一个对象只被弱引用指向，当JVM进行垃圾回收时，无论内存是否充足，都会回收该对象。
    - 虚引用（PhantomReference）：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用通常和ReferenceQueue配合使用。
- 一般使用场景
    - 强引用，直接new出来的对象，通过引用对堆里面的对象进行操作，可能会导致内存泄漏，一般内存优化主要是针对强引用优化。可以显示地将引用赋值为null，JVM在合适的时间就会回收该对象。
    - 


### 01.概述
#### 1.1 项目背景
- 通过简要的语言描述项目背景以及要达成的业务目标。

#### 1.2 设计目标
- 需求的背后往往会带来技术的重构/优化，或者单纯的完成需求，如果有必要，需要从技术角度给出方案设计的目标
- 比如对于图片下载需求，需要完成相关的功能，那么设计目标主要有完成异步下载、存储、缓存设计、图片解码、渲染等功能。
- 比如对于优化需求，目标可以是达到一个什么效果？可以是帧率的、Crash率的、卡顿的等。
- 比如对于重构需求，目标可以是加强扩展、解决问题、提升效率等。



### 02.方案设计
- 方案设计是技术文档的最核心部分，主要包括了整体架构和功能设计，这里需要体现：
- 设计的初衷：概要描述方案设计的思考，可以是为了扩展性的考虑，可以是提升性能
关键技术点的思考：描述关键技术选型的思考，比如要解耦，业内解耦方案能有router、Target-Action等，讲清楚选择的思考
- 技术上的折中/取舍：在做技术设计的时候，往往要的很多，但时间有限，那么这个需要讲一下折中与取舍，以及接下来的规划、计划



#### 2.1 整体架构
- 整体架构的组成需要有一张完成的架构设计图，描述清楚具体的分层以及层与层之间的关系
- 比如传统的开发会分为三层，展示层、逻辑层、数据层
    - 展示层的设计：视图的构成、视图间的耦合关系、具体的交互逻辑
    - 逻辑层的设计：支撑展示层所需要的数据、从数据层获取数据的加工、业务相关逻辑（比如轮询服务）
    - 数据层的设计：数据的获取方式以及存储方式，文件、数据库、本地、网络



#### 2.2 功能设计
- 功能设计包含但不限于以下几个部分：逻辑流程图、接口设计图、与外部的模块间依赖关系

#### 2.2.1 关键流程图
- 设计中的最复杂、最关键的逻辑需要画出流程图，实在画不出的流程图需要用语言描述清楚。
- 关键流程需要有逻辑流程图，帮助其他同学理解功能的关键节点逻辑


##### 2.2.2 接口设计图
- 通过UML类图来展示类间关系，描述清楚接口设计的一些思考原则
    - 提供的接口，往往接口设计为了完成相关逻辑



##### 2.2.3 模块间依赖关系
- 描述清楚和哪些模块存在依赖关系以及原因，比如首页依赖于购物车模块，需要解释清楚要强耦合，有没有办法解耦
    - App内部模块间依赖
    - App外部依赖


#### 2.3 UI/动效设计
- 客户端开发有很大一部分精力在UI/动效上，对于复杂的静态UI和复杂动效，需要给出实现方案和选型逻辑
- 静态UI
    - 只有复杂的UI才需要给出设计方案，例如核心页面大重构、复杂的协调布局等
- 复杂动效
    - 复杂的动效是端上容易踩坑的关键点，需要给出实现方案的对比、选型等，为验证动效可行性，可以给出动效Demo



### 03.其他设计（Optional）
- 以下部分是可选项，主要是从异常、兼容性、性能、稳定性、灰度、降级等维护来设计。


#### 3.1 性能设计
- 有些业务项目可能会考虑性能，比如列表页，卡顿、流畅度怎么样？如何评估？
- 有些技术项目可能也会考虑性能，比如数据库设计，检索性能如何？是否有瓶颈，如何评估？


#### 3.2 稳定性设计
- 大的项目需要考虑性能如何保障？
    - 比如方案 Review
    - 比如自测Case Review，加强自测
    - 比如单测


#### 3.3 灰度设计
- 核心关键功能需要有A/B设计
- 比如UIWebview替换为WKWebview，其中存在很多不确定因素，需要做好灰度设计


#### 3.4 降级设计
- 在做一些新技术尝试时，需要考虑降级设计
    - 比如RN、swift、weex引入对原有业务造成影响的，需要有兜底，可降级
    - 参考资料
    - 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


#### 3.5 异常设计
- 大部分业务需求都会涉及到异常处理，在关心主流程的同时需要关注异常场景怎么保证正确性？
    - 比如用户操作中途退出、网络异常、数据被清理等


#### 3.6 兼容性设计
- 业务逻辑一般不会涉及到兼容性，但UI/动效需求容易遇到兼容性问题，也是提测时需要让QA关注的
    - 比如独立端/嵌入端、高低版本API适配等


### 04.排期与计划
- 排期计划主要针对周期较长项目的时间补充，对于小型项目不需要，例如：
    - 正常的版本业务需求，5pd以下，不需要给出排期计划；5pd或者以上，可以简单描述一下排期和提测时间
    - 跨版本的大型业务需求、重构专项等，需要给出详细的排期计划
    - 研发自驱的技术优化项目，需要给出详细的排期计划


### 05.参考资料
- 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。






