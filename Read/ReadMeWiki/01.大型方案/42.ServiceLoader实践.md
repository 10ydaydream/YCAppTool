#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.SPI机制说明
    - 2.1 SPI是什么
    - 2.2 作用是什么
    - 2.3 SPI机制原理
- 03.SPI简单案例实现
- 04.SPI封装思路
    - 4.6 如何使用
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计


### 01.整体概述
#### 1.1 项目背景


#### 1.2 遇到问题
- 1.项目业务组件依赖sdk组件，如何使用组件中功能且减少代码耦合性？

#### 1.3 基础概念介绍


#### 1.4 设计目标


#### 1.5 产生收益分析


### 02.SPI机制说明
#### 2.1 SPI是什么
- SPI ，全称为 Service Provider Interface，是一种服务发现机制。
    - 它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类，一般用来启用框架扩展和替换组件。

#### 2.2 作用是什么
- 解耦合：
    - 把接口的具体实现类的全名写成配置文件，然后进行读取，生成具体的实现类对象，进行服务的调用，从而实现解耦。


#### 2.3 SPI机制原理
- SPI机制原理
    - 1.使用@ServiceProvider来标注该类提供哪些服务接口，标识服务的优先级与别名(加载时可通过别名指定加载某个服务)
    - 2.在构建过程中，java代码编译完成之后，执行自定义的gradle任务，扫描所有class，生成SPI配置文件，存放接口、接口实现类(服务)与实现类优先级信息
    - 3.解析SPI配置文件，通过Javapoet生成ServiceRegistry.java，将配置文件中接口与实现类的映射关系转译成代码，生成静态代码块可在类加载时自动完成 服务的注册
    - 4.把ServiceRegistry.java编译成class文件，被ClassLoader加载后可在ServiceLoader中正常引用完成服务的创建



### 04.SPI封装思路
#### 4.6 如何使用
- 举一个案例
    - 比如想实现一个推送的功能，不管是在那个组件中能快速使用，减少耦合性。核心还是用到接口+实现类+反射创建对象的形式。
    - 注解类：ServiceProvider，ServiceProviderInterface。注意注解标注是运行时……
    - 定义推送的接口：PushServiceProvider，使用注解ServiceProviderInterface标记
    - 定义推送接口实现类：PushServiceImpl，接口具体实现类，使用注解ServiceProvider标记
    - apt生成类：PushService接口委托类，ServiceRegistry





遇到的问题
1.ServiceRegistry是如何解析生成该编译文件的，这块还要在熟悉下apt，找到项目中具体的实现代码分析下。
2.比如在PushService代码中，成员位置调用ServiceLoader.laod创建接口实现类对象，如果不是单利创建对象，那么会不会多次调用load创建多次对象？是否可以改成在静态final形式或者在静态代码块中调用？
SPI原理图

问题解答说明
1.如何扫描所有class？
写一个plugin插件，开启一个task任务，然后去加载代码文件目录或者jar，遍历取后缀名为.class的字节码并存储到list集合中。
2.委派代理的作用？
接口+接口实现类+接口委派类，调用的时候使用委派类，而具体的实现逻辑细节在实现类中。主要是起到代码隔离和解耦合的操作。
3.如何生成apt代码？

4.ServiceLoader.laod多次会怎样？
会创建多个对象。所以这个一般都是保持单利的形式
5.如何实现priority优先级？
首先获取ServiceProvider注解，然后通过注解拿到里面的参数。然后遍历所有被注解标记的类，最后把优先级写到file文件中。


