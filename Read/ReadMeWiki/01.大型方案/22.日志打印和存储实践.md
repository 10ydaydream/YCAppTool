#### 目录介绍
- 01.整体概述
    - 1.1 项目背景说明
    - 1.2 遇到问题
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.日志存储设计思路
    - 2.1 使用跨进程通信
    - 2.2 选择Service通信
    - 2.3 日志文件路径设置
    - 2.4 组装log日志设计
    - 2.5 日志文件创建机制
    - 2.6 日志缓存的策略
    - 2.9 多进程存储问题
- 03.关键技术点说明
    - 3.1 aidl通信步骤
    - 3.2 跨进程启动服务
    - 3.3 跨进程传输日志
    - 3.4 日志写入操作
    - 3.5 日志如何追加写入
    - 3.6 日志切分存储
    - 3.7 日志自动清除操作
    - 3.9 遇到的一些问题
- 04.使用高效日志库
    - 4.1 高效日志方案
    - 4.2 mmap理解介绍
    - 4.3 移动端使用mmap
    - 4.4 XLog介绍
    - 4.5 Logan介绍
    - 4.6 MMKV介绍
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计
- 07.其他说明介绍
    - 7.1 参考链接


### 01.整体概述
#### 1.1 项目背景说明


#### 1.2 遇到问题


#### 1.3 基础概念介绍


#### 1.4 设计目标


#### 1.5 产生收益分析


### 02.日志存储设计思路
#### 2.1 使用跨进程写日志
- 使用Intent
    - Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。
- 使用文件共享
    - 可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（**注意**：并不是同一个对象，只是内容相同。）
- 使用Messenger
    - Messenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。
- 使用AIDL
    - 服务端，创建Service用于监听客户端的连接请求，然后创建一个AIDL接口文件，里面是将要实现的方法，注意这个方法是暴露给客户端的的，**在Service中实现这个AIDL接口即可**。
    - 客户端，先绑定服务端Service，绑定成功后，将服务端返回的Binder对象转换成AIDL接口所属的类型，最后调用AIDL的方法就可以了。
- 使用ContentProvider
    - 许多如通讯录、公共相册、日程表，需要跨进程访问。使用方法：继承 ContentProvider 类实现抽象方法，除 onCreate 运行在主线程里，其他五个方法均由外界回调运行在 Binder 线程池中。ContentProvider 的底层数据，可以是 SQLite 数据库，可以是文件，也可以是内存中的数据。


#### 2.2 选择Service通信
- 使用Service服务场景：后台运行和跨进程访问
    - 后台运行，Service可以在后台执行长时间运行操作而不提供用户界面；跨进程访问，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。
- 开启远程服务(Remote Service)
    - 该服务是独立的进程，对应进程名格式为所在包名加指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。
- 使用Service服务技术选择
    - 如果只是想开个服务在后台运行的话，直接startService即可；如果需要相互之间进行传值或者操作的话，就应该通过bindService。
    - 需要注意的点有哪些：Service是在主线程里执行操作的，可能会因为执行耗时操作而导致ANR。如果是跨进程传输，则需要注意读写耗时。


#### 2.3 日志文件路径设置
- 首先给客户端设置路径，然后在通过aidl跨进程传递给服务端。
    - 这里面需要注意，在bind绑定service后，在onServiceConnected连接上之后，调用IxxService.Stub.asInterface(IBinder obj) 即可得到一个IxxService实例，即客户端这边通过实例调用接口(aidl)中方法传递路径



#### 2.4 组装log日志设计



#### 2.5 日志文件创建机制



#### 2.6 日志缓存的策略


#### 2.9 多进程存储问题


### 03.关键技术点说明
#### 3.1 aidl通信步骤
- 服务端
    - 步骤1：新建定义AIDL文件【特别注意包名保持一致】，并声明该服务需要向客户端提供的接口。补充，如果aidl中有对象，则需要创建对象，并且实现Parcelable
    - 步骤2：在Service子类中实现AIDL中定义的接口方法，并定义生命周期的方法
    - 步骤3：在AndroidManifest.xml中注册服务 & 声明为远程服务
- 客户端
    - 步骤1：拷贝服务端的AIDL文件到目录下【需要把service端所有的aidl都拷贝到client来】
    - 步骤2：使用Stub.asInterface接口获取服务器的Binder，根据需要调用服务提供的接口方法
    - 步骤3：通过Intent指定服务端的服务名称和所在包，绑定远程Service
- 遇到一些问题
    - aidl接口是如何定义？
    - 定义后aidl接口如何编译生成.java文件？
    - aidl通信是单向还是双向？单向通信，客户端调
    - 其他注意点：注意的是需要先启动service端的apk，在启动client端的apk
- 不同的场景
    - 场景一、service 和 client 在同一个 project 中。service项目可以直接依赖client项目
    - 场景二、service 和 client 分属于不同的 project 中。将service项目中的 aidl 文件夹原封不动的拷贝到client项目中的对应位置




#### 3.2 跨进程启动服务


#### 3.3 跨进程传输日志


#### 3.4 日志写入操作


#### 3.5 日志如何追加写入


#### 3.6 日志切分存储


#### 3.7 日志自动清除操作


#### 3.9 遇到的一些问题
- 跨进程启动Service无效
    - 在manifest注册的时候加了process属性，然后就无法启动了，去掉就可以正常启动的？
- 客户端在
    - 客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。



### 04.使用高效日志库
#### 4.1 高效日志方案
- 移动日志系统使用了Linux系统中提供的mmap作为日志文件的载体，目前业内流行的XLOG日志组件、MMKV、美团Logan均采用了此方案，其最大的优势就是高效I/O、低损耗、跨进程 等优势。
  

#### 4.2 mmap理解介绍
- 操作系统分为内核态和用户态两种运行模式：
    - 内核态(Kernel MODE)能够运行操作系统程序 
    - 用户态(User MODE)能够运行用户程序。用户态(即应用程序)是不能直接对物理设备进行操作的(Ps:对物理设备进行操作，即对设备的物理地址写数据)。
- 为什么有内存映射这个概念
    - 如果想读取硬盘上的某一段数据通常都需要经过 硬盘->内核->用户，即数据需要经历两次拷贝，效率十分低下。
    - 内核映射即mmap,mmap将设备的物理地址映射到进程的虚拟地址，则用户操作虚拟内存时就相当于对物理设备进行操作了，减少了内核到用户的一次数据拷贝，从而提高数据的吞吐率。
    - 当使用mmap映射文件到进程后，就可以直接操作这段虚拟地址进行文件的读写等操作，不必再调用read，write等系统调用。
- mmap区别于以往的文件读写，具备以下几个优点：
    - 减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率；实现了用户空间和内核空间的高效交互方式。
    - 提供进程间共享内存及相互通信的方式；可用于实现高效的大规模数据传输。


#### 4.3 移动端使用mmap
- 对于移动端日志采集SDK来说
    - 主要进行的工作就是将用户写入的数据保存到文件中，在这个过程中涉及到在native层调用mmap函数实现在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系。


#### 4.4 XLog介绍


#### 4.5 Logan介绍
- 大概的原理介绍
    - Logan通过Native方式来实现日志底层的核心逻辑，也就是C编写底层库。收集日志时，在C层实现流式的压缩和加密数据，可以减少CPU峰值，使程序运行更加顺滑。而且先压缩再加密的方式压缩率比较高，整体效率较高。加密方式为AES。
    - Logan对日志协议数据进行格式化处理，针对大日志的分片处理，引入了MMAP机制解决了日志丢失问题，使用AES进行日志加密确保日志安全性。  
- 使用mmap技术优化
    - mmap: 是一种内存映射文件的方法，它将一个文件映射到进程的地址空间中，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系
    - 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上
      




#### 4.6 MMKV介绍


### 05.方案基础设计
#### 5.1 整体架构图


#### 5.2 UML设计图


#### 5.3 关键流程图


#### 5.4 接口设计图


#### 5.5 模块间依赖关系


### 06.其他设计说明
#### 6.1 性能设计


#### 6.2 稳定性设计


#### 6.3 灰度设计


#### 6.4 降级设计


#### 6.5 异常设计




### 07.其他说明介绍
#### 7.1 参考链接
- 京东零售云mPaaS移动端日志回捞探索实践
    - https://www.51cto.com/article/682747.html
- 美团开源移动端基础日志库
    - https://tech.meituan.com/2018/10/11/logan-open-source.html
- Android跨进程启动Service流程及常见问题
    - https://blog.csdn.net/One_Month/article/details/80255893
- Android进阶——AIDL详解
    https://blog.csdn.net/ly0724ok/article/details/117450121/
- Android中AIDL使用案例
    - https://www.jianshu.com/p/b174f14a2d2f









