### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念介绍
    - 1.4 设计目标
    - 1.5 产生收益分析
- 02.线程池基础知识
    - 2.1 为何有线程池
    - 2.2 如何管理线程
    - 2.3 线程池创建
    - 2.4 线程池生命周期
- 03.线程分析
    - 3.1 线程为何有优先级
    - 3.2 线程池如何管理线程
    - 3.3 线程之间如何切换
    - 3.4 线程任务耗时统计
    - 3.5 线程数据共享
    - 3.6 多线程并发优化
- 04.线程池封装思路
    - 4.1 封装总体思路
    - 4.2 主和子线程通信
    - 4.3 使用静态代理模式
    - 4.4 
    - 4.6 设置自定义Task
    - 4.7 线程池使用分析
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计
- 07.其他说明介绍
    - 7.1 参考链接



### 01.整体概述
#### 1.1 项目背景


#### 1.2 遇到问题
- **一般开启线程的操作如下所示**
    ``` 
    new Thread(new Runnable() {
        @Override
        public void run() {
            //做一些任务
        }
    }).start();
    ``` 
    - 创建了一个线程并执行，它在任务结束后GC会自动回收该线程。在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕。[博客](https://github.com/yangchong211/YCBlogs)
- **主要的弊端有这些，可能总结并不全面**
    - 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM
    - 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿
    - 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失



#### 1.3 基础概念介绍
- 线程池好处：
    - 1）降低资源消耗；
    - 2）提高相应速度；
    - 3）提高线程的可管理性
- 线程池的实现原理：
    - 当提交一个新任务到线程池时，判断核心线程池里的线程是否都在执行。如果不是，则创建一个新的线程执行任务。如果核心线程池的线程都在执行任务，则进入下个流程。
    - 判断工作队列是否已满。如果未满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
    - 判断线程池是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果满了，则交给饱和策略来处理这个任务。


#### 1.4 设计目标


#### 1.5 产生收益分析


### 02.线程池基础知识
#### 2.1 为何有线程池
- 使用线程池管理线程优点
    - ①降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；
    - ②提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；
    - ③方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；
    - ④更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。


#### 2.2 如何管理线程
- 大概的流程图如下
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-113cbc79670d1aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 文字描述如下
    - ①如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。
    - ②如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。
    - ③由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。
    - ④如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。[博客](https://github.com/yangchong211/YCBlogs)


#### 2.3 线程池创建
- 通过Executors的工厂方法获取这五种线程池，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，具体可以看看源码，这里省略呢……
    ``` 
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
    ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
    ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();
    ``` 



#### 2.4 线程池生命周期


### 03.线程分析
#### 3.1 线程为何有优先级


#### 3.2 线程池如何管理线程


#### 3.3 线程之间如何切换


#### 3.4 线程任务耗时统计


#### 3.5 线程数据共享


#### 3.6 多线程并发优化



### 04.线程池封装思路
#### 4.1 封装总体思路
#### 4.2 主和子线程通信
#### 4.3 使用静态代理模式
- 静态代理理解和应用：AbsTaskExecutor(抽象类) + DefaultTaskExecutor(委托类) + DelegateTaskExecutor(代理类)


#### 4.4 


#### 4.6 设置自定义Task
- AbsTaskExecutor使用代理模式实现了一个内部的线程池 DefaultTaskExecutor 提供使用，同时支持切换主线程的功能。其中如果使用者没有设置自己的 TaskExecutor ，那么 AbsTaskExecutor 将会使用 DefaultTaskExecutor 作为默认实现的线程池。
- 后面如果需要用到线程池的地方，就不用再自己写一堆实现方法了，直接调用 AbsTaskExecutor 就行了，如果不满足要求，就自己再定义一个 TaskExecutor 。


#### 4.7 线程池使用分析








