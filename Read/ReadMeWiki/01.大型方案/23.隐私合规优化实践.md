#### 目录介绍
- 01.整体概述
    - 1.1 遇到问题
    - 1.2 项目背景
    - 1.3 设计目标
    - 1.4 产生收益分析
- 02.隐私合规测什么
    - 2.1 隐私合规是什么
    - 2.2 为何做隐私合规
    - 2.3 隐私合规政策案例
- 04.隐私合规检测
    - 4.1 隐私合规检查什么
    - 4.5 隐私数据注意项
- 05.隐私合规检测库实践
    - 5.1 整体合规思路
    - 5.2 方案的选择和比较
    - 5.3 处理getDeviceId
    - 5.7 打印堆栈信息
- 06.方案基础设计
    - 6.1 整体架构图
    - 6.2 UML设计图
    - 6.3 关键流程图
    - 6.4 接口设计图
    - 6.5 模块间依赖关系
- 07.其他设计说明
    - 7.1 性能设计
    - 7.2 稳定性设计
    - 7.3 灰度设计
    - 7.4 降级设计
    - 7.5 异常设计
- 08.其他说明介绍
    - 8.1 参考链接



### 01.整体概述
#### 1.1 遇到问题
- 国内对应用程序安全隐私问题监管变的越来越严格。各个应用市场对APP上架也有比较严格的检查。出现隐私合规安全问题主要有哪些呢？
    - 在用户同意隐私协议之前，不能有收集用户隐私数据的行为。例如，在用户同意之前不能去获取 Android ID、Device ID、MAC 等隐私数据
    - 在用户同意隐私协议之后，搜集用户隐私数据的行为不能超出实现服务场景所必需的最低频率。例如，某些应用会在每次网络请求时将当前设备的 Android ID 作为 header 一起上报，如果没有对 Android ID 进行缓存处理的话，搜集该数据的行为频率就会非常高，此时一样存在隐私合规问题。


#### 1.2 项目背景
- 最关键的问题是用户同意隐私协议之前，不能有收集用户隐私信息的行为，例如获取deviceId、androidId等信息，除此之外，对于频繁申请权限、超范围申请权限也是需要注意的。
- 除了开迭代针对性整改，从技术角度思考，有没有一劳永逸的办法，杜绝隐私调用不合规问题呢？


#### 1.3 设计目标
- 针对提前收集用户隐私数据。
    - 需要统计出整个项目中所有涉及到隐私行为的相关代码，根据业务流程来判断该隐私行为是否合理、以及是否会在用户同意隐私协议之前被触发。这就需要对整个项目进行静态扫描。
- 针对收集隐私数据哪里调用。
    - 需要在应用运行时动态记录每次触发隐私行为的时间点和调用链信息，根据触发时间来判断该隐私行为是否过量执行，根据调用链信息来辅助判断具体是哪一块业务在获取隐私数据。这就需要对应用进行动态记录。


#### 1.4 产生收益分析
- 编码排查耗时大
    - 如果单纯靠开发人员来肉眼识别代码和编码统计的话，工作量非常大而且也很不现实，因为一个大型项目往往都会引入多个依赖库和第三方 SDK，可以规范自有代码，但没法修改和有效约束外部依赖，也很难理清楚依赖库的内部逻辑和调用链关系。
- 提高合规隐私检测效率
    - 当检测有调用隐私数据时，在控制台打印输出提示，给出堆栈信息让开发快速定位调用链路；当检测到隐私行为后，输出相对应的记录报告，以便开发人员能够在开发阶段排查问题。



### 02.隐私合规测什么
#### 2.1 隐私合规是什么
- 对客户端而言，权限隐私可分为 **权限** 和 **隐私** 两个大的方面。
- **权限**为用户通过app内弹窗设置或者手机设置内对应app的权限设置方式给予对应app相应的权限
    - 如电话权限，定位权限，相机权限，浮窗权限，读写权限等。
- **隐私**为app使用过程中与用户个人相关的个人信息
    - 如所在位置，Mac地址，设备id等。就Android端而言，多数隐私信息需要对应授权后才能获取，但目前仍存在部分隐私信息无需授权就可以拿到的。


#### 2.2 为何做隐私合规
- 大众隐私意识觉醒，权限隐私安全性差会直接导致用户不愿使用；日趋严格的权限治理和隐私安全治理，工信部和市场的严格管控；
- 客户端作为与用户最直接的交互信息收集入口，有义务合规化的收集和使用用户信息。



#### 2.3 隐私合规政策案例
- 隐私合规案例
    - 比如获取设备信息：获取设备id，androidId等
    - 比如获取权限信息：获取读写存储卡权限，获取电话权限等。
    - http://sofire.bdstatic.com/push/privacy.html
- 需要有文案描述
    - 收集设备id，为了帮助开发者在进行消息推送时识别最终用户设备，保障开发者及最终用户正常使用消息推送服务，提升消息推送服务的效率以及准确率。
    - 获取读写权限，帮助开发者进行最终用户设备识别，保障开发者及最终用户正常使用消息推送服务，提升消息推送服务的效率以及准确率；更准确定位并解决产品和服务使用问题，改进及优化产品和服务体验。


### 04.隐私合规检测
#### 4.1 隐私合规检查什么



#### 4.5 隐私数据注意项
- 遇到的问题，每次排查隐私数据很麻烦
    - 因为随着项目更迭，随时可能有新的隐私安全问题被引入进来，而如果每次发版前都要重新走一遍上述流程来排查是否存在问题的话，也是很麻烦。
- 如何保证隐私合规绝对安全呢
    - 一般都是会通过一个标记位来记录用户是否已经同意过隐私协议，我们可以在每次获取敏感数据前均先判断该标记位，如果用户还未同意隐私协议的话就直接返回空数据，否则才去真正执行操作。



### 05.隐私合规检测库实践
#### 5.1 整体合规思路
- 开发了一个针对 Android APK 的敏感方法调用的静态检查工具。检查关键字，对于一些敏感 API 调用，例如 oaid、androidId、imei 相关的调用。其实只要能检测到这些相关 API 里的一些关键字，找出整个 APP 里面有哪些地方直接调用了这些方法就可以了。
- 针对的上述的一些场景，这个工具具有两个方向的工作：
    - APK 包的扫描，检查出整个APK中，哪些地方有对包含上面这些 API 关键字的直接调用。
    - 运行时检查。针对运行时频繁调用这个场景，还是需要在运行时辅助检查特定API的调用情况。


#### 5.2 方案的选择和比较
- 方案1：Xposed
    - 如果你对Xposed比较熟悉，并且手头有个root的设备安装了Xposed框架，那么直接开发一个Xposed模块来hook指定方法就可以了。缺点是需要root权限……
- 方案2：VirtualXposed
    - VirtualXposed 是基于VirtualApp 和 epic 在非ROOT环境下运行Xposed模块的实现（支持5.0~10.0)。
    - VirtualXposed其实就是一个支持Xposed的虚拟机，我们把开发好的Xposed模块和对应需要hook的App安装上去就能实现hook功能。
- 方案3：epic
    - 如果不想折腾 Xposed 或者 VirtualXposed，只要在应用内接入epic，就可以实现应用内Xposed hook功能，满足运行hook需求。
    - epic 存在兼容性问题，例如Android 11 只支持64位App，所以建议只在debug环境使用。
- 最终选择：方案3
    - 它可以拦截本进程内部几乎任意的 Java 方法调用，可用于实现 AOP 编程、运行时插桩、性能分析、安全审计等。


#### 5.3 处理getDeviceId
- 使用起来也非常简单：提前设置需要 hook 哪个 java 方，比如，我要 hook TelephonyManager 的 getDeviceId 方法：
    ``` java
    //核心方法
    DexposedBridge.findAndHookMethod(TelephonyManager.class, "getDeviceId", new XC_MethodHook() {
        @Override
        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            super.beforeHookedMethod(param);
            String className = param.method.getDeclaringClass().getName();
            String methodName = param.method.getName();
            Log.i(PrivacyHelper.TAG, "检测到风险函数被调用: " + className + "#" + methodName);
            Log.d(PrivacyHelper.TAG, StackTraceUtils.getMethodStack());
        }

        @Override
        protected void afterHookedMethod(MethodHookParam param) throws Throwable {
            super.afterHookedMethod(param);
            Log.d(PrivacyHelper.TAG, "afterHookedMethod getDeviceId");
        }
    });
    ```
- 在代码中如果有地方调用 TelephonyManager.getDeviceId 的，都会被 epic 的 beforeHookedMethod 给拦截到，只需要在 beforeHookedMethod 打印出堆栈即可看到是谁调用的。




#### 5.7 打印堆栈信息
- 为何打印堆栈信息
    - 在应用运行时记录每次触发隐私行为的时间点和调用链信息，根据触发时间来判断该隐私行为是否过量执行，根据调用链信息来辅助判断具体是哪一块业务需要来获取隐私数据。
- 当检测到了风险函数调用情况，则需要知道该函数是在哪里调用的？这个该怎么做呢？
    - 获取当前线程，然后通过线程获取stackTraces，再然后遍历打印即可。根据堆栈信息，可以看到调用链的类名，方法名称，代码行数等。



### 08.其他说明介绍
#### 8.1 参考链接
- http://www.45fan.com/article.php?aid=1yyCmAXXM31pnFuG
- Android 隐私合规静态检查
    - https://mp.weixin.qq.com/s/U06HZb1P5Z2bK_ibtJk9KA
    - https://juejin.cn/post/7046269884207988744
- 隐私权限整理笔记：https://blog.csdn.net/zjy764219923/article/details/123559789

