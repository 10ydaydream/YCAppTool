#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念
    - 1.4 设计目标
    - 1.5 收益分析
- 02.Window概念
    - 2.1 Window的概念
    - 2.2 LayoutParams
    - 2.3 Window窗口坐标
    - 2.4 WPS流程梳理
- 03.悬浮窗技术要点
    - 3.1 业务思考点分析
    - 3.2 关键技术要点
    - 3.3 应用内悬浮窗
    - 3.4 应用外悬浮窗
    - 3.5 悬浮窗添加流程
    - 3.6 拖拽回弹吸附
- 04.开发重要步骤
    - 4.1 悬浮窗实现流程
    - 4.2 请求悬浮窗权限
    - 4.3 初始化悬浮窗
    - 4.4 设置悬浮窗参数
    - 4.5 添加View到悬浮窗
    - 4.6 悬浮窗拖拽实现
    - 4.8 悬浮窗权限适配
    - 4.9 LayoutParam坑
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计
- 07.遇到的问题和坑
    - 7.1 处理输入法层级关系
    - 7.2 边界逻辑关闭悬浮窗
    - 7.3 点击多次打开页面



### 01.整体概述
#### 1.1 项目背景
- 业务场景分析
    - 以视频通话为例，在视频通话时，我们打开其他应用或点击Home键退出时或点击缩放图标，悬浮窗会显示在其他应用之上，给人的假象是通话页面变小了，点击悬浮窗回到通过页面，悬浮窗消失。退出通话页面悬浮窗消失。
- 市面上常见的悬浮窗，如微信视频通话功能，有如下特点：
    - 整屏页面能切换到一个小的悬浮窗；悬浮窗能运行在其他app上方；悬浮窗能跳回整屏页面，并且悬浮窗消失


#### 1.2 遇到问题
- 什么是悬浮窗
    - 全局悬浮窗在许多应用中都能见到，点击Home键，小窗口仍然会在屏幕上显示。
- 那么开发全局悬浮窗属于那一类呢？
    - 属于系统窗口，相当于跟Toast是一个级别的。



#### 1.3 基础概念
- Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。
    - 应用Window，如：Activity和Dialog。
    - 子Window，如：PopupWindow。
    - 系统窗口，如：Toast，输入法，状态栏，导航栏。
- Window 是分层的，每个 Window 都有对应的 z-ordered，层级大的会覆盖在层级小的 Window 上面。
    - 在三种 Window 中，应用 Window 层级范围是 1~99，子 Window 层级范围是1000~1999，系统 Window 层级范围是 2000~2999。
- 这些层级范围对应着 WindowManager.LayoutParams 的 type 参数
    - 如果想要 Window 位于所有 Window 的最顶层，那么采用较大的层级即可，很显然系统 Window 的层级是最大的。
- Android显示系统分为3层
    - UI框架层：负责管理窗口中View组件的布局与绘制以及响应用户输入事件
    - WindowManagerService层：负责管理窗口Surface的布局与次序
    - SurfaceFlinger层：将WindowManagerService管理的窗口按照一定的次序显示在屏幕上


#### 1.4 设计目标
- 目前开发悬浮窗的方案有以下几种
    - 第一种：写在base里面或者监听所有activity生命周期，这样每次启动一个新的Activity都要往页面上addView一次。
    - 第二种：采用在Window上添加View的形式，相当于是全局性的悬浮窗。


#### 1.5 收益分析
- 悬浮窗收益
    - 提高产品的用户体验，app推到后台，或者推出页面做其他操作(比如查看信息)，这个时候浮窗功能主要是增加通话的友好


### 02.Window概念
#### 2.1 Window的概念
- Window是个抽象类，PhoneWindow是Window唯一的实现类。PhoneWindow像是一个工具箱，封装了三种工具：
    - DecorView、WindowManager.LayoutParams、WindowManager。
    - 其中DecorView和WindowManager.LayoutParams负责窗口的静态属性，比如窗口的标题、背景、输入法模式、屏幕方向等等。WindowManager负责窗口的动态操作，比如窗口的增、删、改。
    - Window抽象类对WindowManager.LayoutParams相关的属性（如：输入法模式、屏幕方向）都提供了具体的方法。而对DecorView相关的属性（如：标题、背景），只提供了抽象方法，这些抽象方法由PhoneWindow实现。
- Window并不是真实地存在着的，而是以View的形式存在。
    - Window本身就只是一个抽象的概念，而View是Window的表现形式。要想显示窗口，就必须调用WindowManager.addView(View view, ViewGroup.LayoutParams params)。
    - 参数view就代表着一个窗口。在Activity和Dialog的显示过程中都会调用到wm.addView(decor, l)；所以Activity和Dialog的DecorView就代表着各自的窗口。


#### 2.4 LayoutParams
- WindowManager.LayoutParams这个类用于提供悬浮窗所需的参数，其中有几个经常会用到的变量：
    - type值用于确定悬浮窗的类型，一般设为2002，表示在所有应用程序之上，但在状态栏之下。
    - flags值用于确定悬浮窗的行为，比如说不可聚焦，非模态对话框等等，属性非常多，大家可以查看文档。
    - gravity值用于确定悬浮窗的对齐方式，一般设为左上角对齐，这样当拖动悬浮窗的时候方便计算坐标。
    - x值用于确定悬浮窗的位置，如果要横向移动悬浮窗，就需要改变这个值。
    - y值用于确定悬浮窗的位置，如果要纵向移动悬浮窗，就需要改变这个值。
    - width值用于指定悬浮窗的宽度。
    - height值用于指定悬浮窗的高度。

#### 2.3 Window窗口坐标




### 03.悬浮窗技术要点
#### 3.1 业务思考点分析
- 针对窗口缩小或者悬浮窗需要考虑几个重要的点：
    - 悬浮窗体的比例以及层级，层级要在statusBar之下且在activity之上，这样才能保证其不会被其他业务界面覆盖；
    - 悬浮框显示后，内部的内容如何无缝衔接继续显示；


#### 3.2 关键技术要点
- 悬浮窗权限判断
    - 1
- 将view添加到悬浮窗上
    - 利用addView将View添加在window上，同样的，WindowManager.LayoutParams.type可以设置View的层级，防止被其他业务界面所覆盖。


#### 3.3 应用内悬浮窗
- 应用内悬浮窗实现流程
    - 1.获取WindowManager；2.创建悬浮View；3.设置悬浮View的拖拽事件；4.添加View到WindowManager中
- 对于应用悬浮窗来说，Android版本对其影响不大。
    - Type为TYPE_APPLICATION：只要Activity建立了，就可以添加。
    - Type为TYPE_APPLICATION_ATTACHED_DIALOG：需要在Activity获取焦点，并且用户可操作时才可添加。


#### 3.4 应用外悬浮窗


#### 3.5 悬浮窗添加流程
- 悬浮窗添加流程：
    - -> WindowManager.addView          这个是调用ViewManager接口的addView方法添加视图
    - -> WindowManagerImpl.addView      接着会调用具体实现类
    - -> WindowManagerGlobal.addView    在这个方法中会找到核心的ViewRootImpl
    - -> ViewRootImpl.setView           最后会调用setView将view设置出来
    - -> WindowSession.addToDisplay(AIDL进行IPC)      
    - -> WindowManagerService.addWindow() 
    - -> ViewRootImpl.setView


#### 3.6 拖拽回弹吸附
- 先看微信效果
    - 当你拖动微信悬浮窗的时候，手指松开，这个时候悬浮窗回到边缘，会有一个很友好的动画过渡效果。而并非是改变位置那么生硬。
- 为何做该功能
    - 拖拽回到边缘，如果是直接调用updateLocation，那太生硬了。
- 如何做友好动画
    - 这里可以添加属性动画，给动画设置时间，然后在动画执行获取坐标值。然后再更改位置，这样就比较连贯，效果更好一些。



### 04.开发重要步骤
#### 4.1 悬浮窗实现流程
- 应用内悬浮窗实现流程
    - 第一个是获取WindowManager，然后设置相关params参数。注意配置参数的时候需要注意type
    - 第二个是添加xml或者自定义view到windowManager上
    - 第三个是处理拖拽更改view位置的监听逻辑，分别在down，move，up三个事件处理业务
    - 第四个是吸附左边或者右边，大概的思路是判断手指抬起时候的点是在屏幕左边还是右边


#### 4.2 请求悬浮窗权限
- 关于悬浮窗的权限
    - 当API<18时，系统默认是有悬浮窗的权限，不需要去处理；
    - 当API >= 23时，需要在AndroidManifest中申请权限，为了防止用户手动在设置中取消权限，需要在每次使用时check一下是否有悬浮窗权限存在；
    ```
    Settings.canDrawOverlays(this)
    ```
    - 当API > 25时，系统直接禁止用户使用TYPE_TOAST创建悬浮窗。
    ``` java
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    ```
- 针对不同厂商手机的权限说明
    - 待完善


#### 4.3 初始化悬浮窗
- 第一步：首先创建WindowManager
    ``` java
    //创建WindowManager
    windowManager = (WindowManager)applicationContext.getSystemService(Context.WINDOW_SERVICE);
    layoutParams = new WindowManager.LayoutParams();
    ```



#### 4.4 设置悬浮窗参数
- 第一步：创建LayoutParams
    ``` java
    layoutParams = new WindowManager.LayoutParams();
    ```
- 第二步：LayoutParam设置


#### 4.5 添加View到悬浮窗
- 界面触发悬浮窗代码如下：
    ```
    // 新建悬浮窗控件
    View view = LayoutInflater.from(this).inflate(R.layout.float_window, null);
    view.setOnTouchListener(new FloatingOnTouchListener());
    // 将悬浮窗控件添加到WindowManager
    windowManager.addView(view, layoutParams);
    ```
- 需要注意的是，在隐藏悬浮窗的时候，最好是移除一下，下次需要显示的时候再添加。


#### 4.6 悬浮窗拖拽实现
- 如何实现悬浮窗可随手指拖动？
    - 思路非常简单，监听悬浮窗那个onTouchListener即可，在刚点击的ACTION_DOWN事件中记录当前的x,y位置，然后在每次移动后获取到本次移动的位置，二者相减就是需要移动的位置，这是自定义view的最基本操作了。
- 如何实现悬浮窗左右边的吸顶效果？
    - 监听到手指抬起的动作后，判断当前位置是靠近左边还是右边，靠近左边就以位置动画的方式平移到左边，靠近右边就平移到右边。





#### 4.8 悬浮窗权限适配
- 权限配置和请求，这一块倒是没什么坑
    - 在当Android7.0以上的时候，需要在AndroidManifest.xml文件中声明SYSTEM_ALERT_WINDOW权限
    ``` java
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" />
    ```


#### 4.9 LayoutParam坑
- LayoutParam的坑！！！！
    - WindowManager的addView方法有两个参数，一个是需要加入的控件对象View，另一个参数是WindowManager.LayoutParam对象。
    - LayoutParam里的type变量。需要注意一个坑！！！！！！这个变量是用来指定窗口类型的。在设置这个变量时，需要对不同版本的Android系统进行适配。
    ```
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
    } else {
      layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
    }
    ```
- 在Android 8.0之前，悬浮窗口设置可以为TYPE_PHONE，这种类型是用于提供用户交互操作的非应用窗口。
    - 而Android 8.0对系统和API行为做了修改，包括使用SYSTEM_ALERT_WINDOW权限的应用无法再使用一下窗口类型来在其他应用和窗口上方显示提醒窗口：
    - 如果需要实现在其他应用和窗口上方显示提醒窗口，那么必须该为TYPE_APPLICATION_OVERLAY的新类型。
- 如果在Android 8.0以上版本仍然使用TYPE_PHONE类型的悬浮窗口，则会出现如下异常信息：
    ```
    android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@f8ec928 -- permission denied for window type 2002
    ```


### 07.遇到的问题和坑
#### 7.1 处理输入法层级关系
- 先看一下问题
    - 微信里的悬浮窗是在输入法之下的，所以交互的同学也要求悬浮窗也要在输入法之下。查看了一下WindowManager源码，悬浮窗的优先级TYPE_APPLICATION_OVERLAY，上面大字写着明明是在输入法之下的，但是实际表现是在输入法之上。


#### 7.2 边界逻辑关闭悬浮窗
- 先看一下问题
    - 谷歌坑人的地方，都没地方设置这个悬浮窗是否只用到app内，所以默认在桌面上也会显示自己的悬浮窗。
    - 比如在微信里显示其他app的悬浮窗，这种糟糕的体验可想而知，用户不给你卸载就真是奇迹了。
- 尝试解决这个问题
    - 为了解决这个问题，最初的实现方式是对所有经过的activity进行记录，显示就加1，页面被挂起就减1，如果减到当前计数为0时说明所有页面已经关闭了，就可以隐藏悬浮窗了。
    - 实际上这么做还是有问题的，在部分手机上如果是在首页按返回键的话仍然不能隐藏，这个又是系统级的兼容性问题。
    - 为了解决这问题，后面又做了一个处理，通过注册registerActivityLifecycleCallbacks监听app的前后台回调，检测到如果当前首页被销毁时，应该将悬浮窗进行隐藏。


#### 7.3 点击多次打开页面
- 问题说明一下
    - 如果你的悬浮窗点击事件是打开页面的话，这里需要注意了，别忘了将这个打开的页面的启动模式设置为singleTop或者是singleTask，从而复用同一个，远离一直按返回的地狱操作。




### 参考博客
- Android悬浮框无法弹出输入法的原因
    - https://blog.csdn.net/iromkoear/article/details/68936832
- Android悬浮窗原理解析
    - https://blog.csdn.net/Awenyini/article/details/78265284







