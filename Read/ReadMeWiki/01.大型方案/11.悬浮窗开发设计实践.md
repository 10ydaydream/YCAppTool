#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 基础概念
    - 1.4 设计目标
    - 1.5 收益分析
- 02.Window概念
    - 2.1 Window的概念
    - 2.2 
- 03.悬浮窗技术要点
    - 3.1 业务思考点
    - 3.2 关键技术要点
    - 3.3 应用内悬浮窗
    - 3.4 应用外悬浮窗
    - 3.5 悬浮窗添加流程
- 04.开发重要步骤
    - 4.1 悬浮窗实现流程
    - 4.2 请求悬浮窗权限
    - 4.3 初始化悬浮窗
    - 4.4 设置悬浮窗参数
    - 4.5 添加View到悬浮窗
    - 4.6 悬浮窗拖拽实现
    - 4.8 悬浮窗权限适配
    - 4.9 LayoutParam坑
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计




### 01.整体概述
#### 1.1 项目背景
- 市面上常见的悬浮窗，如微信、手机QQ的视频通话功能，有如下特点：
    - 整屏页面能切换到一个小的悬浮窗
    - 悬浮窗能运行在其他app上方
    - 悬浮窗能跳回整屏页面，并且悬浮窗消失




#### 1.2 遇到问题
- 什么是悬浮窗
    - 全局悬浮窗在许多应用中都能见到，点击Home键，小窗口仍然会在屏幕上显示。
- 那么开发全局悬浮窗属于那一类呢？
    - 属于系统窗口，相当于跟Toast是一个级别的。



#### 1.3 基础概念
- Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。
    - 应用Window，如：Activity和Dialog。
    - 子Window，如：PopupWindow。
    - 系统窗口，如：Toast，输入法，状态栏，导航栏。
- Window 是分层的，每个 Window 都有对应的 z-ordered，层级大的会覆盖在层级小的 Window 上面。
    - 在三种 Window 中，应用 Window 层级范围是 1~99，子 Window 层级范围是1000~1999，系统 Window 层级范围是 2000~2999。
- 这些层级范围对应着 WindowManager.LayoutParams 的 type 参数，如果想要 Window 位于所有 Window 的最顶层，那么采用较大的层级即可，很显然系统 Window 的层级是最大的。
    - 当我们采用系统层级时，一般选用TYPE_SYSTEM_ERROR或者TYPE_SYSTEM_OVERLAY，还需要声明权限。
    ```
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    ```
- Android显示系统分为3层
    - UI框架层：负责管理窗口中View组件的布局与绘制以及响应用户输入事件
    - WindowManagerService层：负责管理窗口Surface的布局与次序
    - SurfaceFlinger层：将WindowManagerService管理的窗口按照一定的次序显示在屏幕上



#### 1.4 设计目标


#### 1.5 收益分析


### 02.Window概念
#### 2.1 Window的概念
- Window是个抽象类，PhoneWindow是Window唯一的实现类。PhoneWindow像是一个工具箱，封装了三种工具：
    - DecorView、WindowManager.LayoutParams、WindowManager。
    - 其中DecorView和WindowManager.LayoutParams负责窗口的静态属性，比如窗口的标题、背景、输入法模式、屏幕方向等等。WindowManager负责窗口的动态操作，比如窗口的增、删、改。
    - Window抽象类对WindowManager.LayoutParams相关的属性（如：输入法模式、屏幕方向）都提供了具体的方法。而对DecorView相关的属性（如：标题、背景），只提供了抽象方法，这些抽象方法由PhoneWindow实现。
- Window并不是真实地存在着的，而是以View的形式存在。
    - Window本身就只是一个抽象的概念，而View是Window的表现形式。要想显示窗口，就必须调用WindowManager.addView(View view, ViewGroup.LayoutParams params)。
    - 参数view就代表着一个窗口。在Activity和Dialog的显示过程中都会调用到wm.addView(decor, l)；所以Activity和Dialog的DecorView就代表着各自的窗口。


### 03.悬浮窗技术要点
#### 3.1 业务思考点
- 针对窗口缩小或者悬浮窗需要考虑几个重要的点：
    - 悬浮窗体的比例以及层级，层级要在statusBar之下且在activity之上，这样才能保证其不会被其他业务界面覆盖；
    - 悬浮框显示后，内部的内容如何无缝衔接继续显示；
- 悬浮窗回到桌面



#### 3.2 关键技术要点
- 悬浮窗权限判断
    - 1
- 将view添加到悬浮窗上
    - 利用addView将View添加在window上，同样的，WindowManager.LayoutParams.type可以设置View的层级，防止被其他业务界面所覆盖。


#### 3.3 应用内悬浮窗
- 应用内悬浮窗实现流程
    - 1.获取WindowManager；2.创建悬浮View；3.设置悬浮View的拖拽事件；4.添加View到WindowManager中
- 对于应用悬浮窗来说，Android版本对其影响不大。
    - Type为TYPE_APPLICATION：只要Activity建立了，就可以添加。
    - Type为TYPE_APPLICATION_ATTACHED_DIALOG：需要在Activity获取焦点，并且用户可操作时才可添加。


#### 3.4 应用外悬浮窗


#### 3.5 悬浮窗添加流程
- 悬浮窗添加流程：
    - -> WindowManager.addView          这个是调用ViewManager接口的addView方法添加视图
    - -> WindowManagerImpl.addView      接着会调用具体实现类
    - -> WindowManagerGlobal.addView    在这个方法中会找到核心的ViewRootImpl
    - -> ViewRootImpl.setView           最后会调用setView将view设置出来
    - -> WindowSession.addToDisplay(AIDL进行IPC)      
    - -> WindowManagerService.addWindow() 
    - -> ViewRootImpl.setView



### 04.开发重要步骤
#### 4.1 悬浮窗实现流程
- 应用内悬浮窗实现流程
    - 获取WindowManager
    - 创建悬浮View
    - 设置悬浮View的拖拽事件
    - 添加View到WindowManager中



#### 4.2 请求悬浮窗权限
- 关于悬浮窗的权限
    - 当API<18时，系统默认是有悬浮窗的权限，不需要去处理；
    - 当API >= 23时，需要在AndroidManifest中申请权限，为了防止用户手动在设置中取消权限，需要在每次使用时check一下是否有悬浮窗权限存在；
    ```
    Settings.canDrawOverlays(this)
    ```
    - 当API > 25时，系统直接禁止用户使用TYPE_TOAST创建悬浮窗。
    ``` java
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    ```


#### 4.3 初始化悬浮窗
- 第一步：首先创建WindowManager
    ``` java
    //创建WindowManager
    windowManager = (WindowManager)applicationContext.getSystemService(Context.WINDOW_SERVICE);
    layoutParams = new WindowManager.LayoutParams();
    ```



#### 4.4 设置悬浮窗参数
- 第一步：创建LayoutParams
    ``` java
    layoutParams = new WindowManager.LayoutParams();
    ```
- 第二步：LayoutParam设置


#### 4.5 添加View到悬浮窗
- 界面触发悬浮窗代码如下：
    ```
    // 新建悬浮窗控件
    View view = LayoutInflater.from(this).inflate(R.layout.float_window, null);
    view.setOnTouchListener(new FloatingOnTouchListener());
    // 将悬浮窗控件添加到WindowManager
    windowManager.addView(view, layoutParams);
    ```


#### 4.6 悬浮窗拖拽实现
- 如何实现悬浮窗可随手指拖动？
    - 思路非常简单，监听悬浮窗那个onTouchListener即可，在刚点击的ACTION_DOWN事件中记录当前的x,y位置，然后在每次移动后获取到本次移动的位置，二者相减就是需要移动的位置，这是自定义view的最基本操作了。
- 如何实现悬浮窗左右边的吸顶效果？
    - 监听到手指抬起的动作后，判断当前位置是靠近左边还是右边，靠近左边就以位置动画的方式平移到左边，靠近右边就平移到右边。





#### 4.8 悬浮窗权限适配
- 权限配置和请求，这一块倒是没什么坑
    - 在当Android7.0以上的时候，需要在AndroidManefest.xml文件中声明SYSTEM_ALERT_WINDOW权限
    ``` java
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" />
    ```

#### 4.9 LayoutParam坑
- LayoutParam的坑！！！！
    - WindowManager的addView方法有两个参数，一个是需要加入的控件对象View，另一个参数是WindowManager.LayoutParam对象。
    - LayoutParam里的type变量。需要注意一个坑！！！！！！这个变量是用来指定窗口类型的。在设置这个变量时，需要对不同版本的Android系统进行适配。
    ```
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
    } else {
      layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
    }
    ```
- 在Android 8.0之前，悬浮窗口设置可以为TYPE_PHONE，这种类型是用于提供用户交互操作的非应用窗口。
    - 而Android 8.0对系统和API行为做了修改，包括使用SYSTEM_ALERT_WINDOW权限的应用无法再使用一下窗口类型来在其他应用和窗口上方显示提醒窗口：
    - 如果需要实现在其他应用和窗口上方显示提醒窗口，那么必须该为TYPE_APPLICATION_OVERLAY的新类型。
- 如果在Android 8.0以上版本仍然使用TYPE_PHONE类型的悬浮窗口，则会出现如下异常信息：
    ```
    android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@f8ec928 -- permission denied for window type 2002
    ```






### 参考博客
- Android悬浮框无法弹出输入法的原因
    - https://blog.csdn.net/iromkoear/article/details/68936832
- Android悬浮窗原理解析
    - https://blog.csdn.net/Awenyini/article/details/78265284







