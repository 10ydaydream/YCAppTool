# 四大组件原理分析1
#### 目录介绍
- 01.Activity启动流程
- 02.Activity绘制流程



### 01.Activity启动流程
#### 1.1 Activity介绍
- 什么是Activity
    - Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。
    - **Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。**


#### 1.2 流程图说明
- 执行启动Activity重点逻辑，大概流程如下所示
    >ActivityStackSupervisor.attachApplicationLocked()
    >ActivityStackSupervisor.realStartActivityLocked()
    >IApplicationThread.scheduleLauncherActivity()
    >ActivityThread.sendMessage()
    >ActivityThread.H.sendMessage()
    >ActivityThread.H.handleMessage()
    >ActivityThread.handleLauncherActivity()
    >ActivityThread.performLauncherActivity()
    >Instrumentation.callActivityOnCreate()
    >Activity.onCreate()
    >ActivityThread.handleResumeActivity()
    >ActivityThread.performResumeActivity()
    >Activity.performResume()
    >Instrumentation.callActivityOnResume()
    >Activity.onResume()
    >ActivityManagerNative.getDefault().activityResumed(token)


#### 1.3 Activity如何创建
- ActivityThread中执行performLaunchActivity，从而生成了Activity的实例。源码如下所示，ActivityThread类中源码
    ``` java
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
        } 
        try {
            if (activity != null) {
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor);
            }
        } 
        return activity;
    }
    ```



### 02.Activity绘制流程
#### 2.1 setContentView()
- 调用PhoneWindow.setContentView(resouseID)
- PhoneWindow中：创建mDector:窗体上的整个View：里面有官方的主题布局+用户自己的布局；
- PhoneWindow中：创建mContentParent:官方主题布局中提供给用户装载布局的容器：id为content；
- 调用mLayoutInflater.inflater(resouseID,mContentParent):
- 解析用户的布局xml
- 递归调用：解析根布局，通过反射创建根布局；解析子view，通过反射创建view；
- 最后PhoneWindow中的mContentParent加载用户的根布局；提交view数据



#### 2.2 View绘制时机
- 在AMS回调ActivityThread中的handleResumeActivity时，也就是Resume时，而不是onCreate()；
    - 获取PhoneWindow
    - 获取PhoneWindow中的mDector布局视图view
    - 将mDector布局视图view传给ViewRootImpl
    - ViewRootImpl中调用requestLayout()
    - requestLayout()中依次调用：performMeasure()、performLayout()、performDraw()


#### 2.3 真正的绘制
- ViewRootImpl.performTraversals()
    - 调用relayoutWindow()：
    - 创建用户java层的surface：只有用户提供的画面数据；
    - 创建native层的surface：包含用户提供的画面数据（java层的surface）+系统的画面数据（状态栏，电池、wifi等等）；
    - 创建完surface后：依次调用：performMeasure（对应view的onMeasure）、performLayout(onLayout)、performDraw(onDraw);
- 在performDraw()中：
    - 将view的数据传至native层的surface
    - surface中的canvas记录数据
    - 生成bitmap图像数据（此时数据是在surface中）
    - 将surface放入队列中；生产者消费者模式；
    - 通知surfaceflinfer进程去队列中取surface数据
    - surfaceflinfer拿到不同的surface,进行融合，生成bitmap数据
    - 将bitmap数据放入framebuffer中，进行展示
































