#### 目录介绍
- 01.Android启动流程
    - 1.1 启动流程图
    - 1.2 流程图说明
- 02.App启动流程
    - 2.1 启动流程图
    - 2.2 流程图说明
- 03.Activity启动流程
    - 3.1 启动流程图
    - 3.2 流程图说明
    - 3.3 Activity如何创建
- 04.Window创建流程
    - 4.1 启动流程图
    - 4.2 流程图说明
    - 4.3 Window如何创建
- 05.Activity绘制流程
    - 5.1 setContentView()
    - 5.2 View绘制时机
    - 5.3 真正的绘制
- 06.DecorView说明
    - 6.1 什么是DecorView
    - 6.2 DecorView如何创建





### 01.App启动流程图
#### 1.1 启动流程图
- 具体看：方案实践，31.1图片


#### 1.2 流程图说明
- 将Android系统的启动分成八层（或者说八个大步骤）
    - 按下电源时引导芯片从代码从预定义的地方（固化在在Rom）开始执行，加载引导程序BootLoaer到RAM。
    - BootLoader程序把系统OS拉起来并运行。
    - Linux内核启动，这里面我们最关心的是init进程的启动，它是所有用户进程的鼻祖。
    - 初始化init进程，这里面最重要的是启动Zygote进程，它是所有APP 进程的鼻祖（或者说是Java进程）。
    - 初始化Zygote进程，创建运行APP所需要的服务，例如Java虚拟机、注册JNI方法以及启动SystemServer进程。
    - 初始化SystemServer进程，这里最重要的就是启动Binder线程池以及一些核心服务，比如PMS、WMS、AMS等。
    - AMS是管理Android 四大组件的核心服务，系统启动后会让AMS将系统桌面（也就是Launcher）加载出来。
    - Launcher作为所有APP 的入口，点击Launcher上的图标后就会启动APP（如果APP进程不在，会先Fork Zygote进程来创建新进程）。
- Zygote进程说明
    - Zygote进程是所有的android进程的父进程
        - 包括SystemServer和各种应用进程都是通过Zygote进程fork出来的。Zygote（孵化）进程相当于是android系统的根进程，后面所有的进程都是通过这个进程fork出来的。
    - 各个进程的先后顺序
        - init进程 --> Zygote进程 --> SystemServer进程 -->各种应用进程



### 02.App启动流程图
#### 2.1 启动流程图
- 看1.2图片
- App点击桌面图片启动过程
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-75aaec2032f31d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 2.2 流程图说明
- 大概流程如下所示
    >ActivityManagerService.startProcessLocked()
    >Process.start()
    >ActivityThread.main()
    >ActivityThread.attach()
    >ActivityManagerNative.getDefault().attachApplication()
    >ActivityManagerService.attachApplication()
- APP启动流程可以分三个阶段：
    - Launcher请求AMS阶段。
    - AMS到ApplicationThread的调用过程。
    - ActivityThread启动Activity过程。



### 03.Activity启动流程
#### 3.1 启动流程图
- 什么是Activity
    - Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。
    - **Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。**




#### 3.2 流程图说明
- 执行启动Activity重点逻辑，大概流程如下所示
    >ActivityStackSupervisor.attachApplicationLocked()
    >ActivityStackSupervisor.realStartActivityLocked()
    >IApplicationThread.scheduleLauncherActivity()
    >ActivityThread.sendMessage()
    >ActivityThread.H.sendMessage()
    >ActivityThread.H.handleMessage()
    >ActivityThread.handleLauncherActivity()
    >ActivityThread.performLauncherActivity()
    >Instrumentation.callActivityOnCreate()
    >Activity.onCreate()
    >ActivityThread.handleResumeActivity()
    >ActivityThread.performResumeActivity()
    >Activity.performResume()
    >Instrumentation.callActivityOnResume()
    >Activity.onResume()
    >ActivityManagerNative.getDefault().activityResumed(token)


#### 3.3 Activity如何创建
- ActivityThread中执行performLaunchActivity，从而生成了Activity的实例。源码如下所示，ActivityThread类中源码
    ``` java
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
        } 
        try {
            if (activity != null) {
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor);
            }
        } 
        return activity;
    }
    ```


### 04.Window创建流程
#### 4.1 启动流程图
- window启动流程
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-99d9bf7265c1566b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- Window是什么？
    - 表示一个窗口的概念，是所有View的直接管理者，任何视图都通过Window呈现(点击事件由Window->DecorView->View; Activity的setContentView底层通过Window完成)
    - Window是一个抽象类，具体实现是PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局`R.layout.activity_main`。
    - 创建Window需要通过WindowManager创建，通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。
    - WindowManager是外界访问Window的入口
    - Window具体实现位于WindowManagerService中
    - WindowManager和WindowManagerService的交互是通过IPC完成
- 如何通过WindowManager添加Window(代码实现)？
    - 如下所示
        ```
        //1. 控件 
        Button button = new Button(this); 
        button.setText("Window Button"); 
        //2. 布局参数 
        WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); 
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; 
        layoutParams.gravity = Gravity.LEFT | Gravity.TOP; 
        layoutParams.x = 100; 
        layoutParams.y = 300; 
        // 必须要有type不然会异常: the specified window type 0 is not valid 
        layoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR; 
        //3. 获取WindowManager并添加控件到Window中 
        WindowManager windowManager = getWindowManager(); 
        windowManager.addView(button, layoutParams);
        ```
- WindowManager的主要功能是什么？
    - 添加、更新、删除View
        ```
        public interface ViewManager{ 
            public void addView(View view, ViewGroup.LayoutParams params); 
            //添加View 
            public void updateViewLayout(View view, ViewGroup.LayoutParams params); 
            //更新View 
            public void removeView(View view); 
            //删除View 
        }
        ```


#### 4.2 流程图说明



#### 4.3 Window如何创建
- 从上面的performLaunchActivity可以看出，在创建Activity实例的同时，会调用Activity的内部方法attach
- 在attach该方法中完成window的初始化。源码如下所示，Activity类中源码
    ```
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback) {
        //创建 PhoneWindow
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
    }
    ```



### 05.Activity层级图
#### 5.1 setContentView()
- 调用PhoneWindow.setContentView(resouseID)
- PhoneWindow中：创建mDector:窗体上的整个View：里面有官方的主题布局+用户自己的布局；
- PhoneWindow中：创建mContentParent:官方主题布局中提供给用户装载布局的容器：id为content；
- 调用mLayoutInflater.inflater(resouseID,mContentParent):
- 解析用户的布局xml
- 递归调用：解析根布局，通过反射创建根布局；解析子view，通过反射创建view；
- 最后PhoneWindow中的mContentParent加载用户的根布局；提交view数据



#### 5.2 View绘制时机
- 在AMS回调ActivityThread中的handleResumeActivity时,也就是Resume时，而不是onCreate()；
    - 获取PhoneWindow
    - 获取PhoneWindow中的mDector布局视图view
    - 将mDector布局视图view传给ViewRootImpl
    - ViewRootImpl中调用requestLayout()
    - requestLayout()中依次调用：performMeasure()、performLayout()、performDraw()


#### 5.3 真正的绘制
- ViewRootImpl.performTraversals()
    - 调用relayoutWindow()：
    - 创建用户java层的surface：只有用户提供的画面数据；
    - 创建native层的surface：包含用户提供的画面数据（java层的surface）+系统的画面数据（状态栏，电池、wifi等等）；
    - 创建完surface后：依次调用：performMeasure（对应view的onMeasure）、performLayout(onLayout)、performDraw(onDraw);
- 在performDraw()中：
    - 将view的数据传至native层的surface
    - surface中的canvas记录数据
    - 生成bitmap图像数据（此时数据是在surface中）
    - 将surface放入队列中；生产者消费者模式；
    - 通知surfaceflinfer进程去队列中取surface数据
    - surfaceflinfer拿到不同的surface,进行融合，生成bitmap数据
    - 将bitmap数据放入framebuffer中，进行展示



### 06.DecorView说明
#### 6.1 什么是DecorView
- DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。
    - DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，**在这个LinearLayout里面有上下三个部分，上面是个ViewStub，延迟加载的视图（应该是设置ActionBar，根据Theme设置），中间的是标题栏(根据Theme设置，有的布局没有)，下面的是内容栏。** 具体情况和Android版本及主体有关，以其中一个布局为例，如下所示：
    ``` java
    <LinearLayout >
        <ViewStub
            android:id="@+id/action_mode_bar_stub"/>
        <FrameLayout>
            <TextView
                android:id="@android:id/title"/>
        </FrameLayout>
    
        <FrameLayout
            android:id="@android:id/content"/>
    </LinearLayout>
    ```
- 在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，成为其唯一子View，就是上面的id为content的FrameLayout中，在代码中可以通过content来得到对应加载的布局。
    ```
    ViewGroup content = (ViewGroup)findViewById(android.R.id.content);
    ViewGroup rootView = (ViewGroup) content.getChildAt(0);
    ```
- Activity 与 PhoneWindow 与 DecorView 关系图
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-6d7499e30fa16789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- Activity 与 PhoneWindow 与 DecorView 之间什么关系？
    - 一个 Activity 对应一个 Window 也就是 PhoneWindow，一个 PhoneWindow 持有一个 DecorView 的实例，DecorView 本身是一个 FrameLayout。



#### 6.2 DecorView如何创建
- 从Activity中的setContentView()开始。
    - 在Activity中的attach()方法中，生成了PhoneWindow实例。既然有了Window对象，那么我们就可以**设置DecorView给Window对象了。
    - 从中获取mContentParent。获得到之后，然后通过installDecor方法，然后生成DecorView，不过这里操作很复杂，大概流程先从主题中获取样式，然后根据样式，加载对应的布局到DecorView中，为mContentParent添加View，即Activity中的布局。






