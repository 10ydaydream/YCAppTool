#### 目录介绍
- 01.事件体系的介绍
    - 1.1 事件体系说明
    - 1.2 什么是事件序列
    - 1.3 如何理解事件序列
    - 1.4 为什么会有分发
- 02.事件序列的设计
    - 2.1 事件序列设计思路
    - 2.2 事件序列导图
    - 2.3 理解事件中递归设计
- 03.事件传递流程
    - 3.1 事件传递的全流程
    - 3.2 事件分发机制方法
    - 3.3 事件分发流程
    - 3.4 事件拦截流程
    - 3.5 事件处理流程
- 04.事件体系案例分析
    - 4.1 先看一个案例
    - 4.2 该案例事件传递情况
    - 4.3 案例默认处理分析
    - 4.4 案例处理事件分析
    - 4.5 拦截DOWN事件
    - 4.6 拦截后续事件（MOVE、UP）
- 05.事件机制源码分析
    - 
- 06.事件冲突案例分析
    - 6.1 滑动冲突说明
    - 6.2 外部拦截法
    - 6.3 内部处理法
    - 6.4 一个常见案例分析
    - 6.5 选择合适的方案


### 01.事件体系的介绍
#### 1.1 事件体系说明
- 完整的掌握 `Android` 事件分发体系并非易事
    - 其整个流程涉及到了 **系统启动流程**（`SystemServer`）、**输入管理**(`InputManager`)、**系统服务和UI的通信**（`ViewRootImpl` + `Window` + `WindowManagerService`）、`View`层级的 **事件分发机制** 等等一系列的环节。
- **事件拦截机制** 
    - 是基于`View`层级 **事件分发机制** 的一个进阶性的知识点。




#### 1.2 什么是事件序列
- 什么是事件序列？可以将其理解为 **用户一次完整的触摸操作流程**。
    - 举例来说，用户单击按钮、用户滑动屏幕、用户长按屏幕中某个UI元素等等，都属于该范畴。
- Android中的TouchEvent/MotionEvent
    - 每一次我们触摸屏幕，都会产生一连串的触摸事件，这些一连串的触摸事件合起来就是一个触摸事件序列。



#### 1.3 如何理解事件序列
- 事件分发的本质原理就是递归，对此简单的实现方式是：
    - 每接收一个新的事件，都需要进行一次递归才能找到对应消费事件的View，并依次向上返回事件分发的结果。
- 思考一下
    - 以每个触摸事件作为最基本的单元，都对`View`树进行一次遍历递归？这对性能的影响显而易见，因此这种设计是有改进空间的。
- 将 **事件序列** 作为最基本的单元进行处理则更为合适。
    - 首先，设计者根据用户的行为对MotionEvent中添加了一个Action的属性以描述该事件的行为：DOWN，MOVE，UP，其他Action事件……
    - 针对用户的一次触摸操作，必然对应了一个事件序列，从用户手指接触屏幕，到移动手指，再到抬起手指 ——单个事件序列必然包含ACTION_DOWN、ACTION_MOVE ... ACTION_MOVE、ACTION_UP 等多个事件，这其中ACTION_MOVE的数量不确定，ACTION_DOWN和ACTION_UP的数量则为1。
- 任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图：
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-07c61723cc06b338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 1.4 为什么会有分发
- 举一个实际案例了解为何有分发
    - 假设屏幕坐标为（11，11）的区域既属于一个LinearLayout，又属于LinearLayout下的一个Button。那这次触碰所产生的触摸事件，是该给LinearLayout还是Button呢？
    - 当然，最终会被Button点击所处理。那触摸事件是怎么给到Button的呢？需要经过LinearLayout吗？怎样能让Button不处理呢？在View树上传递与消费的过程，这就是事件的分发。




### 02.事件序列的设计
#### 2.1 事件序列设计思路




### 03.事件传递流程
#### 3.1 事件传递的全流程
- Android触摸事件流程
	* 1.一个事件序列从手指触摸屏幕开始，到触摸结束。同一事件序列是以ACTION_DOWN开始，中间有数量不定的ACTION_MOVE事件，最终以ACTION_UP结束
	* 2.事件传递顺序是：Activity(Window)——>ViewGroup——>View；最后顶级View接收到事件后，就会按照事件分发机制去分发事件
	* 3.事件传递过程是由外向内的，即事件总是有父元素分发给子元素



#### 3.2 事件分发机制方法
- 事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成，如下图：
    - ![](http://upload-images.jianshu.io/upload_images/944365-74bdb5c375a37100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则
    ``` java
    // 点击事件产生后，会直接调用dispatchTouchEvent分发方法
    public boolean dispatchTouchEvent(MotionEvent ev) {
        //代表是否消耗事件
        boolean consume = false;
        if (onInterceptTouchEvent(ev)) {
            //如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件
            //则该点击事件则会交给当前View进行处理
            //即调用onTouchEvent (）方法去处理点击事件
            consume = onTouchEvent (ev) ;
        } else {
            //如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件
            //则该点击事件则会继续传递给它的子元素
            //子元素的dispatchTouchEvent（）就会被调用，重复上述过程
            //直到点击事件被最终处理为止
            consume = child.dispatchTouchEvent (ev) ;
        }
        return consume;
    }
    ```


#### 3.3 事件分发流程
- 事件分发的对象是事件
    - 注意，事件分发是向下传递的，也就是父到子的顺序。
- 事件分发的本质：将点击事件（MotionEvent）向某个View进行传递并最终得到处理
    - 即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。**这个事件传递的过程就是分发过程。**
    - Android事件分发机制的本质是要解决，点击事件由哪个对象发出，经过哪些对象，最终达到哪个对象并最终得到处理。




#### 3.4 事件拦截流程



#### 3.5 事件处理流程



### 04.事件体系案例分析
#### 4.1 先看一个案例
- 讨论的布局层次如下：
    - ![](http://upload-images.jianshu.io/upload_images/944365-ecac6247816a3db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 最外层：Activity A，包含两个子View：ViewGroup B、View C
    - 中间层：ViewGroup B，包含一个子View：View C
    - 最内层：View C
- 触摸情况
    - 假设用户首先触摸到屏幕上View C上的某个点（如图中黄色区域），那么Action_DOWN事件就在该点产生，然后用户移动手指并最后离开屏幕。



#### 4.2 该案例事件传递情况
- 一般的事件传递场景有：
    - 默认情况
    - 处理事件
    - 拦截DOWN事件
    - 拦截后续事件（MOVE、UP）


#### 4.3 案例默认处理分析
- 即不对控件里的方法(dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent())进行重写或更改返回值
- 那么调用的是这3个方法的默认实现：调用父类的方法
- 事件传递情况：
    - 从Activity A---->ViewGroup B--->View C，从上往下调用dispatchTouchEvent()
    - 再由View C--->ViewGroup B --->Activity A，从下往上调用onTouchEvent()
- 注：虽然ViewGroup B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent()
- 注意：这一点与onTouchEvent的行为是不一样的。


#### 4.4 案例处理事件分析
- 假设View C希望处理这个点击事件，即C被设置成可点击的（Clickable）或者覆写了C的onTouchEvent方法返回true。
    - 最常见的：设置Button按钮来响应点击事件
- 事件传递情况：
    - DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理这个事件
    - 因为C正在处理这个事件，那么DOWN事件将不再往上传递给B和A的onTouchEvent()；
    - 该事件列的其他事件（Move、Up）也将传递给C的onTouchEvent()



#### 4.5 拦截DOWN事件
- 假设ViewGroup B希望处理这个点击事件
    - 即B覆写了onInterceptTouchEvent()返回true、onTouchEvent()返回true。
- 事件传递情况：
    - DOWN事件被传递给B的onInterceptTouchEvent()方法，该方法返回true，表示拦截这个事件，即自己处理这个事件（不再往下传递）
    - 调用onTouchEvent()处理事件（DOWN事件将不再往上传递给A的onTouchEvent()）
    - 该事件列的其他事件（Move、Up）将直接传递给B的onTouchEvent()
- 该事件列的其他事件（Move、Up）将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。


#### 4.6 拦截后续事件（MOVE、UP）
- 假设ViewGroup B没有拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件。
    - DOWN事件传递到C的onTouchEvent方法，返回了true。
    - 在后续到来的MOVE事件，B的onInterceptTouchEvent方法返回true拦截该MOVE事件，但该事件并没有传递给B；这个MOVE事件将会被系统变成一个CANCEL事件传递给C的onTouchEvent方法
    - 后续又来了一个MOVE事件，该MOVE事件才会直接传递给B的onTouchEvent()
        > 1.后续事件将直接传递给B的onTouchEvent()处理
        > 2.后续事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。
    - C再也不会收到该事件列产生的后续事件。
- 特别注意：
    - 如果ViewGroup A 拦截了一个半路的事件（如MOVE），这个事件将会被系统变成一个CANCEL事件并传递给之前处理该事件的子View；
    - 该事件不会再传递给ViewGroup A的onTouchEvent()
    - 只有再到来的事件才会传递到ViewGroup A的onTouchEvent()



### 06.事件冲突案例分析
#### 6.1 滑动冲突说明
- 滑动冲突的场景
    - 滑动冲突常发生于两个可滑动的控件发生嵌套的情况下。比如RecyclerView嵌套ListView，RecyclerView嵌套ScrollView，ViewPager嵌套RecyclerView等。
- 讨论的布局层次如下：
    - Activity A，包含两个子View：ScrollView B、ViewPager C
- 什么是事件冲突
    - 当父容器与子 View 都可以滑动时，就会产生滑动冲突。
- 根据两个控件的滑动方向，可以将滑动冲突分成两类：
    - 一个是不同方向的滑动冲突，如外层控件垂直滑动，内层控件水平滑动。另一个就是同方向的滑动冲突，如内外两层控件都是垂直滑动。
- 如何解决冲突
    - 解决 View 之间的滑动冲突的方法分为两种，分别是外部拦截法和内部拦截法




#### 6.2 外部拦截法
- 什么叫做外部拦截法
    - 外部拦截法，指的是从外部容器入手，去决定是否要去拦截事件，若拦截掉，子View就没法消费了。
    - 父容器根据需要在 `onInterceptTouchEvent` 方法中对触摸事件进行选择性拦截。
- 外部拦截法的思路
    - 根据实际的业务需求，判断是否需要处理 ACTION_MOVE 事件，如果父 View 需要处理则返回 true，否则返回 false 并交由子 View 去处理
    - ACTION_DOWN 事件需要返回 false，父容器不能进行拦截，否则根据 View 的事件分发机制，后续的 ACTION_MOVE 与 ACTION_UP 事件都将默认交由父容器进行处理
    - 原则上 ACTION_UP 事件也需要返回 false，如果返回 true，那么子 View 将接收不到 ACTION_UP 事件，子 View 的onClick 事件也无法触发



#### 6.3 内部处理法
- 内部拦截法则是要求父容器不拦截任何事件
    - 所有事件都传递给子View，子View根据需求判断是自己消费事件还是传回给父容器进行处理。
    - 从内部容器出发去解决冲突。这依赖于ViewParent#requestDisallowInterceptTouchEvent()。
- 内部处理法的思路
    - 内部拦截法要求父容器不能拦截 ACTION_DOWN 事件，否则一旦父容器拦截 ACTION_DOWN 事件，那么后续的触摸事件都不会传递给子View
    - 滑动策略的逻辑放在子 View 的 `dispatchTouchEvent` 方法的 ACTION_MOVE 事件中，如果父容器需要处理事件则调用 `parent.requestDisallowInterceptTouchEvent(false)` 方法让父容器去拦截事件


#### 6.4 一个常见案例分析
- 场景解释：
    - 为了能使整个Activity界面能够上下滑动，使用了ScrollView，将TabLayout和ViewPager的联合包裹在LinearLayout中，有滑动冲突问题。
- 外部拦截法解决滑动冲突
    - 滑动方向不同之以ScrollView与ViewPager为例的外部解决法。处理是ScrollView，在onInterceptTouchEvent中处理冲突。
    - 从 父View 着手，重写 onInterceptTouchEvent 方法，在 父View 需要拦截的时候拦截，不要的时候返回false。
    - 举个例子，如果是左右滑动冲突，则在DOWN事件记录x和y坐标，在MOVE事件计算x和y轴移动距离，如果是x轴移动距离大于y轴，则返回false表示不拦截。将左右滑动交给ViewPager处理。
- 内部拦截法解决滑动冲突
    - 从子View着手，父View 先不要拦截任何事件，所有的 事件传递给子View，如果子View需要此事件就消费掉，不需要此事件的话就交给 父View 处理。
    - 实现思路 如下，重写 子View 的dispatchTouchEvent方法，在DOWN动作中通过方法requestDisallowInterceptTouchEvent（true） 先请求 父View 不要拦截事件，这样保证子View能够接受到MOVE事件，再在Action_move动作中根据自己的逻辑是否要拦截事件，不要的话再交给 父View 处理


#### 6.5 选择合适的方案
- 进行个小结：
    - “外部拦截法”所使用的原理是运用事件分发机制，去改变事件分发的路径，拦截内部容器的事件。
    - “内部拦截法”使用的是requestDisallowInterceptTouchEvent()方法设置FLAG，不让父容器/祖先容器用onInterceptTouchEvent拦截方法。
- 如何选择合适解决办法
    - 使用“内部拦截法”还是“外部拦截法”，首先需要去看实际业务需要我们怎么做，是从“内部”实现比较方便，还是从“外部”实现比较方便。
    - 相较于“外部拦截法”，“内部拦截法”并没有减少事件分发的层级，因此看起来可能会更加复杂一些。并且也需要注意requestDisallowInterceptTouchEvent方法具体在哪个方法中使用。
    - 若两个方法都能实现最终的效果，建议优先使用“外部拦截法”。






### 02.Activity的事件分发机制
#### 2.1 源码分析
- 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发
    - 具体是由Activity的Window来完成
- 我们来看下Activity的dispatchTouchEvent()的源码
    ```
    public boolean dispatchTouchEvent(MotionEvent ev) {
        //第一步
        //一般事件列开始都是DOWN，所以这里基本是true
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            //第二步
            onUserInteraction();
        }
        //第三步
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
    ```
- 第一步
    - 一般事件列开始都是DOWN（按下按钮），所以这里返回true，执行onUserInteraction()
- 第二步
    - 先来看下onUserInteraction()源码
    ```
    public void onUserInteraction() { 
    }
    ```
    - 从源码可以看出：
        - 该方法为空方法
        - 从注释得知：当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法
        - 所以onUserInteraction()主要用于屏保
- 第三步
    - Window类是抽象类，且PhoneWindow是Window类的唯一实现类
    - superDispatchTouchEvent(ev)是抽象方法
    - 通过PhoneWindow类中看一下superDispatchTouchEvent()的作用
    ```
    @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
        //mDecor是DecorView的实例
        //DecorView是视图的顶层view，继承自FrameLayout，是所有界面的父类
    }
    ```
- 接下来我们看mDecor.superDispatchTouchEvent(event)：
    ```
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    //DecorView继承自FrameLayout
    //那么它的父类就是ViewGroup
    而super.dispatchTouchEvent(event)方法，其实就应该是ViewGroup的dispatchTouchEvent()
    
    }
    ```
- 得出结果
    - **执行getWindow().superDispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event)**
    - 这样事件就从 Activity 传递到了 ViewGroup 



#### 2.2 点击事件调用顺序
- 当一个点击事件发生时，调用顺序如下
    - 1.事件最先传到Activity的dispatchTouchEvent()进行事件分发
    - 2.调用Window类实现类PhoneWindow的superDispatchTouchEvent()
    - 3.调用DecorView的superDispatchTouchEvent()
    - 4.最终调用DecorView父类的dispatchTouchEvent()，**即ViewGroup的dispatchTouchEvent()**




#### 2.3 得出结论
- 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，最终是调用了ViewGroup的dispatchTouchEvent()方法
- 这样事件就从 Activity 传递到了 ViewGroup 




### 03.ViewGroup事件的分发机制
#### 3.1 看一下这个案例
- **布局如下：**
    - ![](http://upload-images.jianshu.io/upload_images/944365-b0bf3dd7ad41b335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 结果测试
    - 只点击Button，发现执行顺序：btn1，btn2
    - 再点击空白处，发现执行顺序：btn1，btn2，viewGroup
- 从上面的测试结果发现：
    - 当点击Button时，执行Button的onClick()，但ViewGroupLayout注册的onTouch（）不会执行
    - 只有点击空白区域时才会执行ViewGroupLayout的onTouch（）;
    - 结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。


#### 3.2 源码分析
- ViewGroup的dispatchTouchEvent()源码分析,该方法比较复杂，截取几个重要的逻辑片段进行介绍，来解析整个分发流程。
    ```
    // 发生ACTION_DOWN事件或者已经发生过ACTION_DOWN,并且将mFirstTouchTarget赋值，才进入此区域，主要功能是拦截器
    final boolean intercepted;
    if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) {
        //disallowIntercept：是否禁用事件拦截的功能(默认是false),即不禁用
        //可以在子View通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改，不让该View拦截事件
        final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
        //默认情况下会进入该方法
        if (!disallowIntercept) {
            //调用拦截方法
            intercepted = onInterceptTouchEvent(ev); 
            ev.setAction(action);
        } else {
            intercepted = false;
        }
    } else {
        // 当没有触摸targets，且不是down事件时，开始持续拦截触摸。
        intercepted = true;
    }
    ```
    - 这一段的内容主要是为判断是否拦截。如果当前事件的MotionEvent.ACTION_DOWN，则进入判断，调用ViewGroup onInterceptTouchEvent()方法的值，判断是否拦截。如果mFirstTouchTarget != null，即已经发生过MotionEvent.ACTION_DOWN，并且该事件已经有ViewGroup的子View进行处理了，那么也进入判断，调用ViewGroup onInterceptTouchEvent()方法的值，判断是否拦截。如果不是以上两种情况，即已经是MOVE或UP事件了，并且之前的事件没有对象进行处理，则设置成true，开始拦截接下来的所有事件。**这也就解释了如果子View的onTouchEvent()方法返回false，那么接下来的一些列事件都不会交给他处理。如果VieGroup的onInterceptTouchEvent()第一次执行为true，则mFirstTouchTarget = null，则也会使得接下来不会调用onInterceptTouchEvent()，直接将拦截设置为true。**
- 当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View或ViewGroup进行处理。
    ```
      /* 从最底层的父视图开始遍历，
       ** 找寻newTouchTarget，即上面的mFirstTouchTarget
       ** 如果已经存在找寻newTouchTarget，说明正在接收触摸事件，则跳出循环。
        */
    for (int i = childrenCount - 1; i >= 0; i--) {
      final int childIndex = customOrder
        ? getChildDrawingOrder(childrenCount, i) : i;
      final View child = (preorderedList == null)
        ? children[childIndex] : preorderedList.get(childIndex);
    
      // 如果当前视图无法获取用户焦点，则跳过本次循环
      if (childWithAccessibilityFocus != null) {
         if (childWithAccessibilityFocus != child) {
            continue;
         }
         childWithAccessibilityFocus = null;
         i = childrenCount - 1;
      }
      //如果view不可见，或者触摸的坐标点不在view的范围内，则跳过本次循环
      if (!canViewReceivePointerEvents(child) 
          || !isTransformedTouchPointInView(x, y, child, null)) {
        ev.setTargetAccessibilityFocus(false);
        continue;
        }
    
       newTouchTarget = getTouchTarget(child);
       // 已经开始接收触摸事件,并退出整个循环。
       if (newTouchTarget != null) {
           newTouchTarget.pointerIdBits |= idBitsToAssign;
           break;
        }
    
        //重置取消或抬起标志位
        //如果触摸位置在child的区域内，则把事件分发给子View或ViewGroup
        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
            // 获取TouchDown的时间点
            mLastTouchDownTime = ev.getDownTime();
            // 获取TouchDown的Index
            if (preorderedList != null) {
               for (int j = 0; j < childrenCount; j++) {
                   if (children[childIndex] == mChildren[j]) {
                        mLastTouchDownIndex = j;
                        break;
                    }
               }
             } else {
                     mLastTouchDownIndex = childIndex;
                    }
    
          //获取TouchDown的x,y坐标
          mLastTouchDownX = ev.getX();
          mLastTouchDownY = ev.getY();
          //添加TouchTarget,则mFirstTouchTarget != null。
          newTouchTarget = addTouchTarget(child, idBitsToAssign);
          //表示以及分发给NewTouchTarget
          alreadyDispatchedToNewTouchTarget = true;
          break;
    }
    ```
    - `dispatchTransformedTouchEvent()`方法实际就是调用子元素的`dispatchTouchEvent()`方法。
    - 其中`dispatchTransformedTouchEvent()`方法的重要逻辑如下：
    ```
    if (child == null) {
        handled = super.dispatchTouchEvent(event);
    } else {
        handled = child.dispatchTouchEvent(event);
    }
    ```
    - 由于其中传递的child不为空，所以就会调用子元素的dispatchTouchEvent()。如果子元素的dispatchTouchEvent()方法返回true，那么mFirstTouchTarget就会被赋值，同时跳出for循环。
    ```
    //添加TouchTarget,则mFirstTouchTarget != null。
    newTouchTarget = addTouchTarget(child, idBitsToAssign);
     //表示以及分发给NewTouchTarget
     alreadyDispatchedToNewTouchTarget = true;
    ```
    - 其中在`addTouchTarget(child, idBitsToAssign);`内部完成mFirstTouchTarget被赋值。如果mFirstTouchTarget为空，将会让ViewGroup默认拦截所有操作。如果遍历所有子View或ViewGroup，都没有消费事件。ViewGroup会自己处理事件。



#### 3.3 得出结论
- Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View
- 在ViewGroup中通过onInterceptTouchEvent()对事件传递进行拦截
    - 1.onInterceptTouchEvent方法返回true代表拦截事件，即不允许事件继续向子View传递；
    - 2.返回false代表不拦截事件，即允许事件继续向子View传递；（默认返回false）
    - 3.子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。



### 04.View事件的分发机制
#### 4.1 源码分析 
- View中dispatchTouchEvent()的源码分析
    ```
    public boolean dispatchTouchEvent(MotionEvent event) {  
        if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  
                mOnTouchListener.onTouch(this, event)) {  
            return true;  
        }  
        return onTouchEvent(event);  
    }
    ```
- 从上面可以看出：
    - 只有以下三个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent(event)方法
    ```
    第一个条件：mOnTouchListener != null；
    第二个条件：(mViewFlags & ENABLED_MASK) == ENABLED；
    第三个条件：mOnTouchListener.onTouch(this, event)；
    ```
- 下面，我们来看看下这三个判断条件：
    - **第一个条件：mOnTouchListener!= null**
    ```
    //mOnTouchListener是在View类下setOnTouchListener方法里赋值的
    public void setOnTouchListener(OnTouchListener l) { 
    
    //即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）
        mOnTouchListener = l;  
    }
    ```
    - **第二个条件：(mViewFlags & ENABLED_MASK) == ENABLED**
    - 该条件是判断当前点击的控件是否enable
    - 由于很多View默认是enable的，因此该条件恒定为true
    - **第三个条件：mOnTouchListener.onTouch(this, event)**
    - 回调控件注册Touch事件时的onTouch方法
    ```
    //手动调用设置
    button.setOnTouchListener(new OnTouchListener() {  
        @Override  
        public boolean onTouch(View v, MotionEvent event) {  
            return false;  
        }  
    });
    ```
    - 如果在onTouch方法返回true，就会让上述三个条件全部成立，从而整个方法直接返回true。
    - 如果在onTouch方法里返回false，就会去执行onTouchEvent(event)方法。
- 接下来，我们继续看：**onTouchEvent(event)**的源码分析
    ```
    public boolean onTouchEvent(MotionEvent event) {  
        final int viewFlags = mViewFlags;  
        if ((viewFlags & ENABLED_MASK) == DISABLED) {  
            // A disabled view that is clickable still consumes the touch  
            // events, it just doesn't respond to them.  
            return (((viewFlags & CLICKABLE) == CLICKABLE ||  
                    (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));  
        }  
        if (mTouchDelegate != null) {  
            if (mTouchDelegate.onTouchEvent(event)) {  
                return true;  
            }  
        }  
         //如果该控件是可以点击的就会进入到下两行的switch判断中去；
    
        if (((viewFlags & CLICKABLE) == CLICKABLE ||  
                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {  
        //如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。
    
            switch (event.getAction()) {  
                case MotionEvent.ACTION_UP:  
                    boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;  
                   // 在经过种种判断之后，会执行到关注点1的performClick()方法。
                   //请往下看关注点1
                    if ((mPrivateFlags & PRESSED) != 0 || prepressed) {  
                        // take focus if we don't have it already and we should in  
                        // touch mode.  
                        boolean focusTaken = false;  
                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {  
                            focusTaken = requestFocus();  
                        }  
                        if (!mHasPerformedLongPress) {  
                            // This is a tap, so remove the longpress check  
                            removeLongPressCallback();  
                            // Only perform take click actions if we were in the pressed state  
                            if (!focusTaken) {  
                                // Use a Runnable and post this rather than calling  
                                // performClick directly. This lets other visual state  
                                // of the view update before click actions start.  
                                if (mPerformClick == null) {  
                                    mPerformClick = new PerformClick();  
                                }  
                                if (!post(mPerformClick)) {  
                //关注点1
                //请往下看performClick()的源码分析
                                    performClick();  
                                }  
                            }  
                        }  
                        if (mUnsetPressedState == null) {  
                            mUnsetPressedState = new UnsetPressedState();  
                        }  
                        if (prepressed) {  
                            mPrivateFlags |= PRESSED;  
                            refreshDrawableState();  
                            postDelayed(mUnsetPressedState,  
                                    ViewConfiguration.getPressedStateDuration());  
                        } else if (!post(mUnsetPressedState)) {  
                            // If the post failed, unpress right now  
                            mUnsetPressedState.run();  
                        }  
                        removeTapCallback();  
                    }  
                    break;  
                case MotionEvent.ACTION_DOWN:  
                    if (mPendingCheckForTap == null) {  
                        mPendingCheckForTap = new CheckForTap();  
                    }  
                    mPrivateFlags |= PREPRESSED;  
                    mHasPerformedLongPress = false;  
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
                    break;  
                case MotionEvent.ACTION_CANCEL:  
                    mPrivateFlags &= ~PRESSED;  
                    refreshDrawableState();  
                    removeTapCallback();  
                    break;  
                case MotionEvent.ACTION_MOVE:  
                    final int x = (int) event.getX();  
                    final int y = (int) event.getY();  
                    // Be lenient about moving outside of buttons  
                    int slop = mTouchSlop;  
                    if ((x < 0 - slop) || (x >= getWidth() + slop) ||  
                            (y < 0 - slop) || (y >= getHeight() + slop)) {  
                        // Outside button  
                        removeTapCallback();  
                        if ((mPrivateFlags & PRESSED) != 0) {  
                            // Remove any future long press/tap checks  
                            removeLongPressCallback();  
                            // Need to switch from pressed to not pressed  
                            mPrivateFlags &= ~PRESSED;  
                            refreshDrawableState();  
                        }  
                    }  
                    break;  
            }  
    //如果该控件是可以点击的，就一定会返回true
            return true;  
        }  
    //如果该控件是不可以点击的，就一定会返回false
        return false;  
    }
    ```
- **关注点1：**
    - performClick()的源码分析
    ```
    public boolean performClick() {  
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  
    
        if (mOnClickListener != null) {  
            playSoundEffect(SoundEffectConstants.CLICK);  
            mOnClickListener.onClick(this);  
            return true;  
        }  
        return false;  
    }
    ```
    - 只要mOnClickListener不为null，就会去调用onClick方法；
- 那么，mOnClickListener又是在哪里赋值的呢？请继续看：
    ```
    public void setOnClickListener(OnClickListener l) {  
        if (!isClickable()) {  
            setClickable(true);  
        }  
        mOnClickListener = l;  
    }
    ```
    - 当我们通过调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值（不为空），即会回调onClick（）。



#### 4.2 得出结论
- 1.onTouch（）的执行高于onClick（）
- 2.每当控件被点击时：
    - 如果在回调onTouch()里返回false，就会让dispatchTouchEvent方法返回false，那么就会执行onTouchEvent()；如果回调了setOnClickListener()来给控件注册点击事件的话，最后会在performClick()方法里回调onClick()。
        - onTouch()返回false（该事件没被onTouch()消费掉） = 执行onTouchEvent() = 执行OnClick()
    - 如果在回调onTouch()里返回true，就会让dispatchTouchEvent方法返回true，那么将不会执行onTouchEvent()，即onClick()也不会执行；
        - onTouch()返回true（该事件被onTouch()消费掉） = dispatchTouchEvent()返回true（不会再继续向下传递） = 不会执行onTouchEvent() = 不会执行OnClick()


#### 4.3 验证结论
- 在回调onTouch()里返回true
    ```
    TextView textView = findViewById(R.id.tv_13);
    //设置OnTouchListener()
    textView.setOnTouchListener(new View.OnTouchListener() {
    
        @Override
        public boolean onTouch(View v, MotionEvent event) {
            Log.d("小杨逗比","执行了onTouch(), 动作是:" + event.getAction());
            return true;
        }
    });
    //设置OnClickListener
    textView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.d("小杨逗比","执行了onClick()");
        }
    });
    ```
    - 打印日志如下所示
    - 注意action为0是ACTION_DOWN，为2是ACTION_MOVE，为1是ACTION_UP。
    ```
    2019-04-04 13:37:58.301 13616-13616/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:0
    2019-04-04 13:37:58.315 13616-13616/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:2
    2019-04-04 13:37:58.405 13616-13616/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:2
    2019-04-04 13:37:58.408 13616-13616/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:1
    ```
- 在回调onTouch()里返回false
    - 打印结果如下所示
    ```
    2019-04-04 13:41:26.961 14006-14006/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:0
    2019-04-04 13:41:26.978 14006-14006/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:2
    2019-04-04 13:41:27.072 14006-14006/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:2
    2019-04-04 13:41:27.074 14006-14006/org.yczbj.ycrefreshview D/小杨逗比: 执行了onTouch(), 动作是:1
    2019-04-04 13:41:27.076 14006-14006/org.yczbj.ycrefreshview D/小杨逗比: 执行了onClick()
    ```
- **总结：onTouch()返回true就认为该事件被onTouch()消费掉，因而不会再继续向下传递，即不会执行OnClick()。**


### 05.思考一下
#### 5.1 onTouch()和onTouchEvent()的区别
- 这两个方法都是在View的dispatchTouchEvent中调用，但onTouch优先于onTouchEvent执行。
- 如果在onTouch方法中返回true将事件消费掉，onTouchEvent()将不会再执行。
- 特别注意：请看下面代码
    ```
    //&&为短路与，即如果前面条件为false，将不再往下执行
    //所以，onTouch能够得到执行需要两个前提条件：
    //1. mOnTouchListener的值不能为空
    //2. 当前点击的控件必须是enable的。
    mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  
            mOnTouchListener.onTouch(this, event)
    ```
- 因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。



#### 5.2 Touch事件的后续事件（MOVE、UP）层级传递
- 如果给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等）
- 当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP）
    - 即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE和ACTION_UP事件都不会执行
- 从上面对事件分发机制分析知：
    - dispatchTouchEvent()和 onTouchEvent()消费事件、终结事件传递（返回true） 
    - 而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用
    - 请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP）
- **这里给出ACTION_MOVE和ACTION_UP事件的传递结论**：
    - 如果在某个对象（Activity、ViewGroup、View）的dispatchTouchEvent()消费事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP
    - 如果在某个对象（Activity、ViewGroup、View）的onTouchEvent()消费事件（返回true），那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent()并结束本次事件传递过程。





#### 8.0.0.2 onInterceptTouchEvent方法作用是什么？onTouchEvent的方法的作用是什么？
- onInterceptTouchEvent方法作用是什么？
    - 在dispatchTouchEvent的内部调用，用于判断是否拦截某个事件
    - View和ViewGroup在onInterceptTouchEvent上的区别：
        - View没有该方法，View会处理所有收到的事件，但不一定会消耗该事件。
        - onInterceptTouchEvent是ViewGroup中添加的方法，用于判断是否拦截该事件。
- onTouchEvent的方法的作用是什么？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 在dispatchTouchEvent的中调用，用于处理点击事件
    - 返回结果表示是否消耗当前事件





#### 8.0.0.4 滑动冲突有哪些场景？滑动冲突处理原则是什么？滑动冲突解决办法有哪些？分别是如何解决的？
- 滑动冲突有哪些场景？
    - 内层和外层滑动方向不一致：一个垂直，一个水平。比如轮播图ViewPager和ScrollView
    - 内存和外层滑动方向一致：均垂直or水平。比如scrollView和RecyclerView
    - 前两者层层嵌套。比如ScrollView和RecyclerView(recyclerView中又嵌套recyclerView)
- 滑动冲突处理原则
    - 对于内外层滑动方向不同，只需要根据滑动方向来给相应控件拦截
    - 对于内外层滑动方向相同，需要根据业务来进行事件拦截，规定何时让外部View拦截事件何时由内部View拦截事件。
    - 前两者嵌套的情况，根据前两种原则层层处理即可。
- 滑动冲突解决办法有哪些？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。
    - 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。
- 外部拦截解决滑动冲突法
    - 外部拦截法要点
        - 父容器的onInterceptTouchEvent方法中处理
        - ACTION_DOWN不拦截，一旦拦截会导致后续事件都直接交给父容器处理。
        - ACTION_MOVE中根据情况进行拦截，拦截：return true，不拦截：return false（外部拦截核心）
        - ACTION_UP不拦截，如果父控件拦截UP，会导致子元素接收不到UP进一步会让onClick方法无法触发。此外UP拦截也没什么用。
    - onClick方法生效的两个条件？
        - View可以点击
        - 接收到了DOWN和UP事件
    - 外部拦截，自定义ScrollView，这块可以看我的博客：





#### 8.0.0.5 onTouch()、onTouchEvent()和onClick()关系是怎样的，哪一个先执行？如果设置了onClickListener, 但是onClick()没有调用，可能产生的原因？ 
- onTouch()、onTouchEvent()和onClick()关系是怎样的，哪一个先执行？
    - onTouch->onTouchEvent->onClick
        - 当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener的onTouch方法会被回调。
        - 这时事件如何处理还得看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的onTouchListener，其优先级比onTouchEvent要高。
        - 如果当前方法中设置了onClickListener，那么它的onClick方法会被调用。可以看出，常用的OnClickListener，其优先级别最低。
- 如果设置了onClickListener, 但是onClick()没有调用，可能产生的原因？ [技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 父View拦截了事件，没有传递到当前View
    - View的Enabled = false(setEnabled(false)): view处于不可用状态，会直接返回。
    - View的Clickable = false(setClickable\setLongClickable(false)):view不可以点击，不会执行onClick
    - View设置了onTouchListener，且消耗了事件。会提前返回。
    - View设置了TouchDelegate，且消耗了事件。会提前返回。





#### 8.0.0.6 View滑动有哪些方法？这些方法分别是如何实现滑动的？分别有什么优缺点？
- View滑动有哪些方法？
    - layout：对View进行重新布局定位。在onTouchEvent()方法中获得控件滑动前后的偏移。然后通过layout方法重新设置。
    - offsetLeftAndRight和offsetTopAndBottom:系统提供上下/左右同时偏移的API。onTouchEvent()中调用
    - LayoutParams: 更改自身布局参数
    - scrollTo/scrollBy: 本质是移动View的内容，需要通过父容器的该方法来滑动当前View
    - Scroller: 平滑滑动，通过重载computeScroll()，使用scrollTo/scrollBy完成滑动效果。
    - 属性动画: 动画对View进行滑动[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - ViewDragHelper: 谷歌提供的辅助类，用于完成各种拖拽效果。
- Layout实现滑动
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-d1d63c609f2c3c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- offsetLeftAndRight和offsetTopAndBottom实现滑动
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-973bba1e87a55917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- LayoutParams实现滑动
    - 通过父控件设置View在父控件的位置，但需要指定父布局的类型，不好
    - 用ViewGroup的MariginLayoutParams的方法去设置margin
        ```
        //方法一：通过布局设置在父控件的位置。但是必须要有父控件, 而且要指定父布局的类型，不好的方法。 
        RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams(); 
        layoutParams.leftMargin = getLeft() + offsetX; 
        layoutParams.topMargin = getTop() + offsetY; 
        setLayoutParams(layoutParams);
        /**===============================================
         * 方法二：用ViewGroup的MarginLayoutParams的方法去设置marign
         * 优点：相比于上面方法, 就不需要知道父布局的类型。
         * 缺点：滑动到右侧控件会缩小
         *===============================================*/ 
        ViewGroup.MarginLayoutParams mlayoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();
        mlayoutParams.leftMargin = getLeft() + offsetX; 
        mlayoutParams.topMargin = getTop() + offsetY; 
        setLayoutParams(mlayoutParams);
        ```
- scrollTo\scrollBy实现滑动
    - 都是View提供的方法。
    - scrollTo-直接到新的x,y坐标处。
    - scrollBy-基于当前位置的相对滑动。
    - scrollBy-内部是调用scrollTo.
    - scrollTo\scrollBy, 效果是移动View的内容，因此需要在View的父控件中调用。
    - scrollTo/By内部的mScrollX和mScrollY的意义
        - mScrollX的值，相当于手机屏幕相对于View左边缘向右移动的距离，手机屏幕向右移动时，mScrollX的值为正；手机屏幕向左移动(等价于View向右移动)，mScrollX的值为负。
        - mScrollY和X的情况相似，手机屏幕向下移动，mScrollY为+正值；手机屏幕向上移动，mScrollY为-负值。
        - mScrollX/Y是根据第一次滑动前的位置来获得的，例如：第一次向左滑动200(等于手机屏幕向右滑动200)，mScrollX = 200；第二次向右滑动50, mScrollX = 200 + （-50）= 150，而不是（-50）。
- 动画实现滑动的方法
    - 可以通过传统动画或者属性动画的方式实现
    - 传统动画需要通过设置fillAfter为true来保留动画后的状态(但是无法在动画后的位置进行点击操作，这方面还是属性动画好)
    - 属性动画会保留动画后的状态，能够点击。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
- ViewDragHelper
    - 通过ViewDragHelper去自定义ViewGroup让其子View具有滑动效果。不过用的很少



#### 8.0.0.7 事件的传递规则是什么？View处理事件的优先级？点击事件传递过程遵循如下顺序？事件传递规则要点？
- 事件的传递规则是什么？
    - 点击事件产生后，会先传递给根ViewGroup，并调用dispatchTouchEvent
    - 之后会通过onInterceptTouchEvent判断是否拦截该事件，如果true，则表示拦截并交给该ViewGroup的onTouchEvent方法进行处理
    - 如果不拦截，则当前事件会传递给子元素，调用子元素的dispatchTouchEvent，如此反复直到事件被处理
- View处理事件的优先级？
    - 在View需要处理事件时，会先调用OnTouchListener的onTouch方法，并判断onTouch的返回值
    - 返回true，表示处理完成，不会调用onTouchEvent方法
    - 返回false，表示未完成，调用onTouchEvent方法进行处理
    - 可见，onTouchEvent的优先级没有OnTouchListener高
    - onTouchEvent没有消耗的话就会交给TouchDelegate的onTouchEvent去处理。
    - 如果最后事件都没有消耗，会在onTouchEvent中执行performClick()方法，内部会执行OnClickListener的onClick方法，优先级最低，属于事件传递尾端
- 点击事件传递过程遵循如下顺序？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - Activity->Window->View->分发
    - 如果View的onTouchEvent返回false，则父容器的onTouchEvent会被调用，最终可以传递到Activity的onTouchEvent
- 事件传递规则要点？
    - View一旦拦截事件，则整个事件序列都由它处理(ACTION_DOWN\UP等)，onInterceptTouchEvent不会再调用(因为默认都拦截了)
    - 但是一个事件序列也可以通过特殊方法交给其他View处理(onTouchEvent)
    - 如果View开始处理事件(已经拦截)，如果不消耗ACTIO_DOWN事件(onTouchEvent返回false)，则同一事件序列的剩余内容都直接交给父onTouchEvent处理
    - View消耗了ACTION_DOWN，但不处理其他的事件，整个事件序列会消失(父onTouchEvent)不会调用。这些消失的点击事件最终会传给Activity处理。
    - ViewGroup默认不拦截任何事件(onInterceptTouchEvent默认返回false)
    - View没有onInterceptTouchEvent方法，一旦有事件传递给View，onTouchEvent就会被调用
    - View的onTouchEvent默认都会消耗事件return true, 除非该View不可点击(clickable和longClickable同时为false)
    - View的enable属性不影响onTouchEvent的默认返回值。即使是disable状态。
    - onClick的发生前提是当前View可点击，并且收到了down和up事件
    - 事件传递过程是由父到子，层层分发，可以通过requestDisallowInterceptTouchEvent让子元素干预父元素的事件分发(ACTION_DOWN除外)


#### 8.0.0.8 Scroller的作用？Scroller的要点有哪些？Scroller的使用步骤？Scroller工作原理？
- Scroller的作用？
    - 用于封装滑动
    - 提供了基于时间的滑动偏移值，但是实际滑动需要我们去负责。
- Scroller的要点有哪些？
    - 调用startScroll方法时，Scroller只是单纯的保存参数
    - 之后的invalidate方法导致的View重绘
    - View重绘之后draw方法会调用自己实现的computeScroll()，才真正实现了滑动
- Scroller的使用步骤？
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-31619d7d004543e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- Scroller工作原理？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - Scroller本身不能实现View的滑动，需要配合View的computeScroll方法实现弹性滑动
    - 不断让View重绘，每一次重绘距离滑动的开始时间有一个时间间隔，通过该时间可以得到View当前的滑动距离
    - View的每次重绘都会导致View的小幅滑动，多次小幅滑动就组成了弹性滑动



#### 8.0.0.9 Activity事件分发的过程？Window事件分发？DecorView的事件分发？根View的事件分发？
- Activity事件分发的过程？
    - 事件分发过程：Activity->Window->Decor View(当前界面的底层容器，setContentView的View的父容器)->ViewGroup->View
    - Activity的dispatchTouchEvent，会交给Window处理(getWindow().superDispatchTouchEvent())，
    - 返回true：事件全部结束
    - 返回false：所有View都没有处理(onTouchEvent返回false)，则调用Activity的onTouchEvent
- Window事件分发？
    - Window和superDispatchTouchEvent分别是抽象类和抽象方法
    - Window的实现类是PhoneWindow
    - PhoneWindow的superDispatchTouchEvent()直接调用mDecor.superDispatchTouchEvent(),也就是直接传给了DecorView
- DecorView的事件分发？
    - DecorView继承自FrameLayout
    - DecorView的superDispatchTouchEvent()会调用super.dispatchTouchEvent()——也就是ViewGroup的dispatchTouchEvent方法，之后就会层层分发下去。
- 根View的事件分发？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 顶层View调用dispatchTouchEvent
    - 调用onInterceptTouchEvent方法
    - 返回true，事件由当前View处理。如果有onTouchiListener，会执行onTouch，并且屏蔽掉onTouchEvent。没有则执行onTouchEvent。如果设置了onClickListener，会在onTouchEvent后执行onClickListener
    - 返回false，不拦截，交给子View重复如上步骤。



#### 8.0.1.0 GestureDetector是干什么用的？GestureDetector作用和注意点？有哪些常用的监听方法？
- GestureDetector作用和注意点？
    - 探测手势和事件，需要通过提供的MotionEvent
    - 该类仅能用于touch触摸提供的MotionEvent，不能用于traceball events(追踪球事件)
    - 可以在自定义View中重写onTouchEvent()方法并在里面用GestureDetector接管。
    - 可以在View的setOnTouchListener的onTouch中将点击事件交给GestureDetector接管。
- 有哪些常用的监听方法？
    - OnGestureListener
    - OnDoubleTapListener
    - OnContextClickListener
    - SimpleOnGestureListener
- OnGestureListener
    - OnGestureListener作用[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - 用于在手势产生时，去通知监听者。
        - 该监听器会监听所有的手势，如果只需要监听一部分可以使用SimpleOnGestureListener
    - OnGestureListener能监听哪些手势
        - 按下操作。
        - 按下之后，Move和Up之前。用于提供视觉反馈告诉用户已经捕获了他们的行为。
        - 抬起操作。
        - 滑动操作(由Down MotionEvent e1触发，当前是Move MotionEvent e2)
        - 长按操作。
        - 猛扔操作。
        - 所有有返回值的回调方法，return true-消耗该事件；return false-不消耗该事件
- OnDoubleTapListener
    - OnDoubleTapListener作用
        - 监听“双击操作”
        - 监听“确认的单击操作”—该单击操作之后的操作无法构成一次双击。
    - OnDoubleTapListener能监听哪些手势？
        - 单击操作。
        - 双击操作.
        - 双击操作之间发生了down、move或者up事件。




#### 8.0.1.2 View的滑动方式？如何让控件滚动到某一位置？scrollTo()和scrollBy()的区别？Scroller是什么？
- View的滑动方式？
    - 三种方式：
        - a. 通过View本身提供的scrollTo/scrollBy方法
            - 移动的是View的内容，View本身不移动
        - b. 通过动画给View施加平移效果实现滑动
            - 通过补间动画移动的View的影像，View本身位置不发生改变。通过属性动画移动view的影像，view本身位置会发生改变。
        - c. 通过改变View的LayoutParams使View重新布局实现滑动
            - 改变布局参数，代码如下：
            ```
            MarginLayoutParams params = (MarginLayoutParams) mButton.getLayoutParams();
            params.width += 10;
            params.height += 10;
            mButton.setLayoutParams(params);
            ```
    - 三种方法的使用对比
        - scrollTo/scrollBy：操作简单，适合对View内容的滑动；
        - 动画：操作简单，主要适合于没有交互的View和实现复杂的动画效果；
        - 改变布局参数：操作稍微复杂，适用于有交互的View。
- scrollTo()和scrollBy()[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - scrollBy内部调用了scrollTo，它是基于当前位置的相对滑动；而scrollTo是绝对滑动，因此如果利用相同输入参数多次调用scrollTo()方法，由于View初始位置是不变只会出现一次View滚动的效果而不是多次。
    - 引申：两者都只能对view内容进行滑动，而不能使view本身滑动，且非平滑，可使用Scroller有过渡滑动的效果。
- Scroller实现滑动的具体过程：
    - 在MotionEvent.ACTION_UP事件触发时调用startScroll()方法，该方法并没有进行实际的滑动操作，而是记录滑动相关量
    - 马上调用invalidate/postInvalidate()方法，请求View重绘，导致View.draw方法被执行
    - 紧接着会调用View.computeScroll()方法，此方法是空实现，需要自己处理逻辑。具体逻辑是：先判断computeScrollOffset()，若为true（表示滚动未结束），则执行scrollTo()方法，它会再次调用postInvalidate()，如此反复执行，直到返回值为false。
    - ![image](https://upload-images.jianshu.io/upload_images/5494434-049e25c8dd5caa0f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)





#### 8.0.1.6 SurfaceView和View的区别，说一下SurfaceView的工作原理，为何不会导致页面卡顿？
- SurfaceView是从View基类中派生出来的显示类，他和View的区别有：
    - View需要在UI线程对画面进行刷新，而SurfaceView可在子线程进行页面的刷新
    - View适用于主动更新的情况，而SurfaceView适用于被动更新，如频繁刷新，这是因为如果使用View频繁刷新会阻塞主线程，导致界面卡顿[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - SurfaceView在底层已实现双缓冲机制，而View没有，因此SurfaceView更适用于需要频繁刷新、刷新时数据处理量很大的页面




