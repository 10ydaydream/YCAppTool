# View绘制流程分析
#### 目录介绍
- 01.addView的流程分析
- 02.requestLayout绘制
    - 2.1 源码流程分析
    - 2.2 View绘制流程简析
- 03.performMeasure测量
    - 3.1 performMeasure源码
- 04.performLayout布局
    - 4.1 performLayout源码
- 05.performDraw绘制
    - 5.1 performDraw源码
- 06.View绘制流程总结下
    - 6.1 Activity布局绘制
- 07.View如何显示在屏幕



### 00.问题答疑思考




### 01.addView的流程分析
- 通过WindowManager添加View分析
    > wm.addView()，根据WindowManagerImpl --> WindowManager --> ViewManager，最终可知vm是WindowManagerImpl的实例，具体看WindowManagerImpl的addView方法
    > WindowManagerImpl#addView()，在这个类中可以看到调用了mGlobal.addView()，而mGlobal是WindowManagerGlobal的对象。
    > WindowManagerGlobal#addView()，这里面逻辑很核心，创建ViewRootImpl对象，这个是布局渲染的核心类
    > WindowManagerGlobal#addView#root.setView()，实现了root与ViewRootImpl的关联
    > ViewRootImpl#setView()#requestLayout()，在ViewRootImpl的setView方法中，调用requestLayout执行重绘的请求
- 从这里可以知道几个核心的关键点
    - 在global#addView()的源码中，创建ViewRootImpl对象root，然后将root和view绑定起来



### 02.requestLayout绘制
#### 2.1 源码流程分析
- requestLayout是执行View绘制入口
    > ViewRootImpl#requestLayout#checkThread()，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误
    > ViewRootImpl#scheduleTraversals()，这里主要是入口
    > ViewRootImpl#scheduleTraversals()#mChoreographer.postCallback(mTraversalRunnable)，调用一个异步消息，用于执行mTraversalRunnable的run方法
    > ViewRootImpl#TraversalRunnable#run()，在TraversalRunnable类的run方法中调用了doTraversal方法
    > ViewRootImpl#doTraversal()，这里主要是看performTraversals方法
    > ViewRootImpl#performTraversals()，整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作
- `ViewRootImpl#performTraversals`方法中核心代码如下所示
    ``` java
    private void performTraversals() {
        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
        performLayout(lp, mWidth, mHeight);
        performDraw();
    }
    ```
    - ![image](https://img-blog.csdnimg.cn/de9fd44442c3430a9dd11fe9c86f9fbd.png)



#### 2.2 View绘制流程简析
- 接下来看一下View的测量，位置，绘制三个流程
    - ![image](https://img-blog.csdnimg.cn/9d5f24df130749c0bd2cea2c4fc73776.png)
    > ViewRootImpl#performTraversals()#performMeasure，执行View组件的onMeasure方法，主要用于测量View
        > ViewRootImpl#performMeasure()，开始执行测量的入口
        > View#measure()，这个时候开始调用View类中的测量
    > ViewRootImpl#performTraversals()#performLayout，执行View组件的onLayout方法，主要用于布局View
        > ViewRootImpl#performLayout()，开始执行布局的入口
        > View#layout()，这个时候调用调用View类中的布局
    > ViewRootImpl#performTraversals()#performDraw，执行View组件的onDraw方法，主要用于绘制View
        > ViewRootImpl#performDraw()，开始执行绘制的入口
- View的绘制流程主要分为三步：
    - onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成绘制工作。
    - onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。
    - onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。
- **onMeasure()方法**：
    - 单一View，一般重写此方法，针对wrap_content情况，规定View默认的大小值，避免于match_parent情况一致。ViewGroup，若不重写，就会执行和单子View中相同逻辑，不会测量子View。一般会重写onMeasure()方法，循环测量子View。
    - Measure完成后可以通过getMeasureWidth和getMeasureHeight方法获取到view的测量后的宽高，在几乎所有的情况下都会等于最终view的宽高
    - onMeasure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。
- **onLayout()方法:**
    - 单一View，不需要实现该方法。ViewGroup必须实现，该方法是个抽象方法，实现该方法，来对子View进行布局。
    - layout 过程决定了View的四个顶点的坐标和实际的View的宽高，完成以后可以通过getTop,getBottom,getLeft,getRight来获取View的四个顶点位置，并通过getWidth,getHeight获取View的最终宽高
- **onDraw()方法：**
    - 无论单一View，或者ViewGroup都需要实现该方法，因其是个空方法
    - draw过程则决定了View的显示，完成draw后view会显示在屏幕上
    - 绘制背景(background.draw(Canvas))
    - 绘制自己    protected void onDraw(Canvas canvas)    onDraw绘制自己，新建一个paint 在canvas上绘制自己的图形
    - 绘制children (dispatchDraw)dispatchDraw会遍历调用所有子元素的draw方法
    - 绘制装饰（onDrawScrollBars）




### 03.performMeasure测量
#### 3.1 performMeasure源码
- 从ViewRootImpl类中分析performMeasure测量，这里是测量的入口
    > ViewRootImpl#performMeasure()，在performMeasure方法中我们又调用了mView的measure方法。这里的mView就是一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法
    > View#measure()，在View的measure方法中，又调用了onMeasure方法。由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法
    > FrameLayout#onMeasure()，这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法。
        - 这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法
    > View#onMeasure()，调用了setMeasuredDimension方法设置测量的结果
    > View#setMeasuredDimension()，在这个方法中调用了setMeasuredDimensionRaw方法，把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中





### 04.performLayout布局
#### 4.1 performLayout源码
- 从ViewRootImpl类中分析performLayout测量，这里是测量的入口
    > ViewRootImpl#performLayout()，具体看一下host.layout()，这个host就是一开始的Activity的mDector根组件
    > View#layout()，看源码执行了onLayout方法，host是一个FrameLayout，所以跟measure类似的，看一下FrameLayout的onLayout方法的实现
    > FrameLayout#onLayout()，调用了layoutChildren方法
    > FrameLayout#layoutChildren()，在这个方法中，遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法
    > View#layout()，经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中





### 05.performDraw绘制
#### 5.1 performDraw源码流程
- 从ViewRootImpl类中分析performDraw测量，这里是测量的入口
    > ViewRootImpl#performDraw()，看源码可知调用了draw(fullRedrawNeeded)
    > ViewRootImpl#draw()，调用了mView的draw方法，这里的mView是我们的mDector，看一下draw方法的具体实现
    > ViewRootImpl#drawSoftware()，调用mSurface.lockCanvas方法获取一个Canvas对象，然后drawColor，translate，setScreenDensity等等。最后调用mView.draw(canvas)。
    > ViewRootImpl#drawSoftware()#mView.draw(canvas)，由于mView是我们的mDector，因此这里可以看FrameLayout的draw方法
    > FrameLayout#draw()，如果包含子View，那么也会执行子View的draw方法。
- 从上述源码可以看到ViewRootImpl有一个Surface属性，当界面绘制时，就调用mSurface.lockCanvas方法获取一个Canvas对象传递个View递归绘制。ViewRootImpl简易类图如下。
    - ![image](https://img-blog.csdnimg.cn/fe4d39ff6f2d4ed292282bdc9f432a9a.png)
- 然后看一下Surface的源码
    > Surface#lockCanvas，这里调用了nativeLockCanvas方法
    > android_view_Surface#nativeLockCanvas()。
    ``` C
    //frameworks\base\core\jni\android_view_Surface.cpp
    static jlong nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) {
        sp<Surface> surface(reinterpret_cast<Surface *>(nativeObject));
        Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);
        // 给Canvas设置Bitmap
        nativeCanvas->setBitmap(bitmap);
        sp<Surface> lockedSurface(surface);
        lockedSurface->incStrong(&sRefBaseOwner);
        return (jlong) lockedSurface.get();
    }
    ```
- 我们的界面像素数据保存在Surface中，这个Surface就是在ViewRootImpl中创建的。
    - ![image](https://img-blog.csdnimg.cn/bba439f66ef441e5a6eec06d2720ab83.png)      




- ViewRootImpl.performTraversals()真正的绘制
    - 调用relayoutWindow()：
    - 创建用户java层的surface：只有用户提供的画面数据；
    - 创建native层的surface：包含用户提供的画面数据（java层的surface）+系统的画面数据（状态栏，电池、wifi等等）；
    - 创建完surface后：依次调用：performMeasure（对应view的onMeasure）、performLayout(onLayout)、performDraw(onDraw);
- 在performDraw()中：
    - 将view的数据传至native层的surface
    - surface中的canvas记录数据
    - 生成bitmap图像数据（此时数据是在surface中）
    - 将surface放入队列中；生产者消费者模式；
    - 通知surfaceflinfer进程去队列中取surface数据
    - surfaceflinfer拿到不同的surface,进行融合，生成bitmap数据
    - 将bitmap数据放入framebuffer中，进行展示



### 06.View绘制流程总结下
#### 6.1 Activity布局绘制
- 想要弄清楚View是怎么绘制的得先弄明白View是怎么创建出来的。我们先来看下View的创建流程。
    - ![image](https://img-blog.csdnimg.cn/e4c031c7bb2846fbafd60aa11a8e7eeb.png)
- 总结如下所示：
    - Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。
    - View的绘制流程包含了测量大小，测量位置，绘制三个流程；
    - Activity的界面绘制是从mDoctor即根View开始的，也就是从mDoctor的测量大小，测量位置，绘制三个流程；
    - View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的；
    - View的测量大小流程:performMeasure --> measure --> onMeasure等方法;
    - View的测量位置流程：performLayout --> layout --> onLayout等方法；
    - View的绘制流程：onDraw等方法；
    - View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑；
    - Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）；




### 07.View如何显示在屏幕
- 一个 view 究竟是如何显示在屏幕上的？
    - 一般都比较了解 view 渲染的三大流程，但是 view 的渲染远不止于此：此处以一个通用的硬件加速流程来表征
    - ![image](https://img-blog.csdnimg.cn/1a64ad8a867f40689eff87d592fea5b1.png)
- 关于整个View显示在屏幕上的流程如下
    - Vsync 调度：很多同学的一个认知误区在于认为 vsync 是每 16ms 都会有的，但是其实 vsync 是需要调度的，没有调度就不会有回调；
    - 消息调度：主要是 doframe 的消息调度，如果消息被阻塞，会直接造成卡顿；
    - input 处理：触摸事件的处理；
    - 动画处理：animator 动画执行和渲染；
    - view 处理：主要是 view 相关的遍历和三大流程；
    - measure、layout、draw：view 三大流程的执行；
    - DisplayList 更新：view 硬件加速后的 draw op；
    - OpenGL 指令转换：绘制指令转换为 OpenGL 指令；
    - 指令 buffer 交换：OpenGL 的指令交换到 GPU 内部执行；
    - GPU 处理：GPU 对数据的处理过程；
    - layer 合成：surface buffer 合成屏幕显示 buffer 的流程；
    - 光栅化：将矢量图转换为位图；
    - Display：显示控制；
    - buffer 切换：切换屏幕显示的帧 buffer；










