# View绘制流程分析
#### 目录介绍
- 01.addView的流程分析
- 02.requestLayout绘制
- 03.performMeasure测量
- 04.performLayout布局
- 05.performDraw绘制
- 06.View绘制流程总结下



### 01.addView的流程分析
- 通过WindowManager添加View分析
    > wm.addView()，根据WindowManagerImpl --> WindowManager --> ViewManager，最终可知vm是WindowManagerImpl的实例，具体看WindowManagerImpl的addView方法
    > WindowManagerImpl#addView()，在这个类中可以看到调用了mGlobal.addView()，而mGlobal是WindowManagerGlobal的对象。
    > WindowManagerGlobal#addView()，这里面逻辑很核心，创建ViewRootImpl对象，这个是布局渲染的核心类
    > WindowManagerGlobal#addView#root.setView()，实现了root与ViewRootImpl的关联
    > ViewRootImpl#setView()#requestLayout()，在ViewRootImpl的setView方法中，调用requestLayout执行重绘的请求
- 从这里可以知道几个核心的关键点
    - 在global#addView()的源码中，创建ViewRootImpl对象root，然后将root和view绑定起来



### 02.requestLayout绘制
- requestLayout是执行View绘制入口
    > ViewRootImpl#requestLayout#checkThread()，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误
    > ViewRootImpl#scheduleTraversals()，这里主要是入口
    > ViewRootImpl#scheduleTraversals()#mChoreographer.postCallback(mTraversalRunnable)，调用一个异步消息，用于执行mTraversalRunnable的run方法
    > ViewRootImpl#TraversalRunnable#run()，在TraversalRunnable类的run方法中调用了doTraversal方法
    > ViewRootImpl#doTraversal()，这里主要是看performTraversals方法
    > ViewRootImpl#performTraversals()，整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作
- 接下来看一下View的测量，位置，绘制三个流程
    > ViewRootImpl#performTraversals()#performMeasure，执行View组件的onMeasure方法，主要用于测量View
        > ViewRootImpl#performMeasure()，开始执行测量的入口
        > View#measure()，这个时候开始调用View类中的测量
    > ViewRootImpl#performTraversals()#performLayout，执行View组件的onLayout方法，主要用于布局View
        > ViewRootImpl#performLayout()，开始执行布局的入口
        > View#layout()，这个时候调用调用View类中的布局
    > ViewRootImpl#performTraversals()#performDraw，执行View组件的onDraw方法，主要用于绘制View
        > ViewRootImpl#performDraw()，开始执行绘制的入口



### 03.performMeasure测量
- 从ViewRootImpl类中分析performMeasure测量，这里是测量的入口
    > ViewRootImpl#performMeasure()，在performMeasure方法中我们又调用了mView的measure方法。这里的mView就是一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法
    > View#measure()，在View的measure方法中，又调用了onMeasure方法。由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法
    > FrameLayout#onMeasure()，这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法。
        - 这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法
    > View#onMeasure()，调用了setMeasuredDimension方法设置测量的结果
    > View#setMeasuredDimension()，在这个方法中调用了setMeasuredDimensionRaw方法，把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中





### 04.performLayout布局
- 从ViewRootImpl类中分析performLayout测量，这里是测量的入口
    > ViewRootImpl#performLayout()，具体看一下host.layout()，这个host就是一开始的Activity的mDector根组件
    > View#layout()，看源码执行了onLayout方法，host是一个FrameLayout，所以跟measure类似的，看一下FrameLayout的onLayout方法的实现
    > FrameLayout#onLayout()，调用了layoutChildren方法
    > FrameLayout#layoutChildren()，在这个方法中，遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法
    > View#layout()，经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中





### 05.performDraw绘制
- 从ViewRootImpl类中分析performDraw测量，这里是测量的入口
    > ViewRootImpl#performDraw()，看源码可知调用了draw(fullRedrawNeeded)
    > ViewRootImpl#draw()——>drawSoftware()，最终调用了mView的draw方法，这里的mView是我们的mDector，看一下draw方法的具体实现
    > FrameLayout#draw()，如果包含子View，那么也会执行子View的draw方法。
- ViewRootImpl.performTraversals()真正的绘制
    - 调用relayoutWindow()：
    - 创建用户java层的surface：只有用户提供的画面数据；
    - 创建native层的surface：包含用户提供的画面数据（java层的surface）+系统的画面数据（状态栏，电池、wifi等等）；
    - 创建完surface后：依次调用：performMeasure（对应view的onMeasure）、performLayout(onLayout)、performDraw(onDraw);
- 在performDraw()中：
    - 将view的数据传至native层的surface
    - surface中的canvas记录数据
    - 生成bitmap图像数据（此时数据是在surface中）
    - 将surface放入队列中；生产者消费者模式；
    - 通知surfaceflinfer进程去队列中取surface数据
    - surfaceflinfer拿到不同的surface,进行融合，生成bitmap数据
    - 将bitmap数据放入framebuffer中，进行展示



### 06.View绘制流程总结下
#### 6.1 Activity布局绘制总结
- 总结如下所示：
    - Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。
    - View的绘制流程包含了测量大小，测量位置，绘制三个流程；
    - Activity的界面绘制是从mDoctor即根View开始的，也就是从mDoctor的测量大小，测量位置，绘制三个流程；
    - View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的；
    - View的测量大小流程:performMeasure --> measure --> onMeasure等方法;
    - View的测量位置流程：performLayout --> layout --> onLayout等方法；
    - View的绘制流程：onDraw等方法；
    - View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑；
    - Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）；







