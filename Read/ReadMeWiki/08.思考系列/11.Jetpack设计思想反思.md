#### 目录介绍
- 01.Jetpack是什么工具
- 02.Navigation设计思想
- 03.DataBinding设计思想
- 04.Lifecycle设计思想
- 05.LiveData设计思想
- 06.Paging设计思想
- 07.ViewModel设计思想
- 08.WorkManager设计思想


### 01.Jetpack是什么工具
- Jetpack一套组件有哪些
    - Architecture帮助开发者设计稳健、可测试且易维护的应用。
    - DataBinding：将可观察数据绑定到界面元素。
    - Lifecycle：管理您的 Activity 和 Fragment 生命周期。
    - LiveData: 在底层数据库更改时通知视图，它具有生命周期。
    - Navigation:处理应用内导航。
    - Paging:可以帮助开发者一次加载和显示小块数据，按需加载部分数据可减少网络带宽和系统资源的使用。
    - Room:友好、流畅的访问SQLite数据库。它在SQLite的基础上提供了一个抽象层，允许更强大的数据库访问。
    - ViewModel: 以生命周期的方式管理界面相关的数据，通常和DataBinding配合使用，为开发者实现MVVM架构提供了强有力的支持。
    - WorkManager: 管理Android的后台的作业，即使应用程序退出或设备重新启动也可以运行可延迟的异步任务。



### 02.Navigation设计思想
#### 2.1 Navigation基础介绍
- `Navigation`是一个可简化`Android`导航的库和插件
    - 更确切的来说，`Navigation`是用来管理`Fragment`的切换，并且可以通过可视化的方式，看见App的交互流程。
- 最关键的三要素
    - Navigation Graph(New XML resource)	
        - 这是一个新的资源文件，用户在可视化界面可以看出他能够到达的Destination(用户能够到达的屏幕界面)，以及流程关系。
        - `NavHostFragment`作为`Activity`导航的容器，然后，其 **app:navGraph** 属性指向一个navigation_graph的xml文件，以声明其 **导航的结构**。
        - `action`标签是什么：声明导航的行为，比如id，通过id可以执行跳转到对应的页面；如果destination，声明行为导航的目的地
        - `argument`标签是什么：跳转参数的设置，name表示参数key，argType表示参数类型，defaultValue表示默认值
    - NavHostFragment(Layout XML view)	
        - 当前Fragment的容器，那么导航的fragment其实都是展示在这个容器上的。
    - NavController(Kotlin/Java object)	
        - 导航的控制者，主要是负责fragment的栈的管理。负责页面跳转



#### 2.2 Navigation如何设计
- 设计`NavHostFragment`。作为`Activity`导航界面的载体；管理并控制导航的行为。
    - NavHostFragment作为容器，主要是负责承载View，解析参数。根据设计原则单一职责，将 **管理并控制导航的行为** 交给另外一个类，这个类的作用应该仅是 **控制导航行为**。为 **NavController**。
    - NavHostFragment理应持有这个**NavController**的实例，并将导航行为 **委托** 给它，这里将 **NavController** 的持有者抽象为一个 **接口**，以便于以后的拓展。
    - 然后设置NavHost接口，为了保证导航的 **安全**，NavHostFragment 在其 **作用域** 内，理应 **有且仅有一个NavController 的实例**。
    - Navigation.findNavController(View)，参数中传递任意一个 view的引用似乎都可以获取 **NavController**——如何保证 **NavController 的局部单例**呢？
    - findNavController(View)内部实现是通过 **遍历** View树，直到找到最底部 **NavHostFragment** 中的**NavController**对象。
- 设计`NavController`。主要是作为路由跳转控制的管理者。
    * 1.对navigation资源文件夹下nav_graph.xml的 **解析**。持有了一个 **NavInflater** ，并通过 **NavInflater** 解析xml文件。
    * 2.通过解析xml，获取所有 **Destination**（目标点）的 **引用** 或者 **Class的引用**。通过反射的方式，实例化对应的 **Destination**，通过一个队列保存。
    * 3.记录当前栈中 **Fragment的顺序**。使用Deque队列保存信息。
    * 4.管理控制 **导航行为**，比如跳转下一个页面，关闭某页面等。
- 设计`NavDestination`和`Navigator`。主要是导航的跳转操作。
    - 对于不同的 **NavDestination** 来讲，它们之间的导航方式是不同的，这完全有可能（比如Activity 和 Fragment），如何根据不同的 **NavDestination** 进行不同的 **导航处理** 呢？
    - 这个时候可以抽取，Google的方式是通过抽象出一个类，这个类叫做 **Navigator**，主要是指定导航，后退导航，导航到某页面等操作。
    - **FragmentNavigator** 对应的是 **FragmentNavigator.Destination**，你可以把他理解为案例中的 **Fragment** 。



#### 2.3 Navigation原理流程
- `NavHostFragment`导航容器核心原理分析
    - 1.NavHostFragment#onCreateView()，这个里面创建了一个FragmentContainerView布局并且设置id
        - NavHostFragment内部实例化了一个FrameLayout, **作为ViewGroup的载体，导航并展示其它Fragment**。
    - 2.NavHostFragment#onCreate()，创建导航控制者对象，并且通用bundle获取核心参数
        - 创建`NavHostController`导航空指针，并且和lifecycle绑定；
        - 通过bundle获取一些核心参数，比如：graphId(Graph文件id属性)，defaultHost(容器是否与系统的返回按钮相关联)，startDestinationArgs等等
        - 将获取的`graphId`设置到`NavHostController`控制器中，这个相当于设置跳转的核心地图。
    - 3.NavHostFragment#onViewCreated()，给view设置tag标签并且绑定`NavHostController`控制器
        - 如果`view`的父布局不为空，则拿到父布局的id和当前`fragment`的id是否相同，如果相同则设置给父布局标签和控制器。
        - 注意Navigation.setViewNavController(view, mNavController)，这个是将view(这个View是NavHostFragment的根布局)和NavController绑定起来，通用tag标签。
- `nav_graph`导航结构图如何解析
    - 1.NavHostFragment#onInflate()，主要是解析自定义属性。
        - 这个里面获取了给`NavHostFragment`容器设置的`defaultNavHost`属性，还有获取`navGraph`属性(对应是graph文件的id)
    - 2.如何导航到graph文件中的第一个页面，即跳转到`startDestination`节点
        - 
    - 3.
- `NavController`实现路由跳转流程
    ``` java
    //xxx，可以是指向目标页面id，也可以是directions，还可以是deepLink
    Navigation.findNavController(view).navigate(xxx)
    ```



#### 2.4 遇到问题的说明
- 第一个问题：Navigation为何重建fragment？
- 第二个问题：



### 03.DataBinding设计思想
#### 3.1 DataBinding基础介绍


#### 3.2 DataBinding如何设计



#### 3.3 DataBinding原理流程

#### 3.4 遇到问题的说明



### 04.Lifecycle设计思想
#### 4.1 Lifecycle基础介绍

#### 4.2 Lifecycle如何设计



#### 4.3 Lifecycle原理流程


#### 4.4 遇到问题的说明



### 05.LiveData设计思想
#### 5.1 LiveData基础介绍

#### 5.2 LiveData如何设计


#### 5.3 LiveData原理流程



### 06.Paging设计思想
#### 6.1 Paging基础介绍


#### 6.2 Paging如何设计


#### 6.3 Paging原理流程




### 07.ViewModel设计思想
#### 7.1 ViewModel基础介绍
- ViewModel简单介绍
    - ViewModel同样具有生命周期意识的处理跟UI相关的数据，并且，当设备的一些配置信息改变（例如屏幕旋转）它的数据不会消失。
    - ViewModel的另一个特点就是同一个Activity的Fragment之间可以使用ViewModel实现共享数据。
- ViewModel设计的思想
    - Model-View-ViewModel，并非是一个新鲜的词汇，它的定义最早起源于前端，代表着 数据驱动视图 的思想。类似Vue布局和数据绑定的关系。
- ViewModel前世痛点
    - 看之前老的MVP或者MVVM项目的时候，ViewModel一般是开发者定义处理数据相关的接口。比如：TaskViewModel
    - 不同的MVVM也有截然不同的实现方式，难以严格统一的 开发流派 导致代码质量的参差不齐，代码的可读性更是天差地别。



#### 7.2 ViewModel如何设计
- 


#### 7.3 ViewModel原理流程


#### 7.4 遇到问题的说明




### 08.WorkManager设计思想
#### 8.1 WorkManager基础介绍



#### 8.2 WorkManager如何设计


#### 8.3 WorkManager原理流程









