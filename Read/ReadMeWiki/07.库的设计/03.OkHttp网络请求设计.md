#### 目录介绍
- 01.整体概述介绍
    - 1.1 项目背景
    - 1.2 遇到问题
    - 1.3 设计目标
    - 1.4 产生收益
- 02.开发设计思路
    - 2.1 整体设计思路
    - 2.2 创建请求Client
    - 2.3 封装Request
    - 2.4 设计Call请求
    - 2.5 同步和异步设计
    - 2.6 拦截器的设计
    - 2.7 缓存拦截的设计
    - 2.8 连接请求设计
    - 2.9 返回response
- 03.OkHttp原理思考
    - 3.2 创建Client操作
    - 3.3 request实践
    - 3.4 Call请求流程
    - 3.5 同步和异步原理
    - 3.6 拦截器实践
    - 3.7 缓存拦截实现
    - 3.8 连接请求实现
    - 3.9 response处理
- 04.一些技术点思考
    - 4.5 
- 05.方案基础设计
    - 5.1 整体架构图
    - 5.2 UML设计图
    - 5.3 关键流程图
    - 5.4 接口设计图
    - 5.5 模块间依赖关系
- 06.其他设计说明
    - 6.1 性能设计
    - 6.2 稳定性设计
    - 6.3 灰度设计
    - 6.4 降级设计
    - 6.5 异常设计




### 01.整体概述介绍
#### 1.1 项目背景



#### 1.2 基础概念


#### 1.3 简单使用
- 最简单的同步和异步调用
    ```
    Response response = okHttpClient.newCall(request).execute();
    okHttpClient.newCall(request).enqueue(callback);
    ```


#### 1.4 产生收益




### 02.开发设计思路
#### 2.1 整体设计思路
- 首先放一张完整流程图（看不懂没关系，慢慢往后看）：
    - ![image](https://blog.piasy.com/img/201607/okhttp_full_process.png)
- 网络请求到响应大概流程图如下所示
    - ![image](https://img-blog.csdnimg.cn/2020032017390425.png)
- 整体设计思路大概如下所示
    - 第一步：创建OkHttpClient对象，由于创建这个对象十分复杂，因此采用builder设计模式构造
    - 第二步：包装Request请求体对象，主要是存放url，header，get请求，post请求等等属性
    - 第三步：通过newCall(request)去创建一个call请求
    - 第四步：开始执行同步execute或者enqueue请求，这里会使用到线程池
    - 第五步：添加各种拦截器，缓存拦截器，
    - 第六步：处理缓存拦截，数据复用的技术逻辑
    - 第七步：创建连接请求的操作，给服务端发送请求
    - 第八步：获取返回response数据



#### 2.2 创建请求Client
- 为何要创建Client
    - 创建OkHttpClient对象，主要是用于Api网络请求的对象。类似于初始化网络请求，可以设置超时时间，日志打印拦截器，代理，ssl校验，域名校验等等。


#### 2.3 封装Request
- Request抽象成请求数据
    - Request包括Headers和RequestBody，而RequestBody是abstract的，他的子类是有FormBody(表单提交的)和MultipartBody(文件上传)，分别对应了两种不同的MIME类型。
    ```
    FormBody ："application/x-www-form-urlencoded"
    MultipartBody："multipart/"+xxx.
    ```


#### 2.4 设计Call请求
- 如何设计Call请求
    - 基于接口开发，设计了Call接口，里面主要做同步请求execute，异步请求enqueue，取消请求cancel等等。
- Call类详解
    - 有道词典翻译该类注释：调用是准备执行的请求。call可以取消。由于此对象表示单个请求/响应对(流)，因此不能执行两次。
- 主要是HTTP请求任务封装
    - 可以说我们能用到的操纵基本上都定义在这个接口里面了，可以通过Call对象来操作请求，同步请求execute，异步请求enqueue。
    - 而Call接口内部提供了Factory工厂方法模式(将对象的创建延迟到工厂类的子类去进行，从而实现动态配置)。



#### 2.5 同步和异步设计
- 同步和异步设计Api设计
    ```
    okHttpClient.newCall(request).execute();
    okHttpClient.newCall(request).enqueue(callback);
    ```
- 如何将一个在子线程中做耗时操作的任务变成同步？
    - 
- 如何设计异步操作？
    - 


#### 2.6 拦截器的设计


#### 2.7 缓存拦截的设计


#### 2.8 连接请求设计


#### 2.9 返回response
- Response抽象成响应数据
    - Response包括Headers和RequestBody，而ResponseBody是abstract的，所以他的子类也是有两个:RealResponseBody和CacheResponseBody,分别代表真实响应和缓存响应。




### 03.OkHttp原理思考
#### 3.2 创建Client操作
- OKHttpClient
    - 1、里面包含了很多对象，其实OKHttp的很多功能模块都包装进这个类，让这个类单独提供对外的API，这种外观模式的设计十分的优雅。外观模式。
    - 2、而内部模块比较多，就使用了Builder模式(建造器模式)。Builder模式(建造器模式)
    - 3、它的方法只有一个：newCall.返回一个Call对象(一个准备好了的可以执行和取消的请求)。


#### 3.3 request实践
- 主要是封装一个Request请求体
    ``` java
    Request request = new Request.Builder()
            .url(url)
            .addHeader("cookie","yangchong")
            .get()
            .build();
    ```



#### 3.4 Call请求流程
- 相当于调用newCall去创建一个call请求，这里分为同步和异步操作
    ```
    okHttpClient.newCall(request).execute();
    okHttpClient.newCall(request).enqueue(callback);
    ```
- RealCall类构造创建对象，它是Call接口的具体实现类。
    - 在源码中，OKHttpClient实现了Call.Factory接口，返回了一个RealCall对象。那我们就来看下RealCall这个类。
    - 1、OkHttpClient的newCall方法里面new了RealCall的对象，但是RealCall的构造函数需要传入一个OKHttpClient对象和Request对象(PS：第三个参数false表示不是webSokcet)。因此RealCall包装了Request对象。所以RealCall可以很方便地使用这两个对象。
    - 2、RealCall里面的两个关键方法是：execute 和 enqueue。分别用于同步和异步得执行网络请求。
    - 3、RealCall还有一个重要方法是:getResponseWithInterceptorChain，添加拦截器，通过拦截器可以将一个流式工作分解为可配置的分段流程，既增加了灵活性也实现了解耦，关键还可以自有配置，非常完美。



#### 3.5 同步和异步原理
- execute同步调用流程
    > RealCall#execute()，这个主要是执行同步操作的核心方法。首先是判断call是否执行过，可以看出每个Call对象只能使用一次原则。
    > Dispatcher#executed()，将任务添加到Deque队列中
    > RealCall#getResponseWithInterceptorChain()，这个是添加各种拦截器，然后创建RealInterceptorChain对象执行请求操作
    > RealInterceptorChain#proceed，在这个里面获取拦截器，
    > interceptor#intercept()，最后通过拦截器请求操作，获取response响应数据
- enqueue异步调用流程
    > 


#### 3.6 拦截器实践


#### 3.7 缓存拦截实现


#### 3.8 连接请求实现


#### 3.9 response处理








