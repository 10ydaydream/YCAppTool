#### 目录介绍
- 01.具体满足那些场景
- 02.核心类说明分析
- 03.相关使用说明介绍
- 04.封装库的架构思想
- 05.js通信分析流程
- 06.h5中如何下载文件
- 07.白名单如何处理


### 01.具体满足那些场景
- 两个库说明
    ```
    //版本集成时，需要依赖hybrid库
    implementation 'com.didi.soda:nova-web-android-app::version'
    //hybrid基础库
    implementation 'com.xiaoju.nova:the-one-hybrid:version'
    ```


### 02.核心类说明分析
#### 2.1 关于配送端项目重要类
- WebInitializer
    - 初始化配置相关的操作
- RiderWebPage
    - web页面的基类，继承了WebPage类。
- RiderGlobalJsBridge
    - 继承GlobalJsBridge类，看RiderGlobalJsBridge主要是处理一些公共参数，在初始化时倒入
- RiderLocalJsBridge
    - 继承BaseHybridModule，主要是做本地js交互相关的操作。完全起到隔离的作用
- WebViewUpgrade
    - 检测WebView版本是否更新
- RiderBizAgent
    - 主要是配置信息相关的操作，比如拼接参数，获取语言locale，初始化时必须设置，如果无扩展功能不用设置如果有需继承 BizAgent。



#### 2.2 关于soda库重要类
- WebPage
    - 基于Page封装WebView能力，同时具备平台的通用功能，可以直接使用，也可以继承它。
- SodaWebView
    - 如果WebPage的子类没有创建webView，那么就默认使用SodaWebView，就是封装了一层。
- SodaWebChromeClient
    - 针对WebChromeClient的封装，主要处理打开file文件的操作和监听，还是js交互，继承FusionWebChromeClient
- SodaWebViewClient
    - 针对WebViewClient的封装，主要处理webPage的状态和异常监听处理。继承FusionWebViewClient
- WebConfig
    - web库的配置类，主要是配置url，标题，是否切换标题，支持缓存，预加载等属性


#### 2.3 关于hybrid基础库
- WebViewJavascriptBridge
    - 负责js交互通信的类
- FusionWebView
    - 针对webView进行的封装
- FusionWebViewClient
    - 主要在shouldOverrideUrlLoading处理交互逻辑
- FusionWebChromeClient
    - 处理加载进度，onJsPrompt的交互逻辑


### 03.相关使用说明介绍
#### 3.1 初始化相关
- 初始化代码如下所示：
    ```
    WebInitializer.start(app)
        .exportGlobalJsBridge(RiderGlobalJsBridge.class)
        .exportJsBridge(RiderLocalJsBridge.RIDER_LOCAL_JS_BRIDGE_KEY, RiderLocalJsBridge.class)
        .exportJsBridge("WSGHybridModule", WSGHybridModule.class)
        .setProgressBarColor(app.getResources().getColor(R.color.theme_rider_base_brand_color))
        .setBusinessAgent(new RiderBizAgent(app))
        .setLogUtil(new LogUtil.LogInterface() {
            @Override
            public void info(String s) {
                sLogger.info(s);
            }
    
            @Override
            public void erro(String s) {
                sLogger.error(s);
            }
    
            @Override
            public void debug(String s) {
                sLogger.debug(s);
                if (!TextUtils.isEmpty(s) && s.contains("PhotoTransferPage")) {
                    PhotoTransferTraceUtil.trackPhotoTransferPageUploadFail(s);
                }
            }
        })
        .execute();
    ```


#### 3.2 自定义page继承WebPage
- WebPage：继承Page正常当一个page使用里面实现了所有公共功能，使用端如需扩展可以直接继承WebPage 进行扩展即可。代码如下所示：
    ```
    public class XxxWebPage extends WebPage {
          @Override
          public void onCreate(@NonNull View view) {
                super.onCreate(view);
          }
        
         /**
         * 能否远程调试webview
         * @return
          */
         @Override
         protected boolean remoteDebuggingEnable() {
              return false;
         }  
    }
    ```


#### 3.3 自定义配置RiderBizAgent
- 主要是配置信息相关的操作，比如拼接参数，获取语言locale，初始化时必须设置，如果无扩展功能不用设置如果有需继承 BizAgent。
    ```
    public class CustonBizAgent extends BizAgent {
    
        public CustonBizAgent(Context context) {
            super(context);
        }
    
        /**
         * 不同端的唯一标识 例如，D端是：Soda.Rider
         * @return
         */
        @Override
        public String getAppUserAgent() {
            return null;
        }
    
        /**
         * 允许WebView开启混合模式
         * @return
         */
        @Override
        protected List<String> getAllowMixContentList() {
            return super.getAllowMixContentList();
        }
    
        /**
         * 获取语言
         * @return
         */
        @Override
        protected String getLocale() {
            return null;
        }
    
        /**
         * 获取Map类型
         * @return
         */
        @Override
        protected String getMapType() {
            return null;
        }
    
        @Override
        protected String getDiDiSUUID() {
            return null;
        }
    
        @Override
        protected String getChannelId() {
            return null;
        }
    
        /**
         * 获取当前定位的纬度
         * @return
         */
        @Override
        protected double getLatitude() {
            return 0;
        }
    
        /**
         * 获取当前定位的经度
         * @return
         */
        @Override
        protected double getLongitude() {
            return 0;
        }
    
        /**
         * 白名单 从apollo 中配置 白名单内的才能调用bridge
         * @return
         */
        @Override
        protected List<String> getBridgeWhiteList() {
            return super.getBridgeWhiteList();
        }
    
        /**
         * 白名单 从apollo 中配置 白名单内的才能在访问url后面添加公参
         * @return
         */
        @Override
        public List<String> getAppendParameterList() {
            return super.getAppendParameterList();
        }
    }
    ```


### 04.封装库的架构思想
- 整体架构思想
    - 上层是：webPage的具体使用，比如钱包，支付，分享等
    - 接口层是：GlobalJsBridge，RiderLocalJsBridge
    - JSBridge通信：BaseHybridModule，WebViewJavascriptBridge，FusionWebViewClient
- js交互
    - 在FusionWebViewClient的shouldOverrideUrlLoading拦截，如果：fusion://invokeNative，则js调用na方法。具体通过反射，也能接耦合。


### 05.js通信分析流程
- 先来看一下js通信案例，具体看RiderLocalJsBridge，采用注解的形式h5调用na原生方法
    ```
    /**
     * 完成钱包跳转至订单详情页功能
     *
     * @param jsonObject jsonObject
     */
    @JsInterface("walletJumpDeliveryDetails")
    public void walletJumpDeliveryDetails(JSONObject jsonObject, CallbackFunction function) {
    
    }
    ```
- js调用na有那些方式
    - JavascriptInterface
    - WebViewClient.shouldOverrideUrlLoading()
    - WebChromeClient.onJsPrompt()
- 目前项目中采用第二种
    - 在shouldOverrideUrlLoading拦截处理，如果url是以fusion://invokeNative开头，则js调用na方法，把具体操作交给mWebJavascriptBridge处理
    ```
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        if (url.startsWith("fusion://")) {
            if (url.startsWith("fusion://invokeNative")) {
                this.mWebJavascriptBridge.handleInvokeFromJs(url);
                return true;
            }
            if (url.startsWith("fusion://callbackNative")) {
                this.mWebJavascriptBridge.handleResponseFromJS(url);
                return true;
            }
        }
    }
    ```
- 这种方式存在一个问题
    - 没有漏洞问题，但是它也有一个很繁琐的地方是，如果 web 端想要得到方法的返回值，只能通过 WebView 的 loadUrl 方法去执行 JS 方法把返回值传递回去。


### 06.h5中如何下载文件
- 在SodaWebView中，添加下载监听操作。跳转外部浏览器进行下载
    ```
    this.setDownloadListener(new DownloadListener() {
        public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) {
            Intent intent = new Intent("android.intent.action.VIEW");
            intent.addCategory("android.intent.category.BROWSABLE");
            intent.setData(Uri.parse(url));
            if (intent.resolveActivity(context.getPackageManager()) != null) {
                context.startActivity(intent);
            } else {
                ToastUtils.show(SodaWebView.this.getContext(), "can not find browser");
            }
    
        }
    });
    ```


### 07.白名单如何处理




