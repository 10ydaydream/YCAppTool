#### 目录介绍
- 01.LiveData介绍
    - 1.1 是什么东西
    - 1.2 有何优点
- 02.LiveData实战必备
    - 2.1 学习方式
    - 2.2 实战必备
- 03.简单实践操作
    - 3.1 看一个简单案例
    - 3.2 LiveData配合ViewModel
- 04.LiveData架构梳理
    - 4.1 LiveData架构图
    - 4.2 LiveData源码UML
    - 4.3 什么是观察者模式
    - 4.4 如何避免内存泄漏
- 05.LiveData原理
- 06.LiveData思考分析




### 01.LiveData介绍
#### 1.1 是什么东西
- LiveData是一个可观察数据持有者类。与常规的可观察对象不同，LiveData是生命周期感知的，这意味着它尊重其他应用组件的生命周期，如活动、片段或服务。


#### 1.2 有何优点
- 数据变更的时候更新UI
- 没有内存泄漏
- 不会因为停止Activity崩溃
- 无需手动处理生命周期
- 共享资源



### 02.LiveData实战必备
#### 2.1 学习方式
- 最好的学习方式仍然是通过官方文档，下面是官方的学习地址：
    - 谷歌官方文档：[LiveData]()


#### 2.2 实战必备
- observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer)	
    - 最常用的方法，需要提供Observer处理数据变更后的处理。LifecycleOwner则是我们能够正确处理声明周期的关键！
- setValue(T value)	
    - 设置数据
- getValue():
    - T	获取数据
- postValue(T value)	
    - 在主线程中更新数据


### 03.简单实践操作
#### 3.1 单独使用LiveData
- 举一个最简单的案例代码：
    ```
    liveData = new MutableLiveData<>();
    liveData.observe(this, new Observer<String>() {
        @Override
        public void onChanged(@Nullable final String newText) {
            // 更新数据
            tv3.setText(newText);
        }
    });
    liveData.setValue("小杨真的是一个逗比么");
    ```
- 那么上面这一段代码大概是什么意思呢？
    - 首先创建一个 MutableLiveData（LiveData是抽象类）对象 ，通过 observe 方法可以订阅修改数据的通知
    - 通过 postValue()或者 setValue() 方法发送事件更新数据
    - 已经订阅的 Observer 能够得到数据更改的通知，就会回调 onChanged() 方法。



#### 3.2 LiveData配合ViewModel
- LiveData是一个数据的包装。具体的包装对象可以是任何数据，包括集合。
    - 它是一个抽象类，首先先创建一个类实现LiveData。代码如下所示：
    ``` kotlin
    class TextViewModel : ViewModel() {
  
        private var mCurrentText: MutableLiveData<String>? = null
        private val mNextText: MutableLiveData<String> by lazy {
            MutableLiveData()
        }
    
        fun getCurrentText(): MutableLiveData<String>{
            if (mCurrentText == null) {
                mCurrentText = MutableLiveData()
            }
            return mCurrentText as MutableLiveData<String>
        }
    
        fun getNextText() : MutableLiveData<String> = mNextText
    
    }
    ```
- 创建一个观察的对象，观察LiveData中的数据。目前在组件的onCreate()方法中开始观察数据，代码如下所示：
    - 思考下，可以在onResume()中调用么，个人觉得不太好。因为系统会多次调用onResume()方法。
    ```
    private void initLiveData() {
        // 创建一个持有某种数据类型的LiveData (通常是在ViewModel中)
        model = ViewModelProviders.of(this).get(TextViewModel.class);
        // 创建一个定义了onChange()方法的观察者
        // 开始订阅
        final Observer<String> nameObserver = new Observer<String>() {
            @Override
            public void onChanged(@Nullable final String newText) {
                // 更新数据
                tvText.setText(newText);
            }
        };
        // 通过 observe()方法连接观察者和LiveData，注意：observe()方法需要携带一个LifecycleOwner类
        model.getCurrentText().observe(this, nameObserver);
    }
    ```
- 然后去创建更新对象数据内容的对象。如何去更新那个文本中的数据呢？代码如下所示：
    - 想要在UI Controller中改变LiveData中的值呢？（比如点击某个Button设置文本内容的更改）。
    - LiveData并没有提供这样的功能，但是Architecture Component提供了MutableLiveData这样一个类，可以通过setValue(T)和postValue(T)方法来修改存储在LiveData中的数据。MutableLiveData是LiveData的一个子类，从名称上也能看出这个类的作用。
    - 调用setValue()方法就可以把LiveData中的值改为 "小杨真的是一个逗比么" 。同样，通过这种方法修改LiveData中的值同样会触发所有对这个数据感兴趣的类。那么setValue()和postValue()有什么不同呢？区别就是setValue()只能在主线程中调用，而postValue()可以在子线程中调用。
    ```
    findViewById(R.id.tv_click).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            count++;
            String text;
            switch (count%5){
                case 1:
                    text = "小杨真的是一个逗比么";
                    break;
                case 2:
                    text = "逗比赶紧来star吧";
                    break;
                case 3:
                    text = "小杨想成为大神";
                    break;
                case 4:
                    text = "开始刷新数据啦";
                    break;
                default:
                    text = "变化成默认的数据";
                    break;
            }
            model.getCurrentText().setValue(text);
        }
    });
    ```



#### 4.3 什么是观察者模式
- `LiveData`实际上就像一个 **容器**, 本文中它存储了一个`T`类型的引用，每当这个容器内 `T`的数据发生变化，我们都能在回调函数中进行对应的处理。
- 这似乎和我们日常用到的 `Button` 控件的 `setOnClickListener()` 非常相似，实际上点击事件的监听也正是 **观察者模式** 的一种体现。
- 对于观察者来说，它并不关心观察对象 **数据是如何过来的**，而只关心数据过来后 **进行怎样的处理**。这也就是说，**事件发射的上游** 和 **接收事件的下游** 互不干涉，大幅降低了互相持有的依赖关系所带来的强耦合性。


#### 4.4 如何避免内存泄漏
- `LiveData`，当它被我们的`Activity`订阅观察，这之后`Activity`如果`finish()`掉，`LiveData`本身会自动“清理”以避免内存泄漏。
    - 这是一个非常好用的特性，它的实现原理非常简单，其本质就是利用了Jetpack 架构组件中的另外一个成员—— **Lifecycle**。



### 06.LiveData思考分析
`LiveData`本身非常简单，毕竟它本身的源码一共也就500行左右，也许你要说 **准备面试粗读一遍源码就够了**，很遗憾，即使是粗读了源码，也很难说能够完全招架更深入的提问...

让我们来看一道题目：在下述Activity完整的生命周期中，`Activity`一共观察到了几次数据的变更——即 **一共打印了几条Log** ？（补充纠正，onStop()方法中值应该为 "onStop"）

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/livedata/image.zckzjh1y2v.png)

公布答案：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/livedata/image.7hm7m3id17t.png)

意外的是，`livedata.observer()`的本次观察并没有观察到 **onCreate**、**onStop** 和 **onDestroy** 的数据变更。

#### 为什么会这样？

还记得上文提到过2次的 **LiveData的活跃状态(Active)** 相关代码吗？实际上，`LiveData`内部存储的每一个`LifecycleBoundObserver`本身都有`shouldBeActive`的状态：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/livedata/image.tv8ns7jh81r.png)

现在我们明白了，原来并不是只要在`onDestroy()`之前为`LiveData`进行更新操作，`LiveData`的观察者就能响应到对应的事件的。

虽然我们明白了这一点，但是如果更深入的思考，你会又多一个问题，那就是：

* 既然`LiveData`已经能够实现在`onDestroy()`的生命周期时自动解除订阅，为什么还要多此一举设置一个`Active`的状态呢？

仔细想想，其实也不难得到答案，`Activity`并非只有`onDestroy()`一种状态的，更多时候，新的`Activity`运行在栈顶，旧的`Activity`就会运行在 `background`——这时旧的`Activity`会执行对应的`onPause()`和`onStop()`方法，我们当然不会关心运行在后台的`Activity`所观察的`LiveData`对象（即使数据更新了，我们也无从进行对应UI的更新操作），因此`LiveData`进入 **InActive(待定、非活跃)**状态，`return`并且不去执行对应的回调方法，是 **非常缜密的优秀设计** 。

当然，有同学提出，我如果希望这种情况下，`Activity`在后台依然能够响应数据的变更，可不可以呢？当然可以，`LiveData`此外还提供了`observerForever()`方法，在这种情况下，它能够响应到任何生命周期中数据的变更事件：

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/livedata/image.i8ed4czamxi.png)

除此之外，源码中处处都是优秀的细节，比如对于`observe()`方法和`observerForever()`方法对应生成的包装类，后者方法生成的是`AlwaysActiveObserver`对象，统一抽象为`ObserverWrapper`。

![](https://raw.githubusercontent.com/qingmei2/qingmei2-blogs-art/master/android/jetpack/livedata/image.2lksnjk02ma.png)

这种即使只有2种不同场景，也通过代码的设计，将公共业务进行向上抽离为抽象类的严谨，也非常值得我们学习。

