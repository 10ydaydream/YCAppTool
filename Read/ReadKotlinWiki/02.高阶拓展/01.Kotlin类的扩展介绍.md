#### 目录介绍
- 02.使用companion object
- 03.object对象声明单例






### 02.使用companion object
- 当你的类包含太多的东西，你想把它们隔离到另外一个类，又不想使用类引用的方式，你就可以使用companion object。
    - `companion object`的好处是，外部类可以直接访问对象，不需要通过对象指针。
- 在类声明内部可以用`companion`关键字标记对象声明：
    - 我们需要一个类里面有一些静态的属性、常量或者函数，我们可以使用伴随对象。这个对象被这个类的所有对象所共享，就像java中的静态属性或者方法。
    - 注意，一个类中只能定义一个`companion object`，不然会报错
    ```
    class AndroidUtils{
        companion object {
            const val name = "yc"
            fun getVersionCode(mContext: Context): Int {
                var versionCode = 0
                try {
                    versionCode = mContext.packageManager.getPackageInfo(mContext.packageName, 0).versionCode
                } catch (e: PackageManager.NameNotFoundException) {
                    e.printStackTrace()
                }
                return versionCode
            }
        }
    }
    ```
- 外部调用伴生函数，属性等
    ```
    //伴随对象的成员可以通过类名做限定词直接使用：
    val name = AndroidUtils.name
    val versionCode = AndroidUtils.getVersionCode(activity)
    ```
    


### 03.object对象声明单例
- 在Java中，单例的声明可能具有多种方式：
    - 如懒汉式、饿汉式、静态内部类、枚举等；
- 在Kotlin中，单例模式的实现只需要一个 object 关键字即可；
    - object 关键字声明,其内部不允许声明构造方法，其中init代码块对应java中static代码块
    ```
    object SingleObject {
        init {
            //对应java中static代码块
            LogUtils.e("SingleObject"+"init")
        }
        fun test() {
            //...
        }
    }
    // 调用方式：类名.方法名()
    class Main {
        fun test() {
            SingleObject.test() //在class文件中，会自动编译成SingleObject.INSTANCE.test();调用方式
        }
    }
    
    // ----------------源码和字节码分界线 ---------------
    //Kotlin文件编译后的class代码如下：
    public final class SingleObject {
       public static final SingleObject INSTANCE;
    
       public final void test() {
       }
    
       private SingleObject() {
          INSTANCE = (SingleObject)this;
       }
    
       static {
          new SingleObject();
       }
    }
    ```















