#### 目录介绍
- 01.常量和变量
    - 1.1 变量
    - 1.2 常量
    - 1.3 与Java区别
    - 1.4 Any 和 Any?
- 02.函数[相当于java方法]
    - 2.1 无返回值的函数
    - 2.2 有返回值的函数
- 04.空安全
    - 4.1 关于空安全
    - 4.2 ?.和!!.和?=各自的含义
    - 4.3 ?:的含义
- 05.条件循环和区间
    - 01.If表达式
    - 02.When表达式
    - 03.for循环
    - 04.While 和 do/while 循环
    - 05.Ranges
- 06.运算符重载
    - 6.1 一元操作符
    - 6.2 二元操作符
    - 6.3 数组操作符
    - 6.4 等于操作符




### 01 常量和变量
#### 1.1 变量
- 在 kotlin 中一切皆为对象，没有像 Java 中的原始基本类型。在 kotlin 中使用 var 修饰的为变量。例如我们定义一个 Int 类型的变量并赋值为1：
- 由于 kotlin 编译器可以自动推断出变量的类型，所以我们通常不需要指定变量的类型：
    ```
    private var index: Int = 0          //定义具体的类型
    private var a = 0                   //自动识别是int类型，通常不需要指定变量的类型
    private var point: Point? = null    //定义对象
    
    
    //可以发现，kotlin从编译时预防了空指针的可能性，VeryGood的特性，能够避免很多人为导致的空指针错误
    //使用的时候，因为point是可空的，所以有两种用法
    println(point?.x) //如果你不能确保point是否为空
    println(point!!.x) //如果你能确保point一定不为空，否则point为空，这里会报运行时空指针
    ```


##### 1.2 常量
- 在 kotlin 中使用 val 修饰的为常量。这和 java 中的 final 很相似。在 kotlin 中有一个重要的概念是：尽可能地使用 val。
    ```
    val s = "String"    //类型为String
    val ll = 22L        //类型为Long
    val d = 2.5         //类型为Double
    val f = 5.5F        //类型为Float
    val point = Point(20, 20)       //类型为Point对象
    ```
    - 注意这种情况下point一定不会为空，因为val定义的变量必须要初始化，从这个角度来看，又避免了人为导致的空指针错误。
    - 比如这样操作会产生编译时错误：point = Point(30, 30)
    - 需要注意的是，point不能被修改，但是Point类里面的成员变量是可修改的，所以下面操作是允许的
        ```
        point.x = 30
        point.y = 30
        ```


#### 1.3 与Java区别
- 对于基本类型，Kotlin 相比 Java 有几点特殊的地方
    - 数字、字符和布尔值可以在运行时表示为原生类型值，但对开发者来说，它们看起来就像普通的类
    - Kotlin 对于数字没有隐式拓宽转换，而在 Java 中 int 可以隐式转换为 long
    - 在 Kotlin 中字符不能视为数字
    - Kotlin 不支持八进制
    ```kotlin
    //在 Kotlin 中，int、long、float等类型仍然存在，但是是作为对象存在的
    
    val intIndex: Int = 100
    //等价于 
    //val intIndex = 100，编译器会自动进行类型推导
    
    //数字类型不会自动转型，必须要进行明确的类型转换
    val doubleIndex: Double = intIndex.toDouble()
    //以下代码会提示错误，需要进行明确的类型转换
    //val doubleIndex: Double = intIndex
    
    //Char 不能直接作为数字来处理，需要主动转换
    val ch: Char = 'c'
    val charValue: Int = ch.toInt()
    //以下代码会提示错误
    //val charValue: Int = ch
    
    //二进制
    val value1 = 0b00101
    //十六进制
    val value2 = 0x123
    ```
- 此外，Kotlin 的可空类型不能用 Java 的基本数据类型表示，因为 null 只能被存储在 Java 的引用类型的变量中，这意味着只要使用了基本数据类型的可空版本，它就会被编译成对应的包装类型



#### 1.4 Any 和 Any?
- Any 类型是 Kotlin 所有非空类型的超类型，包括像 Int 这样的基本数据类型
    - 如果把基本数据类型的值赋给 Any 类型的变量，则会自动装箱
    ```kotlin
    val any: Any = 100
    println(any.javaClass) //class java.lang.Integer
    ```
    - 如果想要使变量可以存储包括 null 在内的所有可能的值，则需要使用 Any?
    ```kotlin
    val any: Any? = null
    ```



### 02 函数[相当于java方法]
#### 2.1 无返回值的函数
- 没有返回值的函数
    - Kotlin 中的 Unit 类型类似于 Java 中的 void，可以用于函数没有返回值时的情况
    ```
    Unit 表示无返回值，对应 java 中 void：
    fun yc(a: Int, b: Int): Unit {
        println("sum of $a and $b is ${a + b}")
    }
    
    Unit 的返回类型可以省略：
    fun yc(a: Int, b: Int) {
        println("sum of $a and $b is ${a + b}")
    }
    ```


##### 2.2 有返回值的函数
- 有返回值
    ```
    override fun getContentView(): Int {
        return R.layout.activity_wan_android
    }
    ```


#### 03 构造方法
- 实例化代码不需要new



### 04 空安全
#### 4.1 关于空安全
- 在 kotlin 中，默认定义的变量不能为 null 的，这可以避免很多的 NullPointerException。
    ```
    var b: String? = "abc"
    b = null
    指定一个变量可null是通过在类型的最后增加一个问号：
    
    var b: String? = "abc"
    val l = b.length //编译错误
    当变量声明为可空时，在调用它的属性时无法通过编译
    
    var b: String? = "abc"
    val l = b?.length 
    可以使用安全操作符 ?.
    ```

#### 4.2 ?.和!!.和?=各自的含义
- ?=    使用 ?= 操作符，当前面的值不为空取前面的值，否则取后面的值，这和java中三目运算符类似
- !!.   使用 !!. 操作符可以跳过限制检查通过编译，此时如果变量为空会抛出空指针异常。
- ?.    使用 ?. 操作符，就先判空，如果不为空则赋值
    ```
    //?.
    //kotlin:
    a?.foo()
    //相当于java:
    if(a!=null){
     a.foo();
    }
    
    //!!.
    //kotlin:
    a!!.foo()
    //相当于java: 
    if(a!=null){
     a.foo();
    }else{
     throw new KotlinNullPointException();
    }
    ```

#### 4.3 ?:的含义
- ?: 的意思是，左边的表达式没有成功，则使用右边的结果；如下，bannerBean是null,所以bannerBean?.title不会执行，所以最终a == "null"
    ```
    var bannerBean : BannerBean? = null
    var a = bannerBean?.title ?: "null"
    ```


### 05.条件循环和区间


#### 5.1 If 表达式
- if 的分支可以是代码块，最后的表达式作为该块的值
    ```kotlin
    val maxValue = if (20 > 10) {
        println("maxValue is 20")
        20
    } else {
        println("maxValue is 10")
        10
    }
    println(maxValue) //20
    ```
- 以下代码可以显示地看出 if 的返回值
    ```kotlin
    val list = listOf(1, 4, 10, 4, 10, 30)
    val value = if (list.size > 0) list.size else null
    println(value)  //6
    ```
- 如果 if 表达式分支是用于执行某个命令，那么此时的返回值类型就是 Unit ，此时的 if 语句就看起来和 Java 的一样了
    ```kotlin
    val value1 = if (list.size > 0) println("1") else println("2")
    println(value1.javaClass)   //class kotlin.Unit
    ```
- 如果将 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支



#### 5.2 When表达式
- when 表达式与 Java 中的 switch/case 类似，但是要强大得多。
    - when 既可以被当做表达式使用也可以被当做语句使用，when 将参数和所有的分支条件顺序比较直到某个分支满足条件，然后它会运行右边的表达式
    - 如果 when 被当做表达式来使用，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。与 Java 的 switch/case 不同之处是 When 表达式的参数可以是任何类型，并且分支也可以是一个条件
    - 和 if 一样，When 每一个分支可以是一个代码块，它的值是代码块中最后的表达式的值，如果其它分支都不满足条件将会求值于 else 分支
    - 如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了
    - 如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔
    ``` kotlin
    val value = 2
    when (value) {
        in 4..9 -> println("in 4..9") //区间判断
        3 -> println("value is 3")    //相等性判断
        2, 6 -> println("value is 2 or 6")    //多值相等性判断
        is Int -> println("is Int")   //类型判断
        else -> println("else")       //如果以上条件都不满足，则执行 else
    }
    
    fun main(args: Array<String>) {
        fun parser(obj: Any): String =
                when (obj) {
                    1 -> "value is 1"
                    "4" -> "value is string 4"
                    is Long -> "value type is long"
                    else -> "unknown"
                }
        println(parser(1))
        println(parser(1L))
        println(parser("4"))
        println(parser(100L))
        println(parser(100.0))
    }
    
    
    value is 1
    value type is long
    value is string 4
    value type is long
    unknown
    ```
- 此外，When 循环也可以不带参数
    ``` kotlin
    when {
        1 > 5 -> println("1 > 5")
        3 > 1 -> println("3 > 1")
    }
    ```


#### 5.3 for循环
- 和 Java 中的 for 循环最为类似的形式是
    ```kotlin
    val list = listOf(1, 4, 10, 34, 10)
    for (value in list) {
        println(value)
    }
    ```
- 通过索引来遍历
    ```kotlin
    val items = listOf("H", "e", "l", "l", "o")
    //通过索引来遍历List
    for (index in items.indices) {
        println("${index}对应的值是：${items[index]}")
    }
    ```
- 也可以在每次循环中获取当前索引和相应的值
    ```kotlin
    val list = listOf(1, 4, 10, 34, 10)
    for ((index, value) in list.withIndex()) {
        println("index : $index , value :$value")
    }
    ```
- 也可以自定义循环区间
    ```kotlin
    for (index in 2..10) {
        println(index)
    }
    ```



#### 5.4 While 和 do/while 循环
- While 和 do/while 和 Java 中的区别不大
    ```kotlin
    val list = listOf(1, 4, 15, 2, 4, 10, 0, 9)
    var index = 0
    while (index < list.size) {
        println(list[index])
        index++
    }
    
    val list = listOf(1, 4, 15, 2, 4, 10, 0, 9)
    var index = 0
    do {
        println(list[index])
        index++
    } while (index < list.size)
    ```


#### 5.5 Ranges
- Ranges 表达式使用一个 ..  操作符来声明一个闭区间，它是被定义实现了一个 RangTo  方法
- 以下两种声明形式是等价了
    ```kotlin
    var index = 5
    if (index >= 0 && index <= 10) {
    
    }
    if (index in 0..10) {
    
    }
    ```
- 数字类型的 ranges 在被迭代时，编译器会将它们转换为与 Java 中使用 index 的 for 循环的相同字节码的方式来进行优化
    - Ranges 默认会自增长，所以如果像以下的代码就不会被执行
    ```kotlin
    for (index in 10..0) {
        println(index)
    }
    ```
    - 可以改用 downTo 函数来将之改为递减
    ```kotlin
    for (index in 10 downTo 0) {
        println(index)
    }
    ```
    - 可以在 ranges 中使用 step 来定义每次循环递增或递增的长度：
    ```kotlin
    for (index in 1..8 step 2){
        println(index)
    }
    for (index in 8 downTo 1 step 2) {
        println(index)
    }
    ```
- 以上声明的都是闭区间，如果想声明的是开区间，可以使用 until 函数：
    ```kotlin
    for (index in 0 until 4){
        println(index)
    }
    ```




### 06.运算符重载
- Kotlin 允许为类型提供预定义的操作符实现，这些操作符具有固定的符号表示（例如 + 和 * ）和固定的优先级，通过操作符重载可以将操作符的行为映射到指定的方法。为实现这样的操作符，需要为类提供一个固定名字的成员函数或扩展函数，相应的重载操作符的函数需要用 operator 修饰符标记

#### 6.1 一元操作符
- 如下所示
    | 操作符| 函数  |
    | -------------  | :-------------: |
    | +a | a.unaryPlus()  |
    | -a| a.unaryMinus()  |
    |!a| a.not()  |
    |a++| a.inc() |
    |a--| a.dec() |

#### 6.2 二元操作符
- 如下所示
    | 操作符  |       函数       |
    | ------- | :--------------: |
    | a + b   |    a.plus(b)     |
    | a - b   |    a.minus(b)    |
    | a * b   |    a.times(b)    |
    | a / b   |     a.div(b)     |
    | a % b   |     a.rem(b)     |
    | a..b    |   a.rangeTo(b)   |
    | a in b  |  b.contains(a)   |
    | a !in b |  !b.contains(a)  |
    | a += b  | a.plusAssign(b)  |
    | a -= b  | a.minusAssign(b) |
    | a *= b  | a.timesAssign(b) |
    | a /= b  |  a.divAssign(b)  |
    | a %= b  |  a.remAssign(b)  |

#### 6.3 数组操作符
- 如下所示
    | 操作符               |          函数           |
    | -------------------- | :---------------------: |
    | a[i]                 |        a.get(i)         |
    | a[i, j]              |       a.get(i, j)       |
    | a[i_1, ..., i_n]     |  a.get(i_1, ..., i_n)   |
    | a[i] = b             |       a.set(i, b)       |
    | a[i, j] = b          |     a.set(i, j, b)      |
    | a[i_1, ..., i_n] = b | a.set(i_1, ..., i_n, b) |

#### 6.4 等于操作符
- 如下所示
    | 操作符 |             函数              |
    | ------ | :---------------------------: |
    | a == b |  a?.equals(b) ?: b === null   |
    | a != b | !(a?.equals(b) ?: b === null) |
- 相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称
    - 方法必须要如下准确地被实现：
    ```
    operator fun equals(other: Any?): Boolean
    ```
- 操作符 ===  和 !==  用来做身份检查（它们分别是 Java 中的 ==  和 !=  ），并且它们不能被重载



#### 6.5 比较操作符
- 如下所示
    | 操作符 |        函数         |
    | ------ | :-----------------: |
    | a > b  | a.compareTo(b) > 0  |
    | a < b  | a.compareTo(b) < 0  |
    | a >= b | a.compareTo(b) >= 0 |
    | a <= b | a.compareTo(b) <= 0 |
- 所有的比较都转换为对  compareTo  的调用，这个函数需要返回  Int  值







### 关于其他内容介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e






















