#### 目录介绍
- 01.为什么要有线程池
    - 1.1 开发中遇到的问题
    - 1.2 线程消耗资源分析
- 02.线程池设计思想
    - 2.1 线程池核心思想
    - 2.2 池化资源设计
    - 2.3 生产者消费者设计
    - 2.4 简化的线程池设计



### 01.为什么要有线程池
#### 1.1 开发中遇到的问题
- 在开发中经常会使用到多线程
    - 例如在Android中，由于主线程的诸多限制，像网络请求，图片加载等一些耗时的操作我们必须在子线程中运行。这时候会创建很多线程。
- 创建线程是重量级操作
    - 创建对象，仅仅是在 JVM 的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的 API，然后操作系统要为线程分配一系列的资源，这个成本就很高了，所以线程是一个重量级的对象，应该避免频繁创建和销毁。



#### 1.2 线程消耗资源分析
- 线程为什么消耗资源呢？
    - 待完善
- 线程是怎么消耗资源的？
    - 待完善



### 02.线程池设计思想
#### 2.1 线程池核心思想
- 线程池核心思想
    - 主要是解决线程的频繁创建和销毁。避免资源的无效浪费。



#### 2.2 池化资源设计
- 什么叫做池化设计
    - 一般意义上的池化资源，都是下面这样，当你需要资源的时候就调用 acquire() 方法来申请资源，用完之后就调用 release() 释放资源。



#### 2.3 生产者消费者设计
- 为什么线程池没有采用一般意义上池化资源的设计方法呢？
    - 你可以来思考一下，假设我们获取到一个空闲线程 T1，然后该如何使用 T1 呢？你期望的可能是这样：通过调用 T1 的 execute() 方法，传入一个 Runnable 对象来执行具体业务逻辑，就像通过构造函数 Thread(Runnable target) 创建线程一样。
    - 可惜的是，你翻遍 Thread 对象的所有方法，都不存在类似 execute(Runnable target) 这样的公共方法。
- 那线程池该如何设计呢？
    - 目前业界线程池的设计，普遍采用的都是生产者 - 消费者模式。线程池的使用方是生产者，线程池本身是消费者。



#### 2.4 简化的线程池设计
- 创建了一个非常简单的线程池 MyThreadPool，你可以通过它来理解线程池的工作原理。
    - 在 MyThreadPool 的内部，我们维护了一个阻塞队列 workQueue 和一组工作线程，工作线程的个数由构造函数中的 poolSize 来指定。
    - 用户通过调用 execute() 方法来提交 Runnable 任务，execute() 方法的内部实现仅仅是将任务加入到 workQueue 中。
    - MyThreadPool 内部维护的工作线程会消费 workQueue 中的任务并执行任务，相关的代码就是代码①处的 while 循环。
- 线程池主要的工作原理就这些，是不是还挺简单的？代码如下所示：
    ``` java
    //简化的线程池，仅用来说明工作原理
    class MyThreadPool{
      //利用阻塞队列实现生产者-消费者模式
      BlockingQueue<Runnable> workQueue;
      //保存内部工作线程
      List<WorkerThread> threads = new ArrayList<>();
      // 构造方法
      MyThreadPool(int poolSize, 
        BlockingQueue<Runnable> workQueue){
        this.workQueue = workQueue;
        // 创建工作线程
        for(int idx=0; idx<poolSize; idx++){
          WorkerThread work = new WorkerThread();
          work.start();
          threads.add(work);
        }
      }
      // 提交任务
      void execute(Runnable command){
        workQueue.put(command);
      }
      // 工作线程负责消费任务，并执行任务
      class WorkerThread extends Thread{
        public void run() {
          //循环取任务并执行
          while(true){ ①
            Runnable task = workQueue.take();
            task.run();
          } 
        }
      }  
    }
    
    /** 下面是使用示例 **/
    // 创建有界阻塞队列
    BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(2);
    // 创建线程池  
    MyThreadPool pool = new MyThreadPool(10, workQueue);
    // 提交任务  
    pool.execute(()->{
        System.out.println("hello");
    });
    ```











    
    