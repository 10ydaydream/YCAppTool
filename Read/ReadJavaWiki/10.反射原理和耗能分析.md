#### 目录介绍
- 01.反射的设计思想
    - 1.1 为何设计反射
    - 1.2 反射应用的场景
    - 1.3 反射的初衷
- 02.反射实践的运用
    - 2.1 反射创建对象
    - 2.2 反射组成
    - 2.5 如何避免反射攻击




### 01.反射的设计思想
#### 1.1 为何设计反射
- 反射是一种具有与类进行动态交互能力的一种机制，为什么要强调动态交互呢
    - 动态加载，也就是在运行的时候才会加载，而不是在编译的时候，在需要的时候才进行加载获取，或者说你可以在任何时候加载一个不存在的类到内存中，然后进行各种交互，或者获取一个没有公开的类的所有信息。
    - 换句话说，开发者可以随时随意的利用反射的这种机制动态进行一些特殊的事情。



#### 1.2 反射应用的场景
- 反射应用的场景
    - 1.逆向代码 ，例如反编译
    - 2.与注解相结合的框架 例如Retrofit
    - 3.单纯的反射机制应用框架 例如EventBus
    - 4.动态生成类框架 例如Gson
    - 5.组件化中Module通信 例如SPI
    - 6.需要访问隐藏属性或者调用方法改变程序原来的逻辑，这个在开发中很常见的，由于一些原因，系统并没有开放一些接口出来，这个时候利用反射是一个有效的解决方法。



#### 1.3 反射的初衷
- 反射是为了能够动态的加载一个类
    - 动态加载类，动态的调用一个方法，动态的访问一个属性等动态要求而设计的。
    - 对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
- 使用反射的初衷是什么
    - 反射的初衷不是方便你去创建一个对象，而是让你**写代码的时候可以更加灵活，降低耦合，提高代码的自适应能力**。



### 02.反射实践的运用
#### 2.1 反射创建对象
- 在Java程序中获得Class对象通常有如下三种方式：
    - 1.使用Class类的forName\(String clazzName\)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。
    - 2.调用某个类的class属性来获取该类对应的Class对象。
    - 3.调用某个对象的getClass\(\)方法。该方法是java.lang.Object类中的一个方法。
- 第一种：Class.forName()
    - 1.通过JVM查找并加载指定的类(上面的代码指定加载了com.fanshe包中的Person类)
    - 2.调用newInstance()方法让加载完的类在内存中创建对应的实例,并把实例赋值给p
        - 注意：如果找不到时，它会抛出 ClassNotFoundException 这个异常，这个很好理解，因为如果查找的类没有在 JVM 中加载的话，自然要告诉开发者。
    ``` java
    Class<?> cls=Class.forName("com.yc.Person"); //forName(包名.类名)
    Person p= (Person) cls.newInstance();
    ```
- 第二种：类.class
    - 1.获取指定类型的Class对象,这里是Person
    - 2.调用newInstance()方法在让Class对象在内存中创建对应的实例,并且让p引用实例的内存地址
    ``` java
    Class<?> cls = Person.class;
    Person p=(Person)cls.newInstance();
    ```
- 第三种：对象.getClass()
    - 1.在内存中新建一个Person的实例,对象p对这个内存地址进行引用
    - 2.对象p调用getClass()返回对象p所对应的Class对
    - 3.调用newInstance()方法让Class对象在内存中创建对应的实例,并且让p2引用实例的内存地址
    ``` java
    Person p = new Person();
    Class<?> cls= p.getClass();
    Person p2=(Person)cls.newInstance();
    ```



#### 2.2 反射组成
- 由于反射最终也必须有类参与，因此反射的组成一般有下面几个方面组成:
    - 1.java.lang.Class.java：类对象；
    - 2.java.lang.reflect.Constructor.java：类的构造器对象；
    - 3.java.lang.reflect.Method.java：类的方法对象；
    - 4.java.lang.reflect.Field.java：类的属性对象；
- 反射中类的加载过程
    - 根据虚拟机的工作原理,一般情况下，类需要经过:加载->验证->准备->解析->初始化->使用->卸载这个过程。
    - 如果需要反射的类没有在内存中，那么首先会经过加载这个过程，并在在内存中生成一个class对象，有了这个class对象的引用，就可以发挥开发者的想象力，做自己想做的事情了。



#### 2.5 如何避免反射攻击
- 第一种：防止反射攻击单例
- 第二种：将类抽象也无法利用反射
- 第三种：将类设置成final不可变



