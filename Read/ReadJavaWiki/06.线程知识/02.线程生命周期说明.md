#### 目录介绍
- 01.线程生命周期
    - 1.1 线程执行流程
    - 1.2 线程状态转换
- 02.线程是如何创建
    - 2.1 创建线程几种方式
    - 2.2 使用Thread类创建线程类
    - 2.3 通过Runnable接口创建线程类
    - 2.4 通过Callable和Future创建线程
    - 2.5 三种创建线程区别
- 07.线程setDaemon守护
- 08.线程stop中断操作




### 01.线程生命周期
#### 1.1 线程执行流程
- 见图03.1
- ![image](https://upload-images.jianshu.io/upload_images/4432347-7a47153a444d450b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.2 线程状态转换
- 线程是会在不同的状态间进行转换。
    - 线程创建之后调用start()方法开始运行，进入到就绪状态；
    - 调用wait(),join(),LockSupport.lock()方法线程会进入到**WAITING**状态；
    - 而同样的wait(long timeout)，sleep(long),join(long),LockSupport.parkNanos(),LockSupport.parkUtil()增加了超时等待的功能，也就是调用这些方法后线程会进入**TIMED_WAITING**状态，
    - 当超时等待时间到达后，线程会切换到Runnable的状态，另外当WAITING和TIMED _WAITING状态时可以通过Object.notify(),Object.notifyAll()方法使线程转换到Runnable状态。
    - 当线程出现资源竞争时，即等待获取锁的时候，线程会进入到**BLOCKED**阻塞状态，当线程获取锁时，线程进入到Runnable状态。
    - 线程运行结束后，线程进入到**TERMINATED**状态，状态转换可以说是线程的生命周期。
- 另外需要注意的是：
    - 当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是BLOCKED状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是WAITING或者TIMED_WAITING状态，因为lock会调用LockSupport的方法。


### 02.线程是如何创建
#### 2.1 创建线程几种方式
- 那么，如何在用户程序中新建一个线程了，只要有三种方式：
    - 1.通过继承Thread类，重写run方法；
    - 2.通过实现runnable接口；
    - 3.通过实现callable接口这三种方式


#### 2.2 使用Thread类创建线程类
- 直接创建，如下所示
    ``` java
    new Thread(new Runnable() {
        @Override
        public void run() {
            
        }
    }).start();
    ```
- 继承Thread，创建步骤如下
    - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run\(\)方法称为执行体。
    - 创建Thread子类的实例，即创建了线程对象。调用线程对象的start\(\)方法来启动该线程。代码如下所示
    ``` java
    public class ThreadDemo {
    	public static void main(String[] args) {
    		// 创建对象
    		MyThread t1 = new MyThread() ;
    		MyThread t2 = new MyThread() ;
    		// 启动线程: 需要使用start方法启动线程, 如果我们在这里调用的是run方法,那么我们只是把该方法作为普通方法进行执行
    //		t1.run() ;
    //		t1.run() ;
    		t1.start() ;		// 告诉jvm开启一个线程调用run方法
    		// t1.start() ;		// 一个线程只能被启动一次
    		t2.start() ;
    		
    	}
    }
    
    public class MyThread extends Thread {
    	@Override
    	public void run() {
    		for(int x = 0 ; x < 1000 ; x++) {
    			System.out.println(x);
    		}
    	}
    }
    ```


#### 2.3 通过Runnable接口创建线程类
- 创建步骤如下
    - 定义runnable接口的实现类，并重写该接口的run\(\)方法，该run\(\)方法的方法体同样是该线程的线程执行体。
    - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    - 调用线程对象的start\(\)方法来启动该线程。
- 代码如下所示
    ```
    public static void main(String[] args) {
    	// 创建定义的类的对象
    	MyThread mt = new MyThread() ;
    	// 创建Thread的对象吧第三步创建的对象作为参数传递进来
    	Thread t1 = new Thread(mt , "张三") ;
    	Thread t2 = new Thread(mt , "李四") ;
    	// 启动线程
    	t1.start() ;
    	t2.start() ;
    }
    
    public class MyThread implements Runnable {
    	@Override
    	public void run() {
    		for(int x = 0 ; x < 1000 ; x++) {
    			System.out.println(Thread.currentThread().getName() + "---" + x);
    		}
    		
    	}
    }
    ```


#### 2.4 通过Callable和Future创建线程
- **Callable基础介绍**
    - Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。
    - 它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。
- 通过对比两个接口得到这样的结论
    - Callable 接口下的方法是 call()，Runnable 接口的方法是 run()；
    - Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的；
    - call() 方法可以抛出异常，run()方法不可以的；
    - 运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果；
    ```
    public interface Runnable {
        public void run();
    }
    
    public interface Callable<V> {
        V call() throws Exception;
    }
    ```
- 创建步骤如下所示
    - 创建Callable接口的实现类，并实现call\(\)方法，该call\(\)方法将作为线程执行体，并且有返回值。
    - 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call\(\)方法的返回值。
    - 使用FutureTask对象作为Thread对象的target创建并启动新线程。
    - 调用FutureTask对象的get\(\)方法来获得子线程执行结束后的返回值，调用get\(\)方法会阻塞线程。
- 代码如下所示
    ```
    public class CallableThread implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            int i = 0;
            for (; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + " " + i);
            }
            return i;
        }
    }
    
    
    public class ThreadDemo {
        public static void main(String[] args) {
            CallableThread ctt = new CallableThread();
            FutureTask<Integer> ft = new FutureTask<>(ctt);
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
                if (i == 20) {
                    new Thread(ft, "有返回值的线程").start();
                }
            }
            try {
                System.out.println("子线程的返回值：" + ft.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
    }
    ```


#### 2.5 三种创建线程区别
- 采用实现Runnable、Callable接口的方式创见多线程时
    - 优势是：
        - 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
        - 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
    - 劣势是：[博客](https://github.com/yangchong211/YCBlogs)
        - 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread\(\)方法。
- 使用继承Thread类的方式创建多线程时
    - 优势是：
        - 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread\(\)方法，直接使用this即可获得当前线程。
    - 劣势是：
        - 线程类已经继承了Thread类，所以不能再继承其他父类。


### 07.线程setDaemon守护
- setDaemon方法
    - public final void setDaemon(boolean on)
    - 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。
- 注意要点：
    - 该方法必须在启动线程前调用。
    - jvm会线程程序中存在的线程类型,如果线程全部是守护线程,那么jvm就停止。
- 守护线程是一种特殊的线程
    - 就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。
- 下面以一个简单的例子来表述Daemon线程的使用。
    ```
    public class DaemonDemo {
        public static void main(String[] args) {
            Thread daemonThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            System.out.println("i am alive");
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } finally {
                            System.out.println("finally block");
                        }
                    }
                }
            });
            daemonThread.setDaemon(true);
            daemonThread.start();
            //确保main线程结束前能给daemonThread能够分到时间片
            try {
                Thread.sleep(800);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```
- 输出结果为：
    ```
    > i am alive
    > finally block
    > i am alive
    ```
- 上面的例子中daemodThread run方法中是一个while死循环，会一直打印,但是当main线程结束后daemonThread就会退出所以不会出现死循环的情况。main线程先睡眠800ms保证daemonThread能够拥有一次时间片的机会，也就是说可以正常执行一次打印“i am alive”操作和一次finally块中"finally block"操作。紧接着main 线程结束后，daemonThread退出，这个时候只打印了"i am alive"并没有打印finnal块中的。因此，这里需要注意的是**守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的**线程可以通过setDaemon(true)的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于start()方法，否则会报
    > Exception in thread "main" java.lang.IllegalThreadStateException
    > 	at java.lang.Thread.setDaemon(Thread.java:1365)
    > 	at learn.DaemonDemo.main(DaemonDemo.java:19)
- 这样的异常，但是该线程还是会执行，只不过会当做正常的用户线程执行。



### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e





















