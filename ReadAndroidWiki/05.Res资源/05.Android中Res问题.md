#### 目录介绍
- 5.0.0.1 什么是混淆？Android中是如何混淆的？混淆具体实践是怎么操作的？
- 5.0.0.2 res目录和assets目录的区别？关于 R.java 的生成规则是如何理解的，多个module中的同一个图片资源，生成R的值是一样吗？




### 5.0.0.1 什么是混淆？Android中是如何混淆的？混淆具体实践是怎么操作的？
- 混淆代码
    - 混淆分为两种代码混淆和资源文件混淆。实际的产品研发中为了防止自己的劳动成果被别人窃取，混淆代码能有效防止apk文件被反编译，进而查看源代码。
- Android如何混淆
    - android提供了Progurd方式来混淆apk中的代码，其核心的逻辑是在代码层将一些易懂的源代码类名，方法名称替换成毫无意义的a、b、c、d...，这样当第三方反编译出你的Apk文件时，看到的源代码也无法还原其本身的逻辑，或者代码中方法，类，对象等变成无法阅读的字母。
- 混淆具体实践是怎么操作的？
    - 第一种方式：gradle配置文件。在android项目中找到module的gradle配置文件，添加proguard配置
        ```
        buildTypes {
            release {
                //混淆
                minifyEnabled false
                //Zipalign优化
                zipAlignEnabled true
            }
        }
        ```
    - 第二种方式：proguard-rules.pro文件。该文件就是Android中的混淆配置文件
        - proguard混淆语法
            ```
            -libraryjars class_path 应用的依赖包，如android-support-v4  
            -keep [,modifier,...] class_specification 这里的keep就是保持的意思，意味着不混淆某些类 
            -keepclassmembers [,modifier,...] class_specification 同样的保持，不混淆类的成员  
            -keepclasseswithmembers [,modifier,...] class_specification 不混淆类及其成员  
            -keepnames class_specification 不混淆类及其成员名  
            -keepclassmembernames class_specification 不混淆类的成员名  
            -keepclasseswithmembernames class_specification 不混淆类及其成员名  
            -assumenosideeffects class_specification 假设调用不产生任何影响，在proguard代码优化时会将该调用remove掉。如system.out.println和Log.v等等  
            -dontwarn [class_filter] 不提示warnning  
            ```
- 混淆原则有哪些？
    - jni方法不可混淆
    - 反射用到的类不混淆(否则反射可能出现问题)
    - AndroidMainfest中的类不混淆，四大组件和Application的子类和Framework层下所有的类默认不会进行混淆
    - Parcelable的子类和Creator静态成员变量不混淆，否则会产生android.os.BadParcelableException异常
    - 使用GSON、fastjson等框架时，所写的JSON对象类不混淆，否则无法将JSON解析成对应的对象
    - 使用第三方开源库或者引用其他第三方的SDK包时，需要在混淆文件中加入对应的混淆规则
    - 有用到WEBView的JS调用也需要保证写的接口方法不混淆
- 第三方库的混淆原则
    - 一般的第三方库都有自身的混淆方案，可直接引用其自身的混淆配置即可
    - 若无混淆配置，一般的可配置不混淆第三方库





### 5.0.0.2 res目录和assets目录的区别？关于 R.java 的生成规则是如何理解的，多个module中的同一个图片资源，生成R的值是一样吗？
- res目录和assets目录的区别
    - assets：不会在 R文件中生成相应标记，存放到这里的资源在打包时会打包到程序安装包中。（通过 AssetManager 类访问这些文件）
    - res：会在 R 文件中生成 id标记，资源在打包时如果使用到则打包到安装包中，未用到不会打入安装包中。
    - res/anim：存放动画资源
    - res/raw：和 asset下文件一样，打包时直接打入程序安装包中（会映射到 R文件中）
- 关于 R.java 的生成规则是如何理解的
    - 一般情况，每个 app 会依赖多个 module，一般 module 里面的资源，例如 res中有个 love。对应的在 module中会有个：com.module.R.res.love。app 中也可以使用这个资源，但是包名为：com.app.R.res.love。两者虽然对应一个资源，但是id 值很大概率上是不同的。那么最终打包是如何处理的呢？
    - 最终打包出来的那些资源id，是会重新分配的（同一个资源生成的id，就算不在同一个R.class里，打包出来时也是相同的）。做了个测试：
    ```
    app依赖了模块test；
    test模块中的string.xml有个test_value；
    在test模块中引用(com.test.R)，看到这个test_value的id值是-1900002；
    而在app中(com.app.R)引用时，id值为-1900023；
    这时候可以看出，相同的资源，id确实是不同。
    打包成apk后，把它拖进AS里，点开classes.dex：
    首先找到app包名下的R$string，右键查看字节码，发现test_value的id值由原来的-1900023，变成了0x7f10005d；
    接着找test模块包名下的R$string，查看字节码发现id值一样是0x7f10005d；
    由此看来，id值在打包成apk的时候，确实是重新分配了，而且同一个资源的id值，也统一了。
    ```




