#### 目录介绍
- 01.App启动类型
- 02.什么是冷启动
- 03.什么是热启动
- 04.什么是温启动
- 05.冷启动流程
- 


### 01.App启动类型
- 你知道App启动类型有哪些么？
    - 有冷启动，热启动，温启动。接下来，一起来了解下它们的启动流程和区别……



### 02.什么是冷启动
- 什么是冷启动
    - 场景：开机后第一次启动应用 或者 应用被杀死后再次启动生命周期：
    - Process.start->Application创建->attachBaseContext->onCreate->onStart->onResume->Activity生命周期启动速度：主要是优化这块的启动过程时间。冷启动是最慢最耗时的，系统以及应用本身都有大量的工作需要处理，所以，冷启动对于应用的启动速度是最具挑战以及最有必要进行优化的。
- 详细一点说
    - 冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。
    - 特点：冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。




### 03.什么是热启动
- 什么是热启动
    - 场景：Home键最小化应用生命周期，然后从后台切换到前台操作
    - onResume->Activity生命周期启动速度：快
- 详细一点说
    - 热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。
    - 特点：热启动因为会从已有的进程中来启动，所以热启动就不会走application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化application，因为一个应用从新进程的创建到进程的销毁，application只会初始化一次。



### 04.什么是温启动
- 什么是温启动
    - 场景：应用已经启动，返回键退出生命周期：onCreate->onStart->onResume->Activity生命周期启动速度：较快


### 05.冷启动流程
- 冷启动指的是应用程序从进程在系统不存在，到系统创建应用运行进程空间的过程。冷启动通常会发生在一下两种情况：
    - 设备启动以来首次启动应用程序
    - 系统杀死应用程序之后再次启动应用程序
在冷启动的最开始，系统需要负责做三件事：

加载以及启动app
app启动之后立刻显示一个空白的预览窗口
创建app进程

一旦系统完成创建app进程后，app进程将要接着负责完成下面的工作：

创建Application对象
创建并且启动主线程ActivityThread
创建启动第一个Activity
Inflating views
布局屏幕
执行第一次绘制

一旦app进程完完成了第一次绘制工作，系统进程就会用main activity替换前面显示的预览窗口，这个时候，用户就可以正式开始与app进行交互了。

从冷启动的流程看，我们无法干预app进程创建等系统操作，我们能够干预的有：


预览窗口


Application生命周期回调


Activity生命周期回调


测量应用启动时间工具

adb shell am start -W [packageName]/[ packageName. AppstartActivity]

在统计 app 启动时间时，系统为我们提供了 adb 命令,可以输出启动时间。系统在绘制完成后，ActivityManagerService 会回调该方法，但是能够方便我们通过脚本多次启动测量 TotalTime，对比版本间启动时间差异。但是统计时间不如 Systrace 准确。

代码埋点

通过代码埋点来准确获取记录每个方法的执行时间，知道哪些地方耗时，然后再有针对性地优化。例如通过在 app 启动生命周期中，关键位置加入时间点记录，达到测量目的；又例如可以在 Application 的 attachBaseContext方法中记录开始时间，然后在启动的第一个 Activity 的 onWindowFocusChanged方法记录结束时间。但是从用户点击 app Icon 到 Application 被创建，再到 Activity 的渲染，中间还是有很多步骤的，比如冷启动的进程创建过程，而这个时间用此版本是没办法统计了，必须得承受这点数据的不准确性。

Nanoscope

Nanoscope 非常真实，不过暂时只支持 Nexus 6 和 x86 模拟器。

Simpleperf

Simpleperf 的火焰图并不适合做启动流程分析。

TraceView

通过 TraceView 主要可以得到两种数据：单次执行耗时的方法 以及 执行次数多的方法。但是TraceView 性能耗损太大，不能比较正确反映真实情况。

Systrace

Systrace 能够追踪关键系统调用的耗时情况，如系统的 IO 操作、内核工作队列、CPU 负载、Surface 渲染、GC 事件以及 Android 各个子系统的运行状况等。但是不支持应用程序代码的耗时分析。

“Systrace + 函数插桩”

除了能够看到例如 GC、System Server、CPU 调度等系统调用的耗时，还能够通过 Android 工程编译的过程中，在指定的方法前后，自动化插入插桩函数，统计方法执行时间。通过插桩，我们可以看到应用主线程和其他线程的函数调用流程。它的实现原理非常简单，就是将下面的两个函数 通过用ASM框架修改字节码的方式分别插入到每个方法的入口和出口。
class TraceMethod {
    public static void i() {
        Trace.beginSection();
    }

    public static void o() {
        Trace.endSection();
    }
}
复制代码当然这里面有非常多的细节需要考虑，比如怎么样降低插桩对性能的影响、哪些函数需要被排除掉。函数插桩后的效果如下：
class Test {

    public void test() {
        TraceMethod.i();
        // 原来的工作
        TraceMethod.o();
    }
}
复制代码启动优化方法

预览窗口优化

当用户点击应用桌面图标启动应用的时候，利用提前展示出来的 Window，快速展示出一个界面，用户只需要很短的时间就可以看到“预览页”，这种完全“跟手”的感觉在高端机上体验非常好，但对于中低端机，会把总的的闪屏时间变得更长。如果点击图标没有响应，用户主观上会认为是手机系统响应比较慢。所以比较推荐的做法是，只在 Android 6.0 或者 Android 7.0 以上才启用“预览窗口”方案，让手机性能好的用户可以有更好的体验。要实现预览窗口的显示，只需要在利用 activity 的windowBackground主题属性提供一个简单的自定义 drawable 给启动的 activity，如下：Layout XML file：
<layer-list xmlns:android="http://schemas.android.com/apk/res/android" android:opacity="opaque">
  <!-- The background color, preferably the same as your normal theme -->
  <item android:drawable="@android:color/white"/>
  <!-- Your product logo - 144dp color version of your app icon -->
  <item>
    <bitmap
      android:src="@drawable/product_logo_144dp"
      android:gravity="center"/>
  </item>
</layer-list>
复制代码Manifest file：
<activity ...
android:theme="@style/AppTheme.Launcher" />
复制代码这样一个 activity 启动的时候，就会先显示一个预览窗口，给用户快速响应的体验。当 activity想要恢复原来 theme，可以通过在调用super.onCreate() 和setContentView()之前调用 setTheme(R.style.AppTheme)，如下：
public class MyMainActivity extends AppCompatActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    // Make sure this is before calling super.onCreate
    setTheme(R.style.Theme_MyApp);
    super.onCreate(savedInstanceState);
    // ...
  }
}
复制代码
业务梳理

不要一股脑把全部初始化工作放在 Application 中做，需要梳理清楚当前启动过程正在运行的每一个模块，哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。但是需要注意的是，懒加载要防止集中化，否则容易出现首页显示后用户无法操作的情形。总的来说，用以下四个维度分整理启动的各个点：

必要且耗时：启动初始化，考虑用线程来初始化。
必要不耗时：首页绘制。
非必要但耗时：数据上报、插件初始化。
非必要不耗时：不用想，这块直接去掉，在需要用的时再加载。

把数据整理出来后，按需实现加载逻辑，采取分步加载、异步加载、延期加载策略，如下图所示：


业务优化

通过梳理之后，剩下的都是启动过程一定要用的模块。这个时候，我们只能硬着头皮去做进一步的优化。优化前期需要“抓大放小”，先看看主线程究竟慢在哪里。最理想是通过算法进行优化，例如一个数据解密操作需要 1 秒，通过算法优化之后变成 10 毫秒。退而求其次，我们要考虑这些任务是不是可以通过异步线程预加载实现，但需要注意的是过多的线程预加载会让我们的逻辑变得更加复杂。

多进程优化

Android app 是支持多进程的，在 Manifest 中只要在组件声明中加入android:process属性就可以让组件在启动时运行在不同的进程中。举个例子： 对于多进程 app ，可能拥有主进程，插件进程以及下载进程，但开发者只能在Manifest 中声明一个 Application 组件，如果对应不同进程的组件启动时，系统会创建三个进程，创建三个 Application 对象，同时attachBaseContext、onCreate等生命周期回调方法也会被调用三次。但是每个进程需要初始化的内容肯定是不一样的，所以，为了防止资源的浪费，我们需要在Application 中区分进程，对应进程只初始化对应的内容。

线程优化线

程优化分两方面：第一，耗时任务异步化。子线程处理耗时任务，主线程做的事情越少，越早进入Acitivity绘制阶段，界面越早展现。例如不在主线程做如 IO 、网络等耗时操作。但是要注意，子线程不能阻塞主线程。第二，线程池管理线程，控制线程的数量。线程数量太多会相互竞争 CPU 资源，导致分给主线程的时间片减少，从而导致启动速度变慢。线程切换的数据我们可以通过卡顿优化中学到的 sched 文件查看，这里特别需要注意 nr_involuntary_switches 被动切换的次数。
proc/[pid]/sched: 
 nr_voluntary_switches：主动上下文切换次数，因为线程无法获取所需资源导致上下文切换，最普遍的是 IO。 
 nr_involuntary_switches：被动上下文切换次数，线程被系统强制调度导致上下文切换，例如大量线程在抢占 CPU。 
复制代码第三，避免主线程与子线程之间的锁阻塞等待。有一次我们把主线程内的一个耗时任务放到线程中并发执行，但是发现这样做根本没起作用。仔细检查后发现线程内部会持有一个锁，主线程很快就有其他任务因为这个锁而等待。通过 Systrace 可以看到锁等待的事件，我们需要排查这些等待是否可以优化，特别是防止主线程出现长时间的空转。

特别是现在有很多启动框架，会使用 Pipeline 机制，根据业务优先级规定业务初始化时机。比如微信内部使用的 mmkernel 、阿里最近开源的 Alpha 启动框架，它们为各个任务建立依赖关系，最终构成一个有向无环图。对于可以并发的任务，会通过线程池最大程度提升启动速度。如果任务的依赖关系没有配置好，很容易出现下图这种情况，即主线程会一直等待 taskC 结束，空转 2950 毫秒。

第四，设置子线程优先级。不重要任务，设置子线程优先级为 THREAD_PRIORITY_BACKGROUND，这样子线程最多能获取到10%的时间片，优先保证主线程执行。

GC优化

在启动过程，要尽量减少 GC 的次数，避免造成主线程长时间的卡顿，特别是对 Dalvik 来说，我们可以通过 Systrace 单独查看整个启动过程 GC 的时间。启动过程避免进行大量的字符串操作，特别是序列化跟反序列化过程。一些频繁创建的对象，例如网络库和图片库中的 Byte 数组、Buffer 可以复用。如果一些模块实在需要频繁创建对象，可以考虑移到 Native 实现。Java 对象的逃逸也很容易引起 GC 问题，我们在写代码的时候比较容易忽略这个点。我们应该保证对象生命周期尽量的短，在栈上就进行销毁。

系统调用优化

部分系统的API使用是阻塞性的，文件很小可能无法感知，当文件过大，或者使用频繁时，可能造成阻塞。例如：SharedPreference.Editor 的提交操作建议使用异步的 apply，而不是阻塞的 commit。通过 systrace 的 System Service 类型，我们可以看到启动过程 System Server 的CPU 工作情况。在启动过程，我们尽量不要做系统调用，例如 PackageManagerService 操作、Binder 调用等待。在启动过程也不要过早地拉起应用的其他进程，System Server 和新的进程都会竞争 CPU 资源。特别是系统内存不足的时候，当我们拉起一个新的进程，可能会成为“压死骆驼的最后一根稻草”。它可能会触发系统的 low memorykiller 机制，导致系统杀死和拉起（保活）大量的进程，从而影响前台进程的 CPU。

布局优化
布局越复杂，测量布局绘制的时间就越长。主要做到以下几点：布局的层级越少，加载速度越快。一个控件的属性越少，解析越快，删除控件中的无用属性。使用标签加载一些不常用的布局，做到使用时在加载。使用标签减少布局的嵌套层次。尽可能少用wrap_content，wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。

主要注意以下几个事项：
尽量避免启动时在主线程做密集繁重的工作，如：避免 I/O 操作、反序列化、网络操作、锁等待等。
对模块以及第三方库按需加载，采取分步加载、异步加载、延期加载等策略。
利用线程池管理线程，避免创建大量线程，造成 CPU 竞争，导致主线程时间片减少。
启动过程中，尽量避免频繁创建的大量对象，减少 GC 给启动性能带来的卡顿影响。
尽量避免在启动过程中调用阻塞性的系统调用。













- https://juejin.im/post/5cba7930f265da036f4e7ca3




















