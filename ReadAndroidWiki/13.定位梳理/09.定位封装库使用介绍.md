#### 目录介绍
- 01.初始化操作



### 01.初始化操作
- 在开始定位前，需要做：首先要初始化一个DIDILocationManager，这是请求定位的入口类，代码如下：
    - private DIDILocationManager mLocManager = null;


#### 1.1 基本初始化



mLocManager = DIDILocationManager.getInstance(this.getApplicationContext());
//设置接入app的名称（能代表自己的应用的名称即可），目前做统计和日志使用。


mLocManager.setAppid("didi_loc_test"); 
//设置登录账户的手机号码，目前做统计和日志使用。
mLocManager.setPhonenum("15901080503");
//设置接入app的版本号，目前做统计和日志使用。
mLocManager.setAppVersionName("1.0.0");


1.2 设置是否使用省电模式

对某些确实有节省耗电要求的app，提供了此接口，可以降低定位模块耗电，但定位效果也会有降低，所以建议谨慎使用。这是个全局属性设置。
原理：定位耗电主要在GPS模块，如果开启对系统GPS连续监听，则即使调大监听频率，但底层GPS模块一直在接收GPS信号及结算，耗电并不会减少。
所以这里的省电策略是根据当前监听定位SDK的最小间隔，去间隔性地调用系统的单次请求GPS，因为GPS不是一直在工作，每次相当于一次热启动（但间隔较短）对收敛性有一定程度影响，从而会对定位效果有影响。
DIDILocationManager:
/**
* 全局指定定位模式，可指定值为{@link Config.LocateMode}, 如高精度模式或GPS低功耗定位模式。
* @param mode 见{@link Config.LocateMode}
*/
@Override
public void setLocateMode(Config.LocateMode mode)



1.3 其他

下面的这个接口务必注意：国内使用的应用不要调用此函数。
/**
* 设置返回的定位坐标类型。默认为GCJ02坐标(国内定位时使用的坐标)。
* 一定注意:1.当前只有做国际版业务时，才需要调用此函数。别的业务线或其他情况下禁止调用此函数。2.若需要调用，请在初始化阶段、请求定位之前调用。
* @param type 坐标类型。只能设置成{@link DIDILocation#COORDINATE_TYPE_GCJ02,DIDILocation#COORDINATE_TYPE_WGS84}之一。
*/

mLocManager.setCoordinateType(DIDILocation.COORDINATE_TYPE_WGS84);



02.请求定位
请求获取位置有三种方式：连续请求定位，单次请求定位，获得上次位置。
2.1 连续请求定位
最常用的方式就是请求连续定位，使用方传入一个listener，SDK内部会根据使用方设定的监听间隔，通过listener不断回调通知使用方获得到的最新位置。当第一次注册listener请求定位时，定位SDK内部会自动启动定位服务。连续定位支持多listener监听，并且每个listener可以指定不同的监听频率。使用方可以根据自己的业务场景，在不同地方注册不同listener，并在传入参数时传入不同的DIDILocationUpdateOption（内部设置不同的监听频率）。同一个listener也可以根据场景改变监听频率，只要把DIDILocationUpdateOption参数设置不同的监听频率，再注册一次此listener就可以。这种定位方式的示例代码如下：
//构造请求定位的监听listener
private DIDILocationListener mLocListener = new DIDILocationListener() {
    @Override
 public void onLocationChanged(DIDILocation didiLocation) {
       ...//获得位置，对位置进行处理。
 }
    @Override
 public void onLocationError(int errNo, ErrInfo errInfo) {
 ...//定位出错，分别根据错误码errNo结合错误说明信息errInfo.getErrMessage()进行处理。注意errInfo只是对错误码的说明，不支持多语言，使用方不可直接用来提示用户或做其他用途。
 }
    @Override
 public void onStatusUpdate(String name, int status, String desc) {
       ...//手机中定位相关硬件模块的状态的变化，如GPS、wifi、cell（基站）状态的变化。
 }
};
//获得默认的定位请求配置option，其监听频率是3s
mUpdateOption = mLocManager.getDefaultLocationUpdateOption();
//一定要设置业务线的key，现阶段复用POI业务分配给各业务线的key，如果没有，传入能代表自己业务的一个字符串。如没有设置，会报错。
mUpdateOption.setModuleKey("didi_loc_test");
//根据自己业务需要是否设置自己的监听频率：用DIDILocationUpdateOption.IntervalMode枚举值：1、3、9、36s。
//mUpdateOption.setInterval(DIDILocationUpdateOption.IntervalMode.BATTERY_SAVE);
//开始请求连续定位。
mLocManager.requestLocationUpdates(mLocListener, mUpdateOption);
//改变监听频率

mUpdateOption.setInterval(DIDILocationUpdateOption.IntervalMode.HIGH_FREQUENCY);
mLocManager.requestLocationUpdates(mLocListener, mUpdateOption);
一定要在传入的请求定位配置mUpdateOption中设置自己应用的key（现阶段复用POI业务分配给各业务线的key，如果没有，传入能代表自己业务的一个字符串），否则会报错。mUpdateOption中可以设置的监听频率具体见下面的接口说明wiki。监听位置的listener有三个回调，分别是获取到位置、定位出错、定位相关硬件模块的状态，DIDILocation是位置信息类，包含经度、纬度、定位精度、位置提供者等信息，具体见接口说明wiki。
定位出错的错误码及说明如下：错误码常量定义在ErrInfo中，错误说明可以通过ErrInfo的getErrMessage()来获得。
ERROR_LOCATION_PERMISSION：101	无定位权限（定位开关关闭；GPS关闭；或者用户没有授予应用定位相关权限）。
ERROR_NO_ELEMENT_FOR_LOCATION：103	获取不到定位依据：由于某种原因，而拿不到GPS信息，也拿不到wifi、基站信息（如定位开关中设置仅GPS不用网路定位）。
ERROR_APP_PERMISSION：201	App无SDK使用权限（业务/APP注册时需要传入使用方信息，进行鉴权）。
ERROR_MODULE_PERMISSION：202	业务线模块无SDK使用权限（业务/APP注册时需要传入使用方信息，进行鉴权）。
ERROR_NETWORK_CONNECTION：301	无网络连接。
ERROR_HTTP_REQUEST_NORMAL_ERR：302	常规网络请求错误，如403，501等。具体网络请求失败错误码可以通过ErrInfo的getReponseCode（）获得。
ERROR_HTTP_REQUEST_EXCEPTION：303	网络请求发生异常，如超时等。
ERROR_HTTP_REQUEST_NO_LOCATION_RETURN：304	服务器没有返回位置信息。
ERROR_HTTP_RESPONSE_NULL：305	服务器请求响应为空。
ERROR_OTHERS：1000	未知错误。
ERROR_TENCENT_NETWORK：1	腾讯定位错误：网络问题引起的定位失败。
注意：ErrInfo里方法返回的字符串只是对相应信息的一个说明，不支持多语言，业务方禁止用其直接做业务使用或提示给用户，应当根据业务场景及错误码生成业务方自己的提示信息。
 

状态回调onStatusUpdate(String name, int status, String desc)里返回的定位硬件模块的名字及其对应的可能的状态码如下：name为硬件模块名称，status为状态，二者相关的常量都定义在DIDILocation中，desc暂时不返回值，为空字符串。
定位硬件模块（name）	状态（status）	说明
 
STATUS_CELL：
"cell"
  	STATUS_CELL_AVAILABLE：
0x00
基站信息可得（安装了sim卡并且有服务）
STATUS_CELL_UNAVAILABLE：
0x01
基站信息不可得（没安装sim卡或服务不可得等）
STATUS_CELL_DENIED：
0x02
基站（cell）定位权限被禁止（android M以上：没有授予应用定位权限，没有ACCESS_COARSE_LOCATION级别权限）
 
STATUS_WIFI：
"wifi"
   	STATUS_WIFI_ENABLED：
0x00
wifi开关打开
STATUS_WIFI_DISABLED：
0x10
wifi开关关闭
STATUS_WIFI_DENIED：
0x20
wifi定位权限被禁止（没有授予应用定位权限，没有ACCESS_COARSE_LOCATION级别权限）
STATUS_WIFI_LOCATION_SWITCH_OFF：
0x40
位置信息开关关闭，在android M系统中，此时禁止进行wifi扫描
 
STATUS_GPS：
"gps"
    	
STATUS_GPS_ENABLED：
0x000
手机gps开启
STATUS_GPS_DISABLED：
0x100
手机GPS没有开启
STATUS_GPS_DENIED：
0x200
GPS定位权限被禁止（没有授予应用定位权限，没有ACCESS_FINE_LOCATION级别权限）
STATUS_GPS_AVAILABLE：
0x300
GPS模块是可用的，可用于定位
STATUS_GPS_UNAVAILABLE：
0x400
GPS模块定位是不可用的
2.2 设置直接监听模式
定位SDK支持直接监听定位模式：
从系统得到某种系统定位（如GPS,FLP）后，会结合监听间隔立即回调通知设置此模式的listener，不走轮询获取再通知的流程，以免造成延时；其他定位类型（如滴滴网络定位、腾讯定位、NLP等）仍然走轮询获取再通知。当前支持google flp，在global司机端使用。
设置此模式方法：
mUpdateOption = mLocManager.getDefaultLocationUpdateOption();
//其他设置同上（1）。
......

//设置直接监听模式。
mUpdateOption.setDirectNotify(true);
//开始请求连续定位。
mLocManager.requestLocationUpdates(mLocListener, mUpdateOption);

2.3 单次请求定位
单次请求定位同样是异步方式，方式类似于连续请求定位，但listener回调只会得到一次结果，之后定位服务自动停止。示例代码如下：
//mLocManager初始化同连续定位，但只初始化一次即可。

//构造单次请求定位的监听listener
private DIDILocationListener mOnceLocListener = new DIDILocationListener() {
    @Override
 public void onLocationChanged(DIDILocation didiLocation) {
       ...//获得位置，对位置进行处理。
 }
    @Override
 public void onLocationError(int errNo, ErrInfo errInfo) {
 ...//定位出错，分别根据错误码errNo结合错误说明信息errInfo.getErrMessage()进行处理。注意errInfo只是对错误码的说明，不支持多语言，使用方不可直接用来提示用户或做其他用途。
 }
    @Override
 public void onStatusUpdate(String name, int status, String desc) {
       ...//手机中定位相关硬件模块的状态的变化，如GPS、wifi、cell（基站）状态的变化。
 }
};
mLocManager.requestLocationUpdateOnce(mOnceLocListener, "didi_loc_test");
第二个参数一定正确传入自己业务的key，规则同（1）连续定位中的说明。



2.4 获得上次定位位置
如果定位从来没有启动过，此接口返回null，只要定位结果启动过，此接口就会返回最近一次获得的位置。此位置有可能是一个缓存位置，如果定位服务在你调用此接口之前已经关闭了。调用示例代码如下：
DIDILocation didiLocation = mLocManager.getLastKnownLocation();
2.5 获得一组最近得到有效的定位点
最多5个，有效：得到定位的时间在30s内

此功能得到的点可能是各种类型的定位点，具体获取方法：

DIDILocBusinessHelper mLocBizHelper =DIDILocBusinessHelper.getInstance();
List<DIDILocation> recentLocs = mLocBizHelper.getRecent5EffectiveLocations();


 
03.停止定位服务
当启动连续定位后，如果业务不再需要定位了（如应用退出，切到后台后），一定要注销2（1）中注册的listener，注册listener和注销listener一定要成对使用，并且不需要定位时尽早注销listener，当所有监听位置的listener都被注销时，定位SDK内部会自动停止定位服务。按照此规则使用避免过度消耗手机性能及耗电。注销监听定位listener示例代码如下：
locManager.removeLocationUpdates(mLocListener);
04.模拟定位
1）手机设置中-》开发者选项-》模拟定位开关中选择模拟软件（android6.0是打开模拟开关就行）。
2）代码中如下设置：
DIDILocationManager.getInstance(this).enableMockLocation(true);
参数 true：打开模拟定位。false：关闭模拟定位。

5.获取定位硬件模块状态
定位SDK提供了获取手机上GPS，wifi，基站（sim卡）的状态的能力，示例代码如下：
//获取基站（sim卡）相关状态
int cellState = locManager.getCellStatus();
//获取wifi相关状态
 
int wifiState = locManager.getWifiStatus();
//获取gps相关状态
 
int gpsState = locManager.getGpsStatus();
以上返回值是一个状态值位或后的整型值。可以用DIDILocation中的状态常量值与返回值位与，得到具体包含的状态。具体请见下面的定位SDK接口wiki。


6.其他工具
Utils类中：
/**
 * 获得位置开关的状态。
 * @return -1：无法获得状态， 0:定位开关关闭，1:仅GPS定位，2:仅网络定位，3:高精度定位（GPS加网络）。参见: {@link android.provider.Settings.Secure#LOCATION_MODE}
 */
public static int getLocationSwitchLevel(Context context)
DIDILocation类中：
/**
 * 此定位点到目标点location的距离
 * @param location 目标点
 * @return 两点距离，单位米
 */
public double distanceTo(DIDILocation location)

/**
 * 此定位点到目标点的距离
 * @param lng 目标点的精度
 * @param lat 目标点的纬度
 * @return 两点距离，单位米
 */
public double distanceTo(double lng, double lat)

/**
 * 计算两个定位点的距离
 * @param loc1 定位点1
 * @param loc2 定位点2
 * @return 两点距离，单位米
 */
public static double distanceBetween(DIDILocation loc1, DIDILocation loc2)

/**
 * 计算两个定位点的距离
 * @param lng1 定位点1的经度
 * @param lat1 定位点1的纬度
 * @param lng2 定位点2的经度
 * @param lat2 定位点2的纬度
 * @return 两点距离，单位米
 */
public static double distanceBetween(double lng1, double lat1, double lng2, double lat2)
08.常见问题
1、室内不能定位：滴滴网络定位请求失效，返回定位SDK内部定义的错误码304或302。
解：滴滴有个签名拦截器的SDK，之前某版本版本此拦截器会改变请求内容，导致网络请求失效。此拦截器绑定公共网络库使用，而定位新版本都使用公共网络库了。如果室内，系统设置中设置“仅使用GPS定位”，用定位sdk 2.3.77可以定位，用最新版本不能定位，那就是这个原因。请更新'com.didi.security.wireless:wsg-android-adapter:1.3.7'。
2、Android 8.0 后台定位适配
Android 8.0 及以上版本，系统默认会限制后台定位，实测8.0退到后台时几乎不会收到系统GPS定位更新。
解决方案：若有后台定位需求，则需要业务层在退后台时启动一个ForegroundService，并传入对应的Notification。
参考实现方式：
https://git.xiaojukeji.com/one-android/TheOnePassengerFramework/tree/master/src/main/java/com/didi/sdk/service
参考文档：
https://developer.android.com/about/versions/oreo/android-8.0-changes 
https://developer.android.com/about/versions/oreo/background-location-limits
3、Android Q 后台定位适配
Android Q 及以上版本，引入了 “仅在使用该应用期间允许” 的定位权限。
若有后台定位需求，且 targetSdkVersion 在 Q 及以上，则在 “Android 8.0 后台定位适配” 基础上，需做如下改动：
compileSdkVersion 调成 Q 或以上
在 manifest 定义的前台服务中增加 android:foregroundServiceType=“location“
调用 startForeground 启动服务时，增加第三个参数：ServiceInfo.FOREGROUND_SERVICE_TYPE_MANIFEST
集成App增加权限声明：android.permission.FOREGROUND_SERVICE


















