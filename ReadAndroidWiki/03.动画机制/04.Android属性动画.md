
##  4.Android属性动画
#####  4.1 属性动画基本介绍
- **补间动画增强版本，补间动画存在一些缺点**
- a.作用对象局限：View 。即补间动画 只能够作用在视图View上，即只可以对一个Button、TextView、甚至是LinearLayout、或者其它继承自View的组件进行动画操作，但无法对非View的对象进行动画操作
- b.没有改变View的属性，只是改变视觉效果
- c.动画效果单一

- **属性动画特点**
- 作用对象：任意 Java 对象，不再局限于 视图View对象
- 实现的动画效果：可自定义各种动画效果，不再局限于4种基本变换：平移、旋转、缩放 & 透明度
- **基本工作原理**
- 在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果
- **属性动画基类：Animator，抽象类。子类有**
- 两个重要的类：ValueAnimator 类 & ObjectAnimator 类
- 其他类：Evaluator类，AnimatorSet类
- **关于常用属性动画类总结如下图所示**
![Image.png](/uploads/userup/10585/1G201191Z8-1C0-0.png)
#####  4.2 Evaluator
- **估值器（TypeEvaluator）作用**
- 设置动画 如何从初始值过渡到结束值的逻辑
- 插值器（Interpolator）决定值的变化模式（匀速、加速blabla）
- 估值器（TypeEvaluator）决定值的具体变化数值
- **看看接口TypeEvaluator 源代码**
```
public interface TypeEvaluator<T> {
    public T evaluate(float fraction, T startValue, T endValue);
}
```
**看看如何实现估值器**
```
public static ValueAnimator ofArgb(int... values) {
    ValueAnimator anim = new ValueAnimator();
    anim.setIntValues(values);
    anim.setEvaluator(ArgbEvaluator.getInstance());
    return anim;
}
//--------------------
public class ArgbEvaluator implements TypeEvaluator {
    private static final ArgbEvaluator sInstance = new ArgbEvaluator();
    public static ArgbEvaluator getInstance() {
        return sInstance;
    }
    // FloatEvaluator实现了TypeEvaluator接口
    public Object evaluate(float fraction, Object startValue, Object endValue) {
        // 参数说明
        // fraction：表示动画完成度（根据它来计算当前动画的值）
        // startValue、endValue：动画的初始值和结束值
        int startInt = (Integer) startValue;
        int startA = (startInt >> 24) & 0xff;
        int startR = (startInt >> 16) & 0xff;
        int startG = (startInt >> 8) & 0xff;
        int startB = startInt & 0xff;
        int endInt = (Integer) endValue;
        int endA = (endInt >> 24) & 0xff;
        int endR = (endInt >> 16) & 0xff;
        int endG = (endInt >> 8) & 0xff;
        int endB = endInt & 0xff;
        // 初始值 过渡 到结束值 的算法是：
        // 1. 用结束值减去初始值，算出它们之间的差值
        // 2. 用上述差值乘以fraction系数
        // 3. 再加上初始值，就得到当前动画的值
        return (int)((startA + (int)(fraction * (endA - startA))) << 24) |
                (int)((startR + (int)(fraction * (endR - startR))) << 16) |
                (int)((startG + (int)(fraction * (endG - startG))) << 8) |
                (int)((startB + (int)(fraction * (endB - startB))));
    }
}
```
#####  4.3 AnimatorSet
- **特点**
- 单一动画实现的效果相当有限，更多的使用场景是同时使用多种动画效果，即组合动画
- 使用方法
- **第一种方式：xml方式**
```
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:ordering="sequentially" >
    <!--表示Set集合内的动画按顺序进行-->
    <!--ordering的属性值:sequentially & together-->
    <!--sequentially:表示set中的动画，按照先后顺序逐步进行（a 完成之后进行 b ）-->
    <!--together:表示set中的动画，在同一时间同时进行,为默认值-->
    <set android:ordering="together" >
        <!--下面的动画同时进行-->
        <objectAnimator
            android:duration="2000"
            android:propertyName="translationX"
            android:valueFrom="0"
            android:valueTo="300"
            android:valueType="floatType" >
        </objectAnimator>
        <objectAnimator
            android:duration="3000"
            android:propertyName="rotation"
            android:valueFrom="0"
            android:valueTo="360"
            android:valueType="floatType" >
        </objectAnimator>
    </set>
    <set android:ordering="sequentially" >
        <!--下面的动画按序进行-->
        <objectAnimator
            android:duration="1500"
            android:propertyName="alpha"
            android:valueFrom="1"
            android:valueTo="0"
            android:valueType="floatType" >
        </objectAnimator>
        <objectAnimator
            android:duration="1500"
            android:propertyName="alpha"
            android:valueFrom="0"
            android:valueTo="1"
            android:valueType="floatType" >
        </objectAnimator>
    </set>
</set>
//关于代码中引用
AnimatorSet animator = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.animator.set_animation);
// 创建组合动画对象  &  加载XML动画
animator.setTarget(mButton);
// 设置动画作用对象
animator.start();
// 启动动画
```
- **第二种方式：Java方式**
```
// 步骤1：设置需要组合的动画效果
ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX); 
// 平移动画
ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f); 
// 旋转动画
ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f); 
// 透明度动画
// 步骤2：创建组合动画的对象
AnimatorSet animSet = new AnimatorSet(); 
// 步骤3：根据需求组合动画
animSet.play(translation).with(rotate).before(alpha); 
animSet.setDuration(5000); 
// 步骤4：启动动画
animSet.start();
``` 
- **常用方法**
``` 
AnimatorSet.play(Animator anim)   ：播放当前动画
AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行
AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行
AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行
AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行
``` 
#####  4.4 ValueAnimator
- **基本作用**
- 将初始值 以整型数值的形式 过渡到结束值 。即估值器是整型估值器 - IntEvaluator
ValueAnimator.oFloat（）采用默认的浮点型估值器 (FloatEvaluator)
ValueAnimator.ofInt（）采用默认的整型估值器（IntEvaluator）
- **第一种实现方式：Java设置**
``` 
public static ValueAnimator setValueAnimator(View view , int start , int end , int time , int delay , int count){
    // 步骤1：设置动画属性的初始值 & 结束值
    ValueAnimator mAnimator = ValueAnimator.ofInt(start, end);
    // ofInt（）作用有两个
    // 1. 创建动画实例
    // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和1,表示将值从0平滑过渡到1
    // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推
    // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值
    // 关于自定义插值器我将在下节进行讲解
    // 下面看看ofInt()的源码分析 ->>关注1
    mAnimator.setTarget(view);
    // 步骤2：设置动画的播放各种属性
    mAnimator.setDuration(time);
    // 设置动画运行的时长
    mAnimator.setStartDelay(delay);
    // 设置动画延迟播放时间
    mAnimator.setRepeatCount(count);
    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    mAnimator.setRepeatMode(ValueAnimator.RESTART);
    // 设置重复播放动画模式
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放
    // 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器
    // 设置 值的更新监听器
    // 即：值每次改变、变化一次,该方法就会被调用一次
    return mAnimator;
}
//-------
Button b1 = (Button) findViewById(R.id.b1);
ValueAnimator valueAnimator = AnimatorUtils.setValueAnimator(b1,0, 2, 2000, 500, 2);
valueAnimator.start();
``` 
- **第二种实现方式：XML设置**
``` 
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <animator
        android:valueFrom="0"
        android:valueTo="100"
        android:valueType="intType"
        android:duration="3000"
        android:startOffset ="1000"
        android:fillBefore = "true"
        android:fillAfter = "false"
        android:fillEnabled= "true"
        android:repeatMode= "restart"
        android:repeatCount = "0" android:interpolator="@android:anim/accelerate_interpolator"/>
        <!--初始值-->
        <!--结束值-->
        <!--变化值类型 ：floatType & intType-->
        <!--动画持续时间（ms），必须设置，动画才有效果-->
        <!--动画延迟开始时间（ms）-->
        <!--动画播放完后，视图是否会停留在动画开始的状态，默认为true-->
        <!--动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false-->
        <!--是否应用fillBefore值，对fillAfter值无影响，默认为true-->
        <!--选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|-->
        <!--重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复-->
        <!--插值器，即影响动画的播放速度,下面会详细讲-->
</set>
//代码引用
Button b3 = (Button) findViewById(R.id.b3);
Animator mAnim = AnimatorInflater.loadAnimator(this, R.animator.animator_1_0);
mAnim.setTarget(b3);
mAnim.start();
``` 
#####  4.5 ObjectAnimator
- **基本的原理**
- 直接对对象的属性值进行改变操作，从而实现动画效果
继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类
- **第一种实现方式：Java设置**
``` 
public static ObjectAnimator setObjectAnimator(View view , String type , int start , int end , long time){
    ObjectAnimator mAnimator = ObjectAnimator.ofFloat(view, type, start, end);
    // ofFloat()作用有两个
    // 1. 创建动画实例
    // 2. 参数设置：参数说明如下
    // Object object：需要操作的对象
    // String property：需要操作的对象的属性
    // float ....values：动画初始值 & 结束值（不固定长度）
    // 若是两个参数a,b，则动画效果则是从属性的a值到b值
    // 若是三个参数a,b,c，则则动画效果则是从属性的a值到b值再到c值
    // 以此类推
    // 至于如何从初始值 过渡到 结束值，同样是由估值器决定，此处ObjectAnimator.ofFloat（）是有系统内置的浮点型估值器FloatEvaluator，同ValueAnimator讲解

    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    mAnimator.setRepeatCount(ValueAnimator.INFINITE);
    // 设置动画运行的时长
    mAnimator.setDuration(time);
    // 设置动画延迟播放时间
    mAnimator.setStartDelay(0);
    // 设置重复播放动画模式
    mAnimator.setRepeatMode(ValueAnimator.RESTART);
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放
    //设置差值器
    mAnimator.setInterpolator(new LinearInterpolator());
    return mAnimator;
}
``` 
- **关于preperty的属性值有，如下表所示**
![Image.png](/uploads/userup/10585/1G201191Z8-4594-1.png)
- **第二种方式：XML方式**
``` 
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <ObjectAnimator
        android:valueFrom="1"
        android:valueTo="0"
        android:valueType="floatType"
        android:duration = "800"
        android:propertyName="alpha"/>
</set>
Animator mAnim = AnimatorInflater.loadAnimator(this, R.animator.animator_1_0);
mAnim.setTarget(fabHomeRandom);
mAnim.start();
``` 
- **注意，以XML方式，res的文件夹名称必须是animator，否则无法引用，如下所示：**
![Image.png](/uploads/userup/10585/1G201191Z8-4496-2.png)

#####  4.6 ValueAnimator与ObjectAnimator区别
- ValueAnimator 类是先改变值，然后手动赋值 给对象的属性从而实现动画；是间接对对象属性进行操作；
- ObjectAnimator 类是先改变值，然后自动赋值 给对象的属性从而实现动画；是直接对对象属性进行操作；

#####  4.7 监听动画器
- **说明**
- Animation类通过监听动画开始 / 结束 / 重复 / 取消时刻来进行一系列操作，如跳转页面等等
通过在Java代码里addListener（）设置
因Animator类、AnimatorSet类、ValueAnimator、ObjectAnimator类存在继承关系，所以AnimatorSet类、ValueAnimator、ObjectAnimator都可以使用addListener()监听器进行动画监听
- 看看第一种监听方式
``` 
mAnim.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {
        //动画开始时执行
    }
    @Override
    public void onAnimationEnd(Animator animation) {
        //动画结束时执行
    }
    @Override
    public void onAnimationCancel(Animator animation) {
        //动画取消时执行
    }
    @Override
    public void onAnimationRepeat(Animator animation) {
        //动画重复时执行
    }
});
``` 
- **看看这二中监听方式**
``` 
mAnim2.addListener(new AnimatorListenerAdapter() {
    // 向addListener()方法中传入适配器对象AnimatorListenerAdapter()
    // 由于AnimatorListenerAdapter中已经实现好每个接口
    // 所以这里不实现全部方法也不会报错
    @Override
    public void onAnimationCancel(Animator animation) {
        super.onAnimationCancel(animation);
        ToastUtils.showShort("动画结束了");
    }
});
``` 


