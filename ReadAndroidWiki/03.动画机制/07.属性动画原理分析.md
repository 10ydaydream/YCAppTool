



### 3.Animator运行原理和源码分析
#### 3.1 属性动画的基本属性
- 属性动画跟补间动画一样会包含动画相关的属性，如动画时长、动画播放次数、延迟时间、插间器等等，为了后面分析动画运行流程时概念更加明确，这里仅仅写了部分ValueAnimator源码中的字段，并做了相应的注解
    ```
    // 初始化函数是否被调用 
    boolean mInitialized = false; 
    // 动画时长 
    private long mDuration = (long)(300 * sDurationScale); 
    private long mUnscaledDuration = 300; 
    // 动画延时 
    private long mStartDelay = 0; 
    private long mUnscaledStartDelay = 0; 
    // 动画重复模式及次数 
    private int mRepeatCount = 0; 
    private int mRepeatMode = RESTART; 
    // 插间器
    private TimeInterpolator mInterpolator = sDefaultInterpolator; 
    // 动画开始运行的时间点 
    long mStartTime; 
    // 是否需要在掉帧的时候调整动画开始时间点 
    boolean mStartTimeCommitted; 
    // 动画是否反方向运行，当repeatMode=REVERSE是会每个动画周期反转一次 
    private boolean mPlayingBackwards = false;
    // 当前动画在一个动画周期中所处位置 
    private float mCurrentFraction = 0f; 
    // 动画是否延时 
    private boolean mStartedDelay = false; 
    // 动画完成延时的时间点 
    private long mDelayStartTime; 
    // 动画当前所处的状态：STOPPED, RUNNING, SEEKED 
    int mPlayingState = STOPPED; 
    // 动画是否被启动 
    private boolean mStarted = false; 
    // 动画是否被执行（以动画第一帧被计算为界） 
    private boolean mRunning = false; 
    
    // 回调监听器 
    // 确保AnimatorListener.onAnimationStart(Animator)仅被调用一次 
    private boolean mStartListenersCalled = false; 
    // start,end,cancel,repeat回调
    ArrayList<AnimatorListener> mListeners = null; 
    // pause, resume回调
    ArrayList<AnimatorPauseListener> mPauseListeners = null;  
    // value更新回调
    ArrayList<AnimatorUpdateListener> mUpdateListeners = null; 
    ```

#### 3.2 属性动画新的概念
- 属性动画相对于插间动画来件引入了一些新的概念
    - 可以暂停和恢复、可以调整进度，这些概念的引入，让动画的概念更加饱满起来，让动画有了视频播放的概念，主要有：
    ```
    // 动画是否正在running
    private boolean mRunning = false;
    // 动画是否被开始
    private boolean mStarted = false;
    // 动画是否被暂停 
    boolean mPaused = false; 
    // 动画暂停时间点，用于在动画被恢复的时候调整mStartTime以确保动画能优雅地继续运行 
    private long mPauseTime; 
    // 动画是否从暂停中被恢复，用于表明动画可以调整mStartTime
    private boolean mResumed = false; 
    // 动画被设定的进度位置
    float mSeekFraction = -1;
    ```


#### 3.3 PropertyValuesHolder作用
- PropertyValuesHolder是用来保存某个属性property对应的一组值，这些值对应了一个动画周期中的所有关键帧。
    - 动画说到底是由动画帧组成的，将动画帧连续起来就成了动画呢。
    - Animator可以设定并保存整个动画周期中的关键帧，然后根据这些关键帧计算出动画周期中任一时间点对应的动画帧的动画数据
    - 而每一帧的动画数据里都包含了一个时间点属性fraction以及一个动画值mValue，从而实现根据当前的时间点计算当前的动画值，然后用这个动画值去更新property对应的属性
    - **Animator被称为属性动画的原因，因为它的整个动画过程实际上就是不断计算并更新对象的属性**这个后面详细讲解。
- 那么保存property使用什么存储的呢？看代码可知：数组
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-0114b7d8c02df548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- PropertyValuesHolder由Property及Keyframes组成，其中Property用于描述属性的特征：如属性名以及属性类型，并提供set及get方法用于获取及设定给定Target的对应属性值；Keyframes由一组关键帧Keyframe组成，每一个关键帧由fraction及value来定量描述，于是Keyframes可以根据给定的fraction定位到两个关键帧，这两个关键帧的fraction组成的区间包含给定的fraction，然后根据定位到的两个关键帧以及设定插间器及求值器就可以计算出给定fraction对应的value。
    - PropertyValuesHolder的整个工作流程
        - 首先通过setObjectValues等函数来初始化关键帧组mKeyframes，必要的情况下（如ObjectAnimator）可以通过setStartValue及setEndValue来设定第一帧及最末帧的value，以上工作只是完成了PropertyValuesHolder的初始化，
        - 之后就可以由Animator在绘制动画帧的时候通过fraction来调用calculateValue计算该fraction对应的value（实际上是由mKeyframes的getValue方法做出最终计算），获得对应的value之后，一方面可以通过getAnimatedValue提供给Animator使用，
        - 另一方面也可以通过setAnimatedValue方法直接将该值设定到相应Target中去，这样PropertyValuesHolder的职责也就完成呢。


#### 3.4 属性动画start执行流程
- 首先看看start方法，默认是false，这个参数是干嘛的呢？这个参数是动画是否应该开始反向播放。
    - 启动动画播放。这个版本的start()使用一个布尔标志，指示动画是否应该反向播放。该标志通常为false，但如果从反向()方法调用，则可以将其设置为true。通过调用此方法启动的动画将在调用此方法的线程上运行。这个线程应该有一个活套(如果不是这样的话，将抛出一个运行时异常)。另外，如果动画将动画化视图层次结构中对象的属性，那么调用线程应该是该视图层次结构的UI线程。
    ```
    @Override
    public void start() {
        start(false);
    }
    
    private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        mReversing = playBackwards;
        mSelfPulse = !mSuppressSelfPulseRequested;
        if (playBackwards && mSeekFraction != -1 && mSeekFraction != 0) {
            if (mRepeatCount == INFINITE) {
                float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction));
                mSeekFraction = 1 - fraction;
            } else {
                mSeekFraction = 1 + mRepeatCount - mSeekFraction;
            }
        }
        mStarted = true;
        mPaused = false;
        mRunning = false;
        mAnimationEndRequested = false;
        mLastFrameTime = -1;
        mFirstFrameTime = -1;
        mStartTime = -1;
        addAnimationCallback(0);

        if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {
            startAnimation();
            if (mSeekFraction == -1) {
                setCurrentPlayTime(0);
            } else {
                setCurrentFraction(mSeekFraction);
            }
        }
    }
    ```
- 然后接着看addAnimationCallback(0)这行代码，从字面意思理解是添加动画回调callback
    - 可以看到通过getAnimationHandler()创建了一个AnimationHandler对象。
    - 然后在看看addAnimationFrameCallback()这个方法，看命名应该是专门处理动画相关的。实际上里面的逻辑大概是：通过Choreographer向底层注册下一个屏幕刷新信号监听，然后将需要运行的动画添加到列表中，如果延迟时间大于0，则说明动画是一个延迟开始的动画，那么加入Delay队列里。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-611bcf80a93bfebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-c06fa6fa856fdf8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 然后看看动画是用什么存储的呢？mAnimationCallbacks是一个ArrayList，每一项保存的是 AnimationFrameCallback 接口的对象，看命名这是一个回调接口
- AnimationHandler的作用主要是什么呢？
    - 是一个定时任务处理器，根据Choreographer的脉冲周期性地完成指定的任务，由于它是一个线程安全的静态变量，因此运行在同一线程中的所有Animator共用一个定时任务处理器，这样的好处在于：一方面可以保证Animator中计算某一时刻动画帧是在同一线程中运行的，避免了多线程同步的问题；另一方面，该线程下所有动画共用一个处理器，可以让这些动画有效地进行同步，从而让动画效果更加优雅。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-8481ef49cc8df2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 然后在回到start(boolean playBackwards)方法中，查看startAnimation()源码。
    - 内部调用，通过将动画添加到活动动画列表来启动动画。必须在UI线程上调用。
    - 通过notifyStartListeners()这个方法，刷新动画listener，也就是通知动画开始呢。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-a12162003f6d96c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看initAnimation()初始化动画操作逻辑
    - 在处理动画的第一个动画帧之前立即调用此函数。如果存在非零<code>startDelay</code>，则在延迟结束后调用该函数，它负责动画的最终初始化步骤。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-fe2776e70e6a304b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.5 属性动画cancel和end执行流程
- **先看看cancel中的源码**
    - 可以得知，cancel只会处理那些正在运行或者等待开始运行的动画，大概的处理逻辑是这样的：
        - 调用AnimatorListener.onAnimationCancel
        - 然后调用Animator.endAnimation
            - 通过removeAnimationCallback()把该动画从AnimationHandler的所有列表中清除
            - 调用AnimatorListener.onAnimationEnd
            - 复位动画所有状态：如mPlayingState = STOPPED、mRunning=false、mReversing = false、mStarted = false等等
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-0a3d919f0c017543.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-91e9d43f64aa5d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- **再看看end中的源码**
    - end相对于cancel来说有两个区别：一个是会处理所有动画；另一个是会计算最末一帧动画值。其具体的处理逻辑如下所示：
        - 若动画尚未开始：调用Animatior.startAnimation让动画处于正常运行状态
        - 计算最后一帧动画的动画值：animateValue(mPlayingBackwards ? 0f : 1f)
        - 结束动画就调用endAnimation这个方法，上面已经分析了该方法的作用
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-5cb0bbba1ac1a1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.6 属性动画pase和resume执行流程
- **先看看pause方法中的源码**
    - 先看在Animator中的pause方法，然后看ValueAnimator中的pause方法可知：
    - 仅仅在动画已开始（isStarted()==true）且当前为非暂停状态时才进行以下处理
        - 置位：mPaused = true
        - 循环遍历调用AnimatorPauseListener.onAnimationPause
        - 清空暂停时间：mPauseTime = -1
        - 复位mResumed = false
    ```
    //在ValueAnimator中
    public void pause() {
        boolean previouslyPaused = mPaused;
        super.pause();
        if (!previouslyPaused && mPaused) {
            mPauseTime = -1;
            mResumed = false;
        }
    }
    
    //在Animator中
    public void pause() {
        if (isStarted() && !mPaused) {
            mPaused = true;
            if (mPauseListeners != null) {
                ArrayList<AnimatorPauseListener> tmpListeners =
                        (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onAnimationPause(this);
                }
            }
        }
    }
    ```
    - 做完这些处理之后，等下一帧动画的到来，当doAnimationFrame被调用，此时若仍然处于暂停状态，就会做如下截击
        - 这样就阻止了动画的正常运行，并记录下来动画暂停的时间，确保恢复之后能让动画调整到暂停之前的动画点正常运行，具体怎么起作用就要看resume的作用。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-3bffba42cdadef07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- **先看看resume方法中的源码**
    - 先看在ValueAnimator中的resume方法，然后看Animator中的resume方法可知：
        - 置位：mResumed = true
        - 复位：mPaused = false
        - 调用AnimatorPauseListener.onAnimationResume
    ```
    //在ValueAnimator中
    @Override
    public void resume() {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be resumed from the same " +
                    "thread that the animator was started on");
        }
        if (mPaused && !mResumed) {
            mResumed = true;
            if (mPauseTime > 0) {
                addAnimationCallback(0);
            }
        }
        super.resume();
    }
    
    //在Animator中
    public void resume() {
        if (mPaused) {
            mPaused = false;
            if (mPauseListeners != null) {
                ArrayList<AnimatorPauseListener> tmpListeners =
                        (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onAnimationResume(this);
                }
            }
        }
    }
    ```
    - 当doAnimationFrame被调用，此时若处于恢复状态（mResume==true），就会做如下补偿处理
        - 这样就让暂停的时间从动画的运行过程中消除
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-1b43530b23fa712b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.7 属性动画与View结合
- 属性动画如何去实现View的变换？
    - 是根据计算出来的动画值去修改View的属性，如alpha、x、y、scaleX、scaleY、translationX、translationY等等，这样当View重绘时就会产生作用，随着View连续不断地被重绘，就会产生绚烂多彩的动画。
- 接着看setTarget这个方法源码
    - 如果是使用ValueAnimator类，那么直接通过mAnimator.setTarget(view)设置view
    - 如果是使用ObjectAnimator，那么直接通过ObjectAnimator.ofFloat(view, type, start, end)设置view，最终还是会调用setTarget方法。注意ObjectAnimator实现了ValueAnimator类
    - ObjectAnimator是可以在动画帧计算完成之后直接对Target属性进行修改的属性动画类型，相对于ValueAnimator来说更加省心省力
- 相比ValueAnimator类，ObjectAnimator还做了许多操作，ObjectAnimator与 ValueAnimator类的区别： 
    - ValueAnimator 类是先改变值，然后 手动赋值 给对象的属性从而实现动画；是 间接 对对象属性进行操作；
    - ObjectAnimator 类是先改变值，然后 自动赋值 给对象的属性从而实现动画；是 直接 对对象属性进行操作；
- 个人感觉属性动画源码分析十分具有跳跃性。不过还好没有关系，只需要理解其大概运作原理就可以呢。






