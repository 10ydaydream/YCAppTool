






##  6.Android动画框架原理解析
#####  6.1 关于补间动画原理
- 要了解Android动画是如何加载出来的,我们首先要了解Android View 是如何组织在一起的.每个窗口是一颗View树. RootView是DecorView,在布局文件中声明的布局都是DecorView的子View.是通过setContentView来设置进入窗口内容的. 因为View的布局就是一棵树.所以绘制的时候也是按照树形结构来遍历每个View进行绘制.ViewRoot.java中 draw函数准备好Canvas后 调用 mView.draw(canvas),这里的mView是DecorView.
- **下面看一下递归绘制的几个步骤:**
- 1.绘制背景
- 2.如果需要,保存画布(canvas),为淡入淡出做准备
- 3.通过调用View.onDraw(canvas)绘制View本身的内容
- 4.通过 dispatchDraw(canvas)绘制自己的孩子,dispatchDraw->drawChild->child.draw(canvas) 这样的调用过程被用来保证每个子 View 的 draw 函数都被调用
- 5.如果需要，绘制淡入淡出相关的内容并恢复保存的画布所在的层（layer）
- 6.绘制修饰的内容（例如滚动条）
- 当一个 ChildView 要重画时，它会调用其成员函数 invalidate() 函数将通知其 ParentView 这个 ChildView 要重画，这个过程一直向上遍历到 ViewRoot，当 ViewRoot 收到这个通知后就会调用上面提到的 ViewRoot 中的 draw 函数从而完成绘制。Android 动画就是通过 ParentView 来不断调整 ChildView 的画布坐标系来实现的





### 2.Animation运行原理和源码分析
#### 2.1 基本属性介绍
- 上一篇文章已经对补间动画做了详细的说明，不过这里还是需要重复说一下动画属性的作用
    - mStartTime：动画实际开始时间
    - mStartOffset：动画延迟时间
    - mFillEnabled：mFillBefore及mFillAfter是否使能
    - mFillBefore：动画结束之后是否需要进行应用动画
    - mFillAfter：动画开始之前是否需要进行应用动画
    - mDuration：单次动画运行时长
    - mRepeatMode：动画重复模式（RESTART、REVERSE）
    - mRepeatCount：动画重复次数（INFINITE，直接值）
    - mInterceptor：动画插间器
    - mBackgroundColor：动画背景颜色
    - mListener：动画开始、结束、重复回调监听器



#### 2.2 如何计算动画数据
- 首先进入Animation类，然后找到getTransformation方法，主要是分析这个方法逻辑，如图所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-d999c70a98e8b17f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 那么这个方法中做了什么呢？Animation在其getTransformation函数被调用时会计算一帧动画数据，而上面这些属性基本都是在计算动画数据时有相关的作用。
- 第一步：若startTime为START_ON_FIRST_FRAME(值为-1)时，将startTime设定为curTime
- 第二步：计算当前动画进度：
    - normalizedTime = (curTime - (startTime + startOffset))/duration
    - 若mFillEnabled==false：将normalisedTime夹逼至[0.0f, 1.0f]
- 第三步：判断是否需要计算动画数据：
    - 若normalisedTime在[0.0f, 1.0f]，需计算动画数据
    - 若normalisedTime不在[0.0f, 1.0f]：
        - normalisedTime<0.0f, 仅当mFillBefore==true时才计算动画数据
        - normalisedTime>1.0f, 仅当mFillAfter==true时才计算动画数据
- 第四步：若需需要计算动画数据：
    - 若当前为第一帧动画，触发mListener.onAnimationStart
    - 若mFillEnabled==false：将normalisedTime夹逼至[0.0f, 1.0f]
    - 根据插间器mInterpolator调整动画进度：
    - interpolatedTime = mInterpolator.getInterpolation(normalizedTime)
    - 若动画反转标志位mCycleFlip为true，则
    - interpolatedTime = 1.0 - normalizedTime
    - 调用动画更新函数applyTransformation(interpolatedTime, transformation)计算出动画数据
- 第五步：若夹逼之前normalisedTime大于1.0f, 则判断是否需继续执行动画：
    - 已执行次数mRepeatCount等于需执行次数mRepeated
        - 若未触发mListener.onAnimationEnd，则触发之
    - 已执行次数mRepeatCount不等于需执行次数mRepeated
        - 自增mRepeatCount
        - 重置mStartTime为-1
        - 若mRepeatMode为REVERSE，则取反mCycleFlip
        - 触发mListener.onAnimationRepeat



#### 2.3 什么是动画更新函数
- 下面我们来看一下getTransformation方法中的这一行代码applyTransformation(interpolatedTime, outTransformation)，然后进去看看这个方法。如下所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-220a227e0fd51206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 这个方法的用途是干啥呢？从这个英文解释中可以得知：getTransform的助手。子类应该实现这一点，以应用给定的内插值来应用它们的转换。该方法的实现应该总是替换指定的转换或文档，而不是这样做的。
- 都知道Animation是个抽象类，接着我们这些逗比程序员可以看看它的某一个子类，比如看看ScaleAnimation中的applyTransformation方法吧。
    - 是否设定缩放中心点： 
        - 若mPivotX==0 且 mPivotY==0：transformation.getMatrix().setScale(sx, sy)
        - 否则：transformation.getMatrix().setScale(sx, sy, mPivotX, mPivotY)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-eb1b0b527f74dd92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 介绍到这里还是没有讲明白它的具体作用，它是在什么情况下调用的。不要着急，接下来会慢慢分析的……



#### 2.4 动画数据如何存储
- 可以看到applyTransformation(float interpolatedTime, Transformation t)这个方法中带有一个Transformation参数，那么这个参数是干啥呢？
    - 实际上，Animation的动画函数getTransformation目的在于生成当前帧的一个Transformation，这个Transformation采用alpha以及Matrix存储了一帧动画的数据，Transformation包含两种模式：
        - alpha模式：用于支持透明度动画
        - matrix模式：用于支持缩放、平移以及旋转动画
    - 同时，Transformation还提供了许多两个接口用于组合多个Transformation：
        - compose：前结合（alpha相乘、矩阵右乘、边界叠加）
        - postCompose：后结合（alpha相乘、矩阵左乘、边界叠加



#### 2.5 Animation的调用
- getTransformation这个函数究竟是在哪里调用的？计算得到的动画数据又是怎么被应用的？为什么Animation这个包要放在android.view下面以及Animation完成之后为什么View本身的属性不会被改变。慢慢看……
    - 要了解Animation，先从要从Animation的基本使用View.startAnimation开始寻根溯源：如下所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-a71aeb172fbdb3d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看看setStartTime这个方法，主要是设置一些属性。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-545bd4bfbc357959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看看setAnimation(animation)方法源码
    - 设置要为此视图播放的下一个动画。如果希望动画立即播放，请使用{@link#startAnimation(android.view.animation.Animation)}代替此方法，该方法允许对启动时间和无效时间进行细粒度控制，但必须确保动画具有启动时间集，并且当动画应该启动时，视图的父视图(控制子视图上的动画)将失效。
    ```
    public void setAnimation(Animation animation) {
        mCurrentAnimation = animation;
        if (animation != null) {
            if (mAttachInfo != null && mAttachInfo.mDisplayState == Display.STATE_OFF
                    && animation.getStartTime() == Animation.START_ON_FIRST_FRAME) {
                animation.setStartTime(AnimationUtils.currentAnimationTimeMillis());
            }
            animation.reset();
        }
    }
    ```
- 接着重点看一下invalidate(true)这个方法
    - 通过invalidate(true)函数会触发View的重新绘制，那么在View.draw是怎么走到对Animation的处理函数呢？
    ```
    View.draw(Canvas)
    —> ViewGroup.dispatchDraw(Canvas)
    —> ViewGroup.drawChild(Canvas, View, long)
    —> View.draw(Canvas, ViewGroup, long)
    —> View.applyLegacyAnimation(ViewGroup, long, Animation, boolean)
    ```
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-29e13cbca350f60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看看View中applyLegacyAnimation这个方法
    ```
    private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime,
            Animation a, boolean scalingRequired) {
        Transformation invalidationTransform;
        final int flags = parent.mGroupFlags;
        //判断Animation是否初始化
        final boolean initialized = a.isInitialized();
        //如果没有初始化，则进行初始化
        if (!initialized) {
            a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());
            a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop);
            if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler);
            //由父视图组调用，通知当前与此视图关联的动画的开始。如果重写此方法，则始终调用Super.on动画Start()；
            onAnimationStart();
        }
    
        //获取Transformation对象
        final Transformation t = parent.getChildTransformation();
        //获取要在指定时间点应用的转换，这个方法最终调用了Animation中的getTransformation方法
        //调用getTransformation根据当前绘制事件生成Animation中对应帧的动画数据
        boolean more = a.getTransformation(drawingTime, t, 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (parent.mInvalidationTransformation == null) {
                parent.mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = parent.mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = t;
        }
    
        //下面主要是，根据动画数据设定重绘制区域
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & ViewGroup.FLAG_INVALIDATE_REQUIRED) == 0) {
                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    //调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域
                    parent.invalidate(mLeft, mTop, mRight, mBottom);
                }
            } else {
                if (parent.mInvalidateRegion == null) {
                    parent.mInvalidateRegion = new RectF();
                }
                final RectF region = parent.mInvalidateRegion;
                a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region,
                        invalidationTransform);
                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
    
                final int left = mLeft + (int) region.left;
                final int top = mTop + (int) region.top;
                
                //调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域
                parent.invalidate(left, top, left + (int) (region.width() + .5f),
                        top + (int) (region.height() + .5f));
            }
        }
        return more;
    }
    ```
    - View.applyLegacyAnimation就是Animation大显神通的舞台，其核心代码主要分三个部分
        - 初始化Animation（仅初始化一次）
            - 调用Animation.initialize(width, height, parentWidth, parentHeight)，通过View及ParentView的Size来解析Animation中的相关数据；
            - 调用Animation.initializeInvalidateRegion(left, top, right, bottom)来设定动画的初始区域，并在fillBefore为true时计算Animation动画进度为0.0f的数据
        - 调用getTransformation根据当前绘制事件生成Animation中对应帧的动画数据
        - 根据动画数据设定重绘制区域
            - 若仅为Alpha动画，此时动画区域为View的当前区域，且不会产生变化
            - 若包含非Alpha动画，此时动画区域需要调用Animation.getInvalidateRegion进行计算，该函数会根据上述生成动画数据Thransformation中的Matrix进行计算，并与之前的动画区域执行unio操作，从而获取动画的完整区域
            - 调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域
- 当View.applyLegacyAnimation调用完成之后，View此次绘制的动画数据就构建完成，之后便回到View.draw(Canvas, ViewGroup, long)应用动画数据对视图进行绘制刷新，如下所示：
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-5f622fe2456db362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 重点看到Animation产生的动画数据实际并不是应用在View本身的，而是应用在RenderNode或者Canvas上的，这就是为什么Animation不会改变View的属性的根本所在。另一方面，我们知道Animation仅在View被绘制的时候才能发挥自己的价值，这也是为什么插间动画被放在Android.view包内。








