#### 目录介绍
- 01.Xposed学习前须知
- 02.Class文件介绍



### 01.Xposed学习前须知
- 研究 Xposed 之后，我决定把虚拟机方面的东西也来研究一番。学习的三个终极问题：学什么？怎么学？学到什么程度为止？关于这三个问题，以本次研究的情况来看，回答如下：
    - 学习目标是：按顺序是 dalvik 虚拟机，然后是 Xposed 针对 dalvik 的实现，然后是 art 虚拟机。
    - 学习方法：VM 原理配合具体实现，以代码为主。Java VM 有一套规范，各公司具体的 VM 实现必须遵守此规范。所以对 VM 学习而言，规范很重要，它是不变的，而代码实现只不过是该规范的一种实现罢了。这里也直接体现了我提出的关于专业知识学习的一句警语“基于 Android，高于 Android”。对 VM 而言，先掌握规范才是最最重要和核心的事情。
    - 学到什么程度为止：对于 dalvik 虚拟机，我们以学会一段 Java 程序从代码，到字节码，最后到如何被 VM 加载并运行它为止。对于 XPosed，基于 dalvik+selinux 环境的代码我们会全部分析。



### 02.Class文件介绍
#### 2.1 Class 文件结构总览
- Class 文件是理解 Vm 实现的关键。关于 Class 文件的结构，这里介绍的内容直接参考 JVM 规范，因为它是最权威的资料。
    - Oracle 的 JVM SE7 官方规范： https://docs.oracle.com/javase/specs/jvms/se7/html/
- 作为分析 Class 文件的入口，在 Demo 示例中提供了一个特别简单的例子，代码如下所示：
    ``` java
    public class TestMain {
        public int mX = 0;
        public static void main(String[] arg){
            TestMain testMain = new TestMain();
            testMain.test();
        }
        public TestMain(){
    
        }
        public void test(){
            return;
        }
    }
    ```
- Class 文件到底是什么东西？我觉得一种通俗易懂的解释就是：
    - *.java 文件是人编写的，给人看的。
    - *.class 是通过工具处理 *.java 文件后的产物，它是给 VM 看的，给 VM 操作的
- VM 使用的 class 文件，其内部结构是怎样的呢？
    - Jvm 规范很聪明，它通过一个 C 的数据结构表达了 class 文件结构，下图为图2。
    - ![image](https://static001.infoq.cn/resource/image/12/5c/12ee39024fe7e6efb5ca17b25a491e5c.png)
- ClassFile 这个数据结构比较容易理解。
    - 比如，类的是 public 的还是 final 的，还是 interface，就由 access_flags 来表示。其具体取值我觉得都不用管，代码中用得是名字诸如 ACC_XXX 这样得的标志位来表示，一看知道是啥玩意儿。
    - Java 类中定义的域（成员变量），方法等都有对应的数据结构来表达，而且还是个数组。
    - 唯一有点特别之处的是常量池。什么东西会放在常量池呢？最容易想到的就是字符串了。对头，这个 Java 源码中的类名，方法名，变量名，居然都是以字符串形式存储在常量池中。所以，图 2 中的 this_class 和 super_class 分别指向两个字符串，代表本类的名字和基类的名字。这两个字符串存储在常量池中，所以 this_class 和 super_class 的类型都是 u2（索引，代表长度为 2 个字节）。
- Class 文件用 javap 工具可以很好得解析成上图那样的格式。下面代码为图3。
    - 解析方法为：javap -verbose xxxx.class
    ```java
    yangchong:~ yangchong$ javap -verbose /Users/yangchong/yc/Demo/a/YCMagiskTool/ZxgPulgin/src/main/java/com/yc/zxgpulgin/TestMain.class 
    Classfile /Users/yangchong/yc/Demo/a/YCMagiskTool/ZxgPulgin/src/main/java/com/yc/zxgpulgin/TestMain.class
      Last modified 2021-1-19; size 399 bytes
      MD5 checksum eb794ff7bb3a52b2ceff57841ce26240
      Compiled from "TestMain.java"
    public class com.yc.zxgpulgin.TestMain
      minor version: 0
      major version: 52
      flags: ACC_PUBLIC, ACC_SUPER
    Constant pool:
       #1 = Class              #18            // com/yc/zxgpulgin/TestMain
       #2 = Methodref          #1.#19         // com/yc/zxgpulgin/TestMain."<init>":()V
       #3 = Methodref          #1.#20         // com/yc/zxgpulgin/TestMain.test:()V
       #4 = Methodref          #6.#19         // java/lang/Object."<init>":()V
       #5 = Fieldref           #1.#21         // com/yc/zxgpulgin/TestMain.mX:I
       #6 = Class              #22            // java/lang/Object
       #7 = Utf8               mX
       #8 = Utf8               I
       #9 = Utf8               main
      #10 = Utf8               ([Ljava/lang/String;)V
      #11 = Utf8               Code
      #12 = Utf8               LineNumberTable
      #13 = Utf8               <init>
      #14 = Utf8               ()V
      #15 = Utf8               test
      #16 = Utf8               SourceFile
      #17 = Utf8               TestMain.java
      #18 = Utf8               com/yc/zxgpulgin/TestMain
      #19 = NameAndType        #13:#14        // "<init>":()V
      #20 = NameAndType        #15:#14        // test:()V
      #21 = NameAndType        #7:#8          // mX:I
      #22 = Utf8               java/lang/Object
    {
      public int mX;
        descriptor: I
        flags: ACC_PUBLIC
    
      public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
          stack=2, locals=2, args_size=1
             0: new           #1                  // class com/yc/zxgpulgin/TestMain
             3: dup
             4: invokespecial #2                  // Method "<init>":()V
             7: astore_1
             8: aload_1
             9: invokevirtual #3                  // Method test:()V
            12: return
          LineNumberTable:
            line 8: 0
            line 9: 8
            line 10: 12
    
      public com.yc.zxgpulgin.TestMain();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=2, locals=1, args_size=1
             0: aload_0
             1: invokespecial #4                  // Method java/lang/Object."<init>":()V
             4: aload_0
             5: iconst_0
             6: putfield      #5                  // Field mX:I
             9: return
          LineNumberTable:
            line 12: 0
            line 5: 4
            line 14: 9
    
      public void test();
        descriptor: ()V
        flags: ACC_PUBLIC
        Code:
          stack=0, locals=1, args_size=1
             0: return
          LineNumberTable:
            line 17: 0
    }
    SourceFile: "TestMain.java"
    ```


#### 2.2 常量池介绍
- 常量池看起来陌生，其实简单得要死。
    - 注意，count_pool_count 是常量池数组长度 +1。比如，假设某个 Class 文件常量池只有 4 个元素，那么 count_pool_count=5）。
    - javap 解析 class 文件的时候，常量池的索引从 1 算起,0 默认是给 VM 自己用得, 一般不显示 0 这一项。这也是为什么图 3 中常量池第一个元素以#1 开头。所以，如果 count_pool_count=5 的话，真正有用的元素是从 count_pool[1] 到 count_pool[4]。
- 常量池数组的元素类型由下面的代码表示：
    ``` java
    cp_info { // 特别注意，这是介绍的 cp_info 是相关元素类型的通用表达。
        u1 tag;   //tag 为 1 个字节长。不论 cp_info 具体是哪种，第一个字节一定代表 tag
        u1 info[]; // 其他信息，长度随 tag 不同而不同
    }
    
    //tag 取值，先列几个简单的：
    tag=7 <==info 代表这个 cp_info 是 CONSTANT_Class_info 结构体
    tag=9<==info 代表 CONSTANT_Fieldrefs_info 结构体
    tag=10<==info 代表 CONSTANT_Methodrefs_info 结构体
    tag=8<==info 代表 CONSTANT_String_info 结构体
    tag=1<==info 代表 CONSTANT_Utf8_info 结构体
    ```
- 在 JVM 规范中，真正代表字符串的数据结构是 CONSTANT_Utf8_info 结构体，它的结构如下代码所示：
    ```
    CONSTANT_Utf8_info {
        u1 tag;
        u2 length;  // 下面就是存储 UTF8 字符串的地方了
        u1 bytes[length];
    }
    ```
- 下面看几个常用的常量池元素类型
    - （1） CONSTANT_Class_info
        - 这个类型是用于描述类信息的，此处的类信息很简单，就是类名（也就是代表类名的字符串）
        ```
        CONSTANT_Class_info {
            u1 tag;   //tag 取值为 7，代表 CONSTANT_Class_info
            u2 name_index;  //name_index 表示代表自己类名的字符串信息位于于常量池数组中哪一个，也就是索引
        }
        ```
        - name_index 对应的那个常量池元素必须是 CONSTANT_Utf8_info，也就是字符串。图 3 中的例子，咱们再看看：
            - #1 = Class #2 //com/test/TestMain
            - #2 = Utf8 com/test/TestMain
        - 这说明：
            - 常量池第一个元素类型为 Class_info，它对应的 name_index 取值为 2，表示使用第 2 个元素
            - 常量池第二个元素类型为 Utf8 内容为“com/test/TestMain”
            - #1 最后的 // 表示注释，它把第二行的字符串内容直接搬过来，方便我们查看
    - （2） CONSTANT_NameAndType_Info
        - 这个结构也是常量池数据结构中中比较重要的一个，干什么用得呢？恩，它用来描述方法 / 成员名以及类型信息的。有点 JNI 基础的童鞋相信不难明白，在 JNI 中，一个类的成员函数或成员变量都可以由这个类名字符串 + 函数名字符串 + 参数类型字符串 + 返回值类型来确定（如果是成员变量，就是类名字符串 + 变量名字符串 + 类型字符串）来表达。既然是字符串，那么 NameAndType_Info 也就是存储了对应字符串在常量池数组中的索引：
            ```
            CONSTANT_NameAndType_info {
               u1 tag;
               u2 name_index;  // 方法名或域名对应的字符串索引
               u2 descriptor_index; // 方法信息（参数 + 返回值），或者成员变量的信息（类型）对应的字符串索引
            }
            // 还是来看图 3 中的例子吧
            #13 = Utf8  ()V
            #15 = NameAnType  #16.#13  // 合起来就是 test.()V 函数名是 test，参数和返回值是 ()V
            #16=Utf8 test
            ```
        - 请自行解析#25 这个常量池元素的内容，一定要做喔！注意，对于构造函数和类初始化函数来说，JVM 要求函数名必须是和。当然，这两个函数是编译器生成的。
    - （3） CONSTANT_MethodrefInfo 三兄弟
        - Methodref_Info 还有两个兄弟，分别是 Fieldref_Info，InterfaceMethodref_Info，他们三用于描述方法、成员变量和接口信息。刚才的 NameAndType_Info 其实已经描述了方法和成员变量信息的一部分，唯一还缺的就是没有地方描述它们属于哪个类。而咱这三兄弟就补全了这些信息。他们三的数据结构如图 4 所示：



#### 2.3 Field 和 Method 描述
- 在常量池介绍中有提到 Methodref_Info 和 Fieldref_Info
    - 这两个 Info 无非是描述了函数或成员变量的名字，参数，类型等信息。但是真正的方法、成员变量信息还包括比如访问权限，注解，源代码位置等。对于方法来说，更重要的还包括其函数功能（即这个函数对应的字节码）。
    - 在 Java VM 中，方法和成员变量的完整描述由如图 5 所示的数据结构来表达的：
    - ![image](https://static001.infoq.cn/resource/image/cf/bb/cf17781e58062d6a2a964ae15792a9bb.png)
        - access_flags：描述诸如 final，static，public 这样的访问标志
        - name_index：方法或成员变量名在常量池中对应的索引，类型是 Utf8_Info
        - attribute_info：是域或方法中很重要的信息。
- attribute_info 介绍.
    - attribute_info 结构体很简单，如下代码所示：
        ```
        attribute_info {// 特别注意，这里描述的 attribute_info 结构体也是具体属性数据结构的通用表达
            u2 attribute_name_index;  //attribute_info 的描述，指向常量池的字符串
            u4 attribute_length;  // 具体的内容由 info 数组描述
            u1 info[attribute_length];
        }
        ```
- Java VM 规范中，attribute 类型比较多，我们重点介绍几个，先来看代表一个函数实际内容的 Code 属性。
    - （1） Code 属性
    - ![image](https://static001.infoq.cn/resource/image/62/b4/626f99eef716f32f639c658f528bafb4.png)
        - 前 2 个成员变量就不多说了。属于 attribute 的头 6 个字节，分别指向代表属性名字符串的常量池元素以及后续属性数据的长度。注意，Code 属性的 attribute_name_index 所指向的那个 Utf8 常量池元素对应的字符串内容就是“Code”，大家可参考图 3 的#9。
        - max_stack 和 max_locals：虚拟机在执行一个函数的时候，会为它建立一个操作数栈。执行过程中的参数啊，一些计算值啊等都会压入栈中。max_stack 就表示该函数执行时，这个栈的最大深度。这是编译时就能确定的。max_locals 用于描述这个方法最大的栈数和最大的本地变量个数。本地变量个数包括传入的参数。
        - code_length 和 code：这个函数编译成 Java 字节码后对应的字节码长度和内容。
        - exception_table_length：用来描述该方法对应异常处理的信息。这块我不打算讲了，其实也蛮简单，就是用 start_pc 表示异常处理时候从此方法对应字节码（由 code[] 数组表示）哪个地方开始执行。
        - Code 属性本身还能包含一些属性，这是由 attributes_count 和 attributes 数组决定的。
    - 来看个实际例子吧，如图 7 所示（接着图 3 的例子）：
    - ![image](https://static001.infoq.cn/resource/image/49/a5/49d5394926ad8b5ace0bfc688abe0ca5.png)
        - stack=2，locals=2，args_size=1。结合代码，main 函数确实有一个参数，而且还有一个本地变量。注意，main 函数是 static 的。如果对于类的非 static 函数，那么 locals 的第 0 个元素代表 this。
        - stack 后面接下来的就是 code 数组，也就是这个函数对应的执行代码。0 表示 code[] 的索引位置。0:new：代表这个操作是 new 操作，此操作对应的字节码长度为 3，所以下一个操作对应的字节码从索引 3 开始。
        - LineNumberTable 也是属性的一种，用于调试，它将源码和字节码匹配了起来。比如 line 7: 0 这句话代表该函数字节码 0 那一个操作对应代码的第 7 行。
        - LocalVariableTable：它也是属性一种，用于调试，它用于描述函数执行时的变量信息。比如图 7 中的 Start = 0：表示从 code[] 第 0 个字节开始，Length = 13 表示到从 start=0 到 start+13 个字节（不包含第 13 个字节，因为 code 数组一共就 12 个字节）这段范围内，这个变量都有效（也就是这个变量的作用域），Slot=0 表示这个变量在本地变量表中第一个元素，还记得前面提到的 locals 吗？，name 为“args”，表示这个参数的名字叫 args，类型（由 Signature 表示）就是 String 数组了。






















