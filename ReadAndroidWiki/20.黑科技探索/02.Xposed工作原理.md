#### 目录介绍
- 01.Xposed使用方法
- 02.Xposed原理概述
- 03.Android zygote 进程
- 04.Xposed对zygote修改
- 05.ART的方法Hook




### 01.Xposed使用方法
- 在对 Xposed 进行分析之前，先回顾一下 Xposed 基本 API 的使用。Xposed 的核心用法就是对一个 Java 方法进行 Hook，它的典型调用如下：
    ```java
    public class TestApplicationPulgin implements IXposedHookLoadPackage {
        @Override
        public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
            XposedBridge.log("------开始执行------");
            if (lpparam.packageName.equals("com.yc.xposeddemo")){
                XposedBridge.log("------开始hook------");
                XposedHelpers.findAndHookMethod(Application.class, "onCreate", Context.class,
                        new XC_MethodHook() {
                            @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                                Application app = (Application) param.thisObject;
                                Context context = (Context) param.args[0];
                                XposedBridge.log("Application#onCreate(Context); this: " + app + " arg: " + context);
                                param.setResult(null);
                            }
    
                            @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                                super.afterHookedMethod(param);
                            }
                        });
            }
        }
    }
    ```
- 上面这段代码
    - 以上代码的意思是对 Application 这个类的 onCreate 方法进行 Hook，并使用 XC_MethodHook 对象提供一个 Hook 处理方法来接管原来方法的逻辑，当应用的 Application 类型的 onCreate 方法被调用时，beforeHookedMethod 将在被调用之前执行，同时 onCreate 的参数将会传递给 beforeHookedMethod 方法进行处理，上面的处理只是将参数打印了出来（一个 Context），同时还可以拿到被调用的 this 目标对象，也就是 Application 的对象，还可以使用 setResult 方法更改原始方法的返回值，不过这里的 Application#onCreate 方法是 void 返回类型的，setResult 不起作用，如果是其他类型，那么原方法的返回值将被更改。
- findAndHookMethod
    - 可以看到，如果要使用 Xposed 对一个 Java 方法进行 Hook，需要提供要 Hook 方法的名字、参数列表类型和方法所在类，以及处理 Hook 的回调方法。



### 02.Xposed原理概述
- Xposed 是一个 Hook 框架，它提供了对任意 Android 应用的 Java 方法进行 Hook 的一种方法，通常它的使用方法如下：
    - 首先按照 Xposed 官网提供的开发规范编写一个 Xposed 模块，它是一个普通的 Android 应用，包含一块开发者自己定义的代码，这块代码有能力通过 Xposed 框架提供的 Hook API 对任意应用的 Java 方法进行 Hook。
    - 在要启用 Xposed 的 Android 设备上安装 Xposed 框架和这个 Xposed 模块，然后在 Xposed 框架应用中启用这个 Xposed 模块，重新启动设备后，Xposed 模块将被激活，当任意的应用运行起来后，Xposed 模块的 Hook 代码将会在这个应用进程中被加载，然后执行，从而对这个应用的 Java 方法进行指定 Hook 操作。
- 那么根据以上使用方法实现一个 Xposed 框架需要分成如下几个部分：
    - 提供用于 Hook 操作的 API，为了让开发者进行模块开发。它通常是一个 jar 包；
    - 提供一个具有界面的管理器应用，用于安装和管理 Xposed 本身和 Xposed 模块；
    - **提供将代码加载到每一个应用进程中的能力，目的是支持 Xposed 模块的代码在进程中使用 Xposed API 进行 Hook 操作**；
    - **提供 Hook 任意 Java 方法的能力，为 Xposed 模块的调用提供支持，当 Xposed 模块在应用进程中执行时可对方法进行 Hook**。
- 前两点对于我们开发者来说都很熟悉，没有什么难点，后面两点才是实现 Xposed 的核心。
    - 首先是 Xposed 怎样实现的将代码加载到每一个应用进程中（Xposed 是基于 Root 权限实现的，所以有修改 Android 系统的能力）？
    - Xposed 是通过修改系统 zygote 进程的实现将代码注入应用进程中的。



### 03.Android zygote 进程
- zygote 进程说明
    - 是 Android 系统中第一个拥有 Java 运行环境的进程，它是由用户空间 1 号进程 init 进程通过解析 init.rc 文件创建出来的，从 init 进程 fork 而来。
    - zygote 进程是一个孵化器。Android 系统中所有运行在 Java 虚拟机中的系统服务以及应用均由 zygote 进程孵化而来。
    - ygote 通过克隆（fork）的方式创建子进程，fork出来的子进程将继承父进程的所有资源，基于这个特性，zygote 进程在启动过程将创建JavaART虚拟机，预加载一个Java进程需要的所有系统资源，之后子进程被创建后，就可以直接使用这些资源运行了。
- zygote 不再是一个进程
    - 自 Android 5.0 系统开始，zygote 不再是一个进程，而是两个进程，一个是 32 位 zygote，负责孵化 32 位进程（为了兼容使用了 armeabi 和 armeabi-v7a 等 32 位架构的本地动态库的应用），另一个是 64 位 zygote 进程，负责孵化 64 位应用进程（可加载 arm64-v8a 等 64 位架构本地库）。
- 看下zygote相关的rc文件
    - init 进程是 Android 系统中的 pid 为 1 的进程，是用户空间的第一个进程，它会在 Android 系统启动时被内核创建出来，之后会对 init.rc 文件进行解析，init.rc 文件是一个按照特定规则编写的脚本文件，init进程通过解析它的规则来创建对应的服务进程。下面看一下 zygote 相关的 rc 文件的内容。
    - 注：自 Android 5.0 开始，32 位 zygote 启动内容在 init.zygote32.rc 文件中，64 位 zygote 启动内容在 init.zygote64.rc 中。
    - 注：自 Android 9.0 开始，两个 zygote 启动配置放在一个文件中 init.zygote64_32.rc。
    - 这里看一下 Android 8.1 系统的 32 位 zygote 的 rc 文件内容：
    ```java
    # init.zygote32.rc
    
    service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
        class main
        socket zygote stream 660 root system
        onrestart write /sys/android_power/request_state wake
        onrestart write /sys/power/state on
        onrestart restart media
        onrestart restart netd
        writepid /dev/cpuset/foreground/tasks
    ```
    - 上面的含义是，创建一个名为 zygote 的服务进程，它的可执行文件在 /system/bin/app_process 中，后面的 -Xzygote、/system.bin 等是可执行文件的 main 函数将要接收的参数。



### 04.Xposed对zygote修改
- Xposed对zygote进程如何修改
    - Xposed 对 zygote 进程的实现源码进行修改后，重新编译出 app_process 可执行文件，替换了系统的 app_process 文件（包括 64 位 zygote），并在其中加载了 XposedBridge.jar 这个 Dex 代码包，它包含 Xposed 的 Java 层实现代码和提供给 Xposed 模块的 API 代码，那么当 init 进程启动 zygote 服务进程时，将执行修改过的 app_process 文件，此时 zygote 进程就具有了 Xposed 的代码，Xposed 可以进行加载 Xposed 模块代码等任意操作了。
    - 所有 Android 应用都是运行在 Java 虚拟机上的，所有的 Android 应用都是 zygote 的子进程，那么当 Android 应用进程启动后，将具备 zygote 进程加载的所有资源，从而将 Xposed 代码继承到了 Android 应用进程中，实现了将 Xposed 代码加载到每一个进程中的目的。
- 如何实现对应用中 Java 方法的 Hook
    - Hook 的基本原理如下，将Java方法的原始逻辑，转接到一个中间处理方法上，这个处理方法会对原始 Java 方法的参数进行转发，转发到一个用于处理 Hook 的方法上（即 XC_MethodHook 的实现），等处理 Hook的方法执行自定义逻辑后（自定义逻辑可选择调用原始逻辑先获取原始返回值，再处理），再返回新的返回值。
    - ![image](https://img-blog.csdnimg.cn/20201011222917778.png)



### 05.ART的方法Hook
- 基于 ART 的 Hook 方案相比 Dalvik 要复杂一些，需要重新修改编译 ART 虚拟机的源码，重新编译出 ART 虚拟机的可执行文件 libart.so，替换 Android 系统中的 ART 虚拟机实现。
- 它的核心原理就是直接修改一个方法对应的汇编代码的地址，让方法直接跳转到指定地址执行，然后就可以执行自定义的逻辑进行 Hook 处理了。
- ART 虚拟机为了提高执行效率，采用了 AOT（Ahead Of Time，预编译） 模式运行，在应用运行之前先将整个 APK 包含的 Java 编译为二进制代码，然后应用运行时将执行每个方法对应的机器代码，比采用 JIT（Just In Time Compiler，即时编译） 的 Dalvik 虚拟机每次在运行时才编译代码执行的效率更高。
- 前面的过程和 Dalvik 一样，都需要在 Hook 一个指定方法时，提供要 Hook 方法的名字、参数列表类型和方法所在类型，和一个用于处理 Hook 的回调，这个回调用于修改原始方法的逻辑。
- 接下来 Xposed 取得这个方法的反射表示对象，它是一个 java.lang.reflect.Method 对象，然后和用于处理 Hook 的回调一起传递给 Xposed 的 Native 层代码，Native 层代码使用 ArtMethod 的一个静态转换方法，将 Java 层的反射对象 Method 转换为一个 ART 中用于表示一个 Java 方法的 ArtMethod 对象，获取这个表示被 Hook 的 Java 方法的 ArtMethod 对象后，会创建它的副本对象用于备份，备份目的是可以在可是的时候再调用原始方法，然后给这个 ArtMethod 对象重新设置汇编代码的地址，这个地址指向一段汇编代码，这个汇编代码是一段蹦床代码（Trampoline），会跳入原本用于处理 Java 动态代理的方法的函数，Xposed 对其进行了修改，在其中加入了处理 Hook 的逻辑，也就是转发被 Hook 方法的参数给处理 Hook 的回调方法，让 Hook 回调方法处理被 Hook 方法的逻辑，从而完成 Hook。至此就完成了 ART 中的 Hook 处理。
- 那么调用一个被 Hook 的方法的过程是：当一个 Android 应用内代码调用一个被 Hook 的方法时，ART 将会对方法代码进行执行，首先这个 Java 方法在 ART 虚拟机中将使用一个 ArtMethod 对象表示，然后进入 ART 的 Java 方法执行函数中，会跳入一段蹦床代码中进行执行，这段蹦床代码又会跳入这个 ArtMethod 对象设置的汇编代码地址处，从而执行到 Xposed 用于处理 Hook 的代码中，之后完成 Hook 逻辑。
















