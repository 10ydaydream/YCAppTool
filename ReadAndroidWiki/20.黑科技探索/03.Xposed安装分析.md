#### 目录介绍
- 01.Xposed的安装







### 01.Xposed的安装
- 首先从 Xposed 的安装开始分析，这部分代码的实现在 XposedInstaller 中。
    - 在一台 Root 过的设备上安装 XposedInstaller 后打开，点击主页的“INSTALL/UPDATE”，会弹出一个对话框，选择“Install”或“Install via recovery”安装 Xposed 框架，此时会首先进行框架核心文件的下载，进入 StatusInstallerFragment#download 方法中：
    ```
    // StatusInstallerFragment.java
    
    private void download(Context context, String title, FrameworkZips.Type type, final RunnableWithParam<File> callback) {
        OnlineFrameworkZip zip = FrameworkZips.getOnline(title, type);
        new DownloadsUtil.Builder(context)
                .setTitle(zip.title)
    	        // 设置下载 url
                .setUrl(zip.url)
                .setDestinationFromUrl(DownloadsUtil.DOWNLOAD_FRAMEWORK)
                .setCallback(new DownloadFinishedCallback() {
                    @Override
                    public void onDownloadFinished(Context context, DownloadInfo info) {
                        // 下载完成，触发回调
                        LOCAL_ZIP_LOADER.triggerReload(true);
                        callback.run(new File(info.localFilename));
                    }
                })
                .setMimeType(DownloadsUtil.MIME_TYPES.ZIP)
                .setDialog(true)
                .download();
    }
    ```
- 其中 zip.url 为 Xposed 框架压缩包的下载地址，我们重点关注安装，所以这里简要描述 zip 对象，zip 是 OnlineFrameworkZip 类的对象，表示一个 Xposed 框架包，它包含 title、type 和 url 三个成员，type 有两种，Installer 和 Uninstaller，即安装包和卸载包，都是包含刷机脚本的 Xposed 补丁包（就是上面工作流程中的压缩包），title 有三种，Xposed 测试版、Xposed 正式版、和 Uninstaller，用于界面显示。上面的 zip.url 在 Android 8.1 的 Pixel 手机上运行出来是 http://dl-xda.xposed.info/framework/sdk27/arm64/xposed-v90-sdk27-arm64-beta3.zip，这个 url 是根据设备支持的 CPU 架构、系统版本和 Xposed 当前最新版本组合出来的，组合规则由一个 framework.json 提供，它的本地路径是 /data/data/de.robv.android.xposed.installer/cache/framework.json，是从 http://dl-xda.xposed.info/framework.json 解析后得到的，内容如下：
    ```
    {
      "zips": [
        {
          "title": "Version 90-beta$(version)",
          "url": "http://dl-xda.xposed.info/framework/sdk$(sdk)/$(arch)/xposed-v90-sdk$(sdk)-$(arch)-beta$(version).zip",
          "versions": [
            { "version": "3", "current": true },
            { "version": "2" },
            { "version": "1" }
          ],
          "archs": ["arm", "arm64", "x86"],
          "sdks" : [26, 27]
        },
        {
          "title": "Version $(version)",
          "url": "http://dl-xda.xposed.info/framework/sdk$(sdk)/$(arch)/xposed-v$(version)-sdk$(sdk)-$(arch).zip",
          "versions": [
            { "version": "89", "current": true },
            { "version": "88.2" },
            { "version": "88.1" },
            { "version": "88" },
            ...
          ],
          "archs": ["arm", "arm64", "x86"],
          "sdks" : [21, 22, 23, 24, 25],
          "exclude": [
            {
              "versions": ["88.1"],
              "sdks": [21, 22, 23]
            },
            {
              "versions": ["78", "79", "80", "81", "82", "83", "84", "85", "86", "87"],
              "sdks": [24, 25]
            },
            ...
          ]
        },
        {
          "title": "Uninstaller ($(version))",
          "url": "http://dl-xda.xposed.info/framework/uninstaller/xposed-uninstaller-$(version)-$(arch).zip",
          "type": "uninstaller",
          "versions": [
            { "version": "20180117", "current": true },
            { "version": "20180108" },
            ...
          ],
          "archs": ["arm", "arm64", "x86"],
          "sdks" : [21, 22, 23, 24, 25, 26, 27]
        }
      ]
    }
    ```
- 能看到，其中包含了 Xposed 测试版、Xposed 正式版、和 Xposed 的 Uninstaller 三种 title 的下载信息，每个下载信息中的 url 为下载地址的模板，versions 为可用的版本，根据系统信息和 Xposed 版本对 url 模板进行填充后组成下载地址。
    - 回到上面的下载，下载成功后，将进入回调根据用户选择的安装类型进行安装，看一下回调的实现：
    ```
    // StatusInstallerFragment.java
    
    if (action == ACTION_FLASH) {
        runAfterDownload = new RunnableWithParam<File>() {
            @Override
            public void run(File file) {
                // 直接刷入
                flash(context, new FlashDirectly(file, type, title, false));
            }
        };
    } else if (action == ACTION_FLASH_RECOVERY) {
        runAfterDownload = new RunnableWithParam<File>() {
            @Override
            public void run(File file) {
                // 依赖 recovery 模式进行刷入
                flash(context, new FlashRecoveryAuto(file, type, title));
            }
        };
    } else if (action == ACTION_SAVE) {
        runAfterDownload = new RunnableWithParam<File>() {
            @Override
            public void run(File file) {
                // 仅保存
                saveTo(context, file);
            }
        };
    }
    ```

上面两个分支分别对应 Install 和 Install via recovery 两种安装方式的实现，flash 方法将会启动一个新的负责展示安装执行的界面，然后执行传入的 Flashable 对象的 flash 方法，执行成功后展示一个对话框，询问用户是否重启，重启后将激活 Xposed。分别看一下两种 Flashable 的实现。

```
直接刷入
// FlashDirectly.java

public void flash(Context context, FlashCallback callback) {
    ZipCheckResult zipCheck = openAndCheckZip(callback);
    if (zipCheck == null) {
        return;
    }

    // 获取压缩包文件
    ZipFile zip = zipCheck.getZip();
    if (!zipCheck.isFlashableInApp()) {
        triggerError(callback, FlashCallback.ERROR_NOT_FLASHABLE_IN_APP);
        closeSilently(zip);
        return;
    }

    // 释放 update-binary 文件至 cache 目录中
    ZipEntry entry = zip.getEntry("META-INF/com/google/android/update-binary");
    File updateBinaryFile = new File(XposedApp.getInstance().getCacheDir(), "update-binary");
    try {
        AssetUtil.writeStreamToFile(zip.getInputStream(entry), updateBinaryFile, 0700);
    } catch (IOException e) {
        Log.e(XposedApp.TAG, "Could not extract update-binary", e);
        triggerError(callback, FlashCallback.ERROR_INVALID_ZIP);
        return;
    } finally {
        closeSilently(zip);
    }

    // 使用 Root 身份执行刷入命令
    RootUtil rootUtil = new RootUtil();
    if (!rootUtil.startShell(callback)) {
        return;
    }

    callback.onStarted();

    rootUtil.execute("export NO_UIPRINT=1", callback);
    if (mSystemless) {
        rootUtil.execute("export SYSTEMLESS=1", callback);
    }

    // 执行 update-binary 文件
    int result = rootUtil.execute(getShellPath(updateBinaryFile) + " 2 1 " + getShellPath(mZipPath), callback);
    if (result != FlashCallback.OK) {
        triggerError(callback, result);
        return;
    }

    callback.onDone();
}
```


直接刷入会直接使用 Root 身份执行 update-binary 可执行文件，其中会调用 flash-script.sh 文件，它将压缩包中的目录复制到对应的系统目录中，同名文件进行覆盖，在覆盖前会对原始系统文件进行备份，例如 libart.so.orig.gz，为了在卸载时恢复。

刷入后正常重启系统，系统在启动时将会加载自定义的 app_process 可执行文件，启动了带有 Xposed 框架代码的定制版 zygote 服务进程，为 Xposed 提供支持。

```
使用 recovery 刷入
// FlashRecoveryAuto.java

@Override
public void flash(Context context, FlashCallback callback) {
    ZipCheckResult zipCheck = openAndCheckZip(callback);
    if (zipCheck == null) {
        return;
    } else {
        closeSilently(zipCheck.getZip());
    }

    final String zipName = mZipPath.getName();
    String cmd;

    // 执行刷入命令
    RootUtil rootUtil = new RootUtil();
    if (!rootUtil.startShell(callback)) {
        return;
    }

    callback.onStarted();

    // 确认 /cache/recovery/ 目录存在
    if (rootUtil.execute("ls /cache/recovery", null) != 0) {
        callback.onLine(context.getString(R.string.file_creating_directory, "/cache/recovery"));
        if (rootUtil.executeWithBusybox("mkdir /cache/recovery", callback) != 0) {
            callback.onError(FlashCallback.ERROR_GENERIC,
                    context.getString(R.string.file_create_directory_failed, "/cache/recovery"));
            return;
        }
    }

    // 复制 zip 到 /cache/recovery/ 目录
    callback.onLine(context.getString(R.string.file_copying, zipName));
    cmd = "cp -a " + RootUtil.getShellPath(mZipPath) + " /cache/recovery/" + zipName;
    if (rootUtil.executeWithBusybox(cmd, callback) != 0) {
        callback.onError(FlashCallback.ERROR_GENERIC,
                context.getString(R.string.file_copy_failed, zipName, "/cache/recovery"));
        return;
    }

    // 将刷机命令写入 /cache/recovery/command 文件中
    callback.onLine(context.getString(R.string.file_writing_recovery_command));
    cmd = "echo --update_package=/cache/recovery/" + zipName + " > /cache/recovery/command";
    if (rootUtil.execute(cmd, callback) != 0) {
        callback.onError(FlashCallback.ERROR_GENERIC,
                context.getString(R.string.file_writing_recovery_command_failed));
        return;
    }

    callback.onLine(context.getString(R.string.auto_flash_note, zipName));
    callback.onDone();
}
```


通过 recovery 模式进行刷入就是首先复制压缩包到 /cache/recovery/ 中，然后向 /cache/recovery/command 文件中写入一条刷入压缩包的命令，然后询问用户是否重启至 recovery 模式，当系统处于 recovery 模式后将会自动检测 command 文件是否存在，如果存在将执行其中的指令，然后执行刷机包提供的脚本，过程和上面直接刷入一致，首先执行 update-binary 可执行文件，然后其中会调用 flash-script.sh 文件，将刷机包中的文件进行复制。此时，系统退出 reocvery 正常重启后将会加载成功 Xposed。

这里就分析完了安装，主要是通过刷入文件将系统关键组件替换为 Xposed 修改过的实现。

下面开始分析 Xposed 的启动，当系统启动后，init 进程将会通过解析 init.rc 文件后执行 app_process 创建 zygote 进程，此时就进入了 Xposed 重新编译修改过的 app_process 文件中。

Xposed 启动
这部分的实现代码在项目 Xposed 中，是使用 C++ 代码编写的，如果这些代码出现崩溃，则会卡在开机界面，即 boot loop 情况。

Xposed 的 app_process 分为 Dalvik 和 ART 两种实现，这里只关注 ART 的实现，在 app_main2.cpp 中。
```
Native 层
入口为 main 函数：

// app_main2.cpp

int main(int argc, char* const argv[])
{
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {
        if (errno != EINVAL) {
            LOG_ALWAYS_FATAL("PR_SET_NO_NEW_PRIVS failed: %s", strerror(errno));
            return 12;
        }
    }

    // 1. 处理 xposed 测试选项
    if (xposed::handleOptions(argc, argv)) {
        return 0;
    }

    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    argc--;
    argv++;

    int i;
    for (i = 0; i < argc; i++) {
        if (argv[i][0] != '-') {
            break;
        }
        if (argv[i][1] == '-' && argv[i][2] == 0) {
            ++i; // Skip --.
            break;
        }
        runtime.addOption(strdup(argv[i]));
    }

    bool zygote = false;
    bool startSystemServer = false;
    bool application = false;
    String8 niceName;
    String8 className;

    ++i;
    while (i < argc) {
        const char* arg = argv[i++];
        if (strcmp(arg, "--zygote") == 0) {
            zygote = true;
            niceName = ZYGOTE_NICE_NAME;
        } else if (strcmp(arg, "--start-system-server") == 0) {
            startSystemServer = true;
        } else if (strcmp(arg, "--application") == 0) {
            application = true;
        } else if (strncmp(arg, "--nice-name=", 12) == 0) {
            niceName.setTo(arg + 12);
        } else if (strncmp(arg, "--", 2) != 0) {
            className.setTo(arg);
            break;
        } else {
            --i;
            break;
        }
    }

    Vector<String8> args;
    if (!className.isEmpty()) {
        args.add(application ? String8("application") : String8("tool"));
        runtime.setClassNameAndArgs(className, argc - i, argv + i);
    } else {
        maybeCreateDalvikCache();

        if (startSystemServer) {
            args.add(String8("start-system-server"));
        }

        char prop[PROP_VALUE_MAX];
        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {
            LOG_ALWAYS_FATAL("app_process: Unable to determine ABI list from property %s.",
                ABI_LIST_PROPERTY);
            return 11;
        }

        String8 abiFlag("--abi-list=");
        abiFlag.append(prop);
        args.add(abiFlag);

        for (; i < argc; ++i) {
            args.add(String8(argv[i]));
        }
    }

    if (!niceName.isEmpty()) {
        runtime.setArgv0(niceName.string());
        set_process_name(niceName.string());
    }

    // 2.
    if (zygote) {
        // 初始化 xposed
        isXposedLoaded = xposed::initialize(true, startSystemServer, NULL, argc, argv);
        // #define XPOSED_CLASS_DOTS_ZYGOTE "de.robv.android.xposed.XposedBridge"
        // 初始化成功则会 XposedBridge 流程，否则进入系统的 ZygoteInit 中
        runtimeStart(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : "com.android.internal.os.ZygoteInit", args, zygote);
    } else if (className) {
        // 非 zygote 进程流程，用于支持使用命令行启动自定义的类，这里先不关心这个流程
        isXposedLoaded = xposed::initialize(false, false, className, argc, argv);
        runtimeStart(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : "com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
        return 10;
    }
}
```


通过对比原版的 ART 代码，发现 main 函数中只有 1 和 2 两处代码进行了修改，当 init 进程解析 init.rc 文件时，会启动 zygote 进程，此时就进入了 app_process 的 main 函数中，并将 init.rc 中附带的选项使用 argv 参数传递进来。

先看第一处 handleOptions：
```
// xposed.cpp

bool handleOptions(int argc, char* const argv[]) {
    parseXposedProp();

    if (argc == 2 && strcmp(argv[1], "--xposedversion") == 0) {
        printf("Xposed version: %s\n", xposedVersion);
        return true;
    }

    if (argc == 2 && strcmp(argv[1], "--xposedtestsafemode") == 0) {
        printf("Testing Xposed safemode trigger\n");

        if (detectSafemodeTrigger(shouldSkipSafemodeDelay())) {
            printf("Safemode triggered\n");
        } else {
            printf("Safemode not triggered\n");
        }
        return true;
    }

    argBlockStart = argv[0];
    uintptr_t start = reinterpret_cast<uintptr_t>(argv[0]);
    uintptr_t end = reinterpret_cast<uintptr_t>(argv[argc - 1]);
    end += strlen(argv[argc - 1]) + 1;
    argBlockLength = end - start;

    return false;
}
```


处理了 --xposedversion 和 --xposedtestsafemode 两个参数，不过查看 init.rc 文件中启动 zygote 的选项中并没有这两项：

service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
...
1
2
所以应该是用于 Xposed 的测试代码，那么这里就不再关心。

继续下面第 2 部分，在 zygote 流程中，首先会初始化 Xposed，如果初始化成功就会传入 XposedBridge 的完整类名，用于进入 Java 层的 XposedBridge 入口。

首先看 xposed::initialize 函数：
```
bool initialize(bool zygote, bool startSystemServer, const char* className, int argc, char* const argv[]) {
#if !defined(XPOSED_ENABLE_FOR_TOOLS)
    if (!zygote)
        return false;
#endif

    // 判断系统是否处于 minmal framework 模式，此时 /data 是 tmpfs 类型，无法加载 Xposed
    if (isMinimalFramework()) {
        ALOGI("Not loading Xposed for minimal framework (encrypted device)");
        return false;
    }

    // 保存相关参数
    // xposed 是一个用于共享信息的对象，XposedShared* xposed = new XposedShared;
    xposed->zygote = zygote;
    xposed->startSystemServer = startSystemServer;
    xposed->startClassName = className;
    xposed->xposedVersionInt = xposedVersionInt;

#if XPOSED_WITH_SELINUX
    xposed->isSELinuxEnabled   = is_selinux_enabled() == 1;
    xposed->isSELinuxEnforcing = xposed->isSELinuxEnabled && security_getenforce() == 1;
#else
    xposed->isSELinuxEnabled   = false;
    xposed->isSELinuxEnforcing = false;
#endif  // XPOSED_WITH_SELINUX

    if (startSystemServer) {
        xposed::logcat::printStartupMarker();
    } else if (zygote) {
        // 给另一个架构的优先执行的 zygote 进程一些时间启动，从而避免同时打印日志，造成难以阅读
        sleep(10);
    }

    // 打印 Xposed 版本和 Device、ROM 等信息，开机时可以在 logcat 中看到
    printRomInfo();

    if (startSystemServer) {
        // 确保 XposedInstaller uid 和 gid 存在，即表示安装了 XposedInstaller
        // 启动 XposedService 服务
        if (!determineXposedInstallerUidGid() || !xposed::service::startAll()) {
            return false;
        }
        xposed::logcat::start();
#if XPOSED_WITH_SELINUX
    } else if (xposed->isSELinuxEnabled) {
        if (!xposed::service::startMembased()) {
            return false;
        }
#endif  // XPOSED_WITH_SELINUX
    }

#if XPOSED_WITH_SELINUX
    if (xposed->isSELinuxEnabled) {
        xposed::service::membased::restrictMemoryInheritance();
    }
#endif  // XPOSED_WITH_SELINUX

    if (zygote && !isSafemodeDisabled() && detectSafemodeTrigger(shouldSkipSafemodeDelay()))
        disableXposed();

    if (isDisabled() || (!zygote && shouldIgnoreCommand(argc, argv)))
        return false;

    // 将 XposedBridge.jar 加入系统 CLASSPATH 变量，使其代码中的类可被加载
    return addJarToClasspath();
}
```


以上代码主要是保存了 app_process 的启动选项，设置一些 xposed 支持，最后使用 addJarToClasspath 将 XposedBridge.jar 加入系统路径。

```
// xposed.cpp
bool addJarToClasspath() {
    ALOGI("-----------------");
    // #define XPOSED_JAR "/system/framework/XposedBridge.jar"
    if (access(XPOSED_JAR, R_OK) == 0) {
        if (!addPathToEnv("CLASSPATH", XPOSED_JAR))
            return false;

        ALOGI("Added Xposed (%s) to CLASSPATH", XPOSED_JAR);
        return true;
    } else {
        ALOGE("ERROR: Could not access Xposed jar '%s'", XPOSED_JAR);
        return false;
    }
}
```


这里就初始化完成了，如果中间有一步执行失败，返回 false，那么 Xposed 就不能正常工作了，会通过传递 ZygoteInit 完整类名，进入系统正常的 zygote 流程。

现在回到 main 函数中，下面进入 runtimeStart：
```
// app_main2.cpp
static void runtimeStart(AppRuntime& runtime, const char *classname, const Vector<String8>& options, bool zygote)
{
#if PLATFORM_SDK_VERSION >= 23
  runtime.start(classname, options, zygote);
#else
  // try newer variant (5.1.1_r19 and later) first
  void (*ptr1)(AppRuntime&, const char*, const Vector<String8>&, bool);
  *(void **) (&ptr1) = dlsym(RTLD_DEFAULT, "_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEEb");

  if (ptr1 != NULL) {
    ptr1(runtime, classname, options, zygote);
    return;
  }

  // fall back to older variant
  void (*ptr2)(AppRuntime&, const char*, const Vector<String8>&);
  *(void **) (&ptr2) = dlsym(RTLD_DEFAULT, "_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEE");

  if (ptr2 != NULL) {
    ptr2(runtime, classname, options);
    return;
  }

  // should not happen
  LOG_ALWAYS_FATAL("app_process: could not locate AndroidRuntime::start() method.");
#endif
}
```


其实就是直接调用系统 AppRuntime 的 start 函数，如果是 Android 5.1.1 之前需要通过通过获取 AppRuntime::start 函数符号句柄的方式调用，后面一长串字符串是函数被编译后的签名字符串。

调用 AppRuntime::start 后，内部会创建 Java 虚拟机，然后执行传入类的 main 函数：
```
// AndroidRuntime.cpp
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
  ALOGD(">>>>>> START %s uid %d <<<<<<\n",
          className != NULL ? className : "(unknown)", getuid());

  static const String8 startSystemServer("start-system-server");
  // ...

  JniInvocation jni_invocation;
  jni_invocation.Init(NULL);
  JNIEnv* env;
  // 创建虚拟机
  if (startVm(&mJavaVM, &env, zygote) != 0) {
    return;
  }
  onVmCreated(env);
  // 注册系统类 JNI 方法
  if (startReg(env) < 0) {
    ALOGE("Unable to register all android natives\n");
    return;
  }
  
  // ...
  
  // 转换为 JNI 格式类名：com/android/internal/os/XposedBridge
  char* slashClassName = toSlashClassName(className);
  jclass startClass = env->FindClass(slashClassName);
  if (startClass == NULL) {
    ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
  } else {
    jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
       "([Ljava/lang/String;)V");
    if (startMeth == NULL) {
      ALOGE("JavaVM unable to find main() in '%s'\n", className);
    } else {
      // 调用 XposedBridge.main();
      env->CallStaticVoidMethod(startClass, startMeth, strArray);
    }
  }

  // ...
}
```


Java 层
下面就进入到了 Java 层的 XposedBridge#main 方法中：

```
// XposedBridge.java
protected static void main(String[] args) {
  // Initialize the Xposed framework and modules
  try {
    // 判断 native 加载成功
    if (!hadInitErrors()) {
      // Xposed 相关初始化
      initXResources();
      // SELinux 相关支持
      SELinuxHelper.initOnce();
      SELinuxHelper.initForProcess(null);

      // runtime 表示 ART 还是 Dalivk
      runtime = getRuntime();
      XPOSED_BRIDGE_VERSION = getXposedVersion();

      if (isZygote) {
        // 为资源的 Hook 注册回调
        XposedInit.hookResources();
        // 为代码 Hook 注册回调，将会调用每个 Xposed 模块的入口
        XposedInit.initForZygote();
      }

      // 加载设备上的 Xposed 模块
      XposedInit.loadModules();
    } else {
      Log.e(TAG, "Not initializing Xposed because of previous errors");
    }
  } catch (Throwable t) {
    Log.e(TAG, "Errors during Xposed initialization", t);
    disableHooks = true;
  }

  // 调用系统正常流程 Java 层
  if (isZygote) {
    ZygoteInit.main(args);
  } else {
    RuntimeInit.main(args);
  }
}
```


重点关注 XposedInit.initForZygote(); 和 XposedInit.loadModules();：
```
/*package*/ static void initForZygote() throws Throwable {
  // ...

  // system_server 初始化
  if (Build.VERSION.SDK_INT < 21) {
    findAndHookMethod("com.android.server.ServerThread", null,
        Build.VERSION.SDK_INT < 19 ? "run" : "initAndLoop", new XC_MethodHook() {
          @Override
          protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
            SELinuxHelper.initForProcess("android");
            loadedPackagesInProcess.add("android");

            XC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);
            lpparam.packageName = "android";
            lpparam.processName = "android"; // it's actually system_server, but other functions return this as well
            lpparam.classLoader = XposedBridge.BOOTCLASSLOADER;
            lpparam.appInfo = null;
            lpparam.isFirstApplication = true;
            XC_LoadPackage.callAll(lpparam);
          }
        });
  } 
  // ...

  hookAllConstructors(LoadedApk.class, new XC_MethodHook() {
    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
      LoadedApk loadedApk = (LoadedApk) param.thisObject;

      String packageName = loadedApk.getPackageName();
      XResources.setPackageNameForResDir(packageName, loadedApk.getResDir());
      if (packageName.equals("android") || !loadedPackagesInProcess.add(packageName))
        return;

      if (!getBooleanField(loadedApk, "mIncludeCode"))
        return;

      XC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);
      lpparam.packageName = packageName;
      lpparam.processName = AndroidAppHelper.currentProcessName();
      lpparam.classLoader = loadedApk.getClassLoader();
      lpparam.appInfo = loadedApk.getApplicationInfo();
      lpparam.isFirstApplication = false;
      XC_LoadPackage.callAll(lpparam);
    }
  });

  // ...
}
```

上面省略了一部分代码，上面的代码主要是通过 Hook 系统关键类的流程，为 Xposed 模块注册加载代码包的回调，当这些系统流程执行时，会通过 XC_LoadPackage.callAll(lpparm) 通知所有的 Xposed 模块。

上面创建了 XC_LoadPackage.LoadPackageParam 的对象，就是为了给 Xposed 模块的入口进行传递。

XposedBridge.sLoadedPackageCallbacks 是 Xposed 模块回调的集合，是一个 CopyOnWriteSortedSet<XC_LoadPackage> 类型。

XC_LoadPackage 有一个 call 方法，用于回调自己的 handleLoadPackage 方法。

```
// XC_LoadPackage.java

@Override
protected void call(Param param) throws Throwable {
  if (param instanceof LoadPackageParam)
    handleLoadPackage((LoadPackageParam) param);
}
```


XC_LoadPackage.callAll 将会调用每一个 XC_LoadPackage 的 call 方法，从而向 Xposed 模块传递 lpparm 参数。

```
// XC_LoadPackage.java

public static void callAll(Param param) {
  if (param.callbacks == null)
    throw new IllegalStateException("This object was not created for use with callAll");

  for (int i = 0; i < param.callbacks.length; i++) {
    try {
      ((XCallback) param.callbacks[i]).call(param);
    } catch (Throwable t) { XposedBridge.log(t); }
  }
}
```


Xposed 模块加载
再来看 XposedInit.loadModules();：
```
// XposedInit.java

/*package*/ static void loadModules() throws IOException {
  // 从 modules.list 文件读取 Xposde 模块列表
  final String filename = BASE_DIR + "conf/modules.list";
  BaseService service = SELinuxHelper.getAppDataFileService();
  if (!service.checkFileExists(filename)) {
    Log.e(TAG, "Cannot load any modules because " + filename + " was not found");
    return;
  }

  ClassLoader topClassLoader = XposedBridge.BOOTCLASSLOADER;
  ClassLoader parent;
  while ((parent = topClassLoader.getParent()) != null) {
    topClassLoader = parent;
  }

  InputStream stream = service.getFileInputStream(filename);
  BufferedReader apks = new BufferedReader(new InputStreamReader(stream));
  String apk;
  while ((apk = apks.readLine()) != null) {
    // 加载每个 Xposed 模块
    loadModule(apk, topClassLoader);
  }
  apks.close();
}
```

```
// XposedInit.java

private static void loadModule(String apk, ClassLoader topClassLoader) {
  Log.i(TAG, "Loading modules from " + apk);

  // ...

  DexFile dexFile;
  try {
    dexFile = new DexFile(apk);
  } catch (IOException e) {
    Log.e(TAG, "  Cannot load module", e);
    return;
  }

  // ...

  ZipFile zipFile = null;
  InputStream is;
  try {
    zipFile = new ZipFile(apk);
    // 打开 Xposed 模块 apk 文件中的 xposed_init 文件，
    // 它的内容是 Xposed 模块入口类的全类名
    ZipEntry zipEntry = zipFile.getEntry("assets/xposed_init");
    if (zipEntry == null) {
      Log.e(TAG, "  assets/xposed_init not found in the APK");
      closeSilently(zipFile);
      return;
    }
    is = zipFile.getInputStream(zipEntry);
  } catch (IOException e) {
    Log.e(TAG, "  Cannot read assets/xposed_init in the APK", e);
    closeSilently(zipFile);
    return;
  }

  ClassLoader mcl = new PathClassLoader(apk, XposedBridge.BOOTCLASSLOADER);
  BufferedReader moduleClassesReader = new BufferedReader(new InputStreamReader(is));
  try {
    String moduleClassName;
    // 获取 Xposed 模块入口类名
    while ((moduleClassName = moduleClassesReader.readLine()) != null) {
      moduleClassName = moduleClassName.trim();
      if (moduleClassName.isEmpty() || moduleClassName.startsWith("#"))
        continue;

      try {
        Log.i(TAG, "  Loading class " + moduleClassName);
        // 加载入口类
        Class<?> moduleClass = mcl.loadClass(moduleClassName);

        // ...

        final Object moduleInstance = moduleClass.newInstance();
        if (XposedBridge.isZygote) {
          if (moduleInstance instanceof IXposedHookZygoteInit) {
            IXposedHookZygoteInit.StartupParam param = new IXposedHookZygoteInit.StartupParam();
            param.modulePath = apk;
            param.startsSystemServer = startsSystemServer;
            ((IXposedHookZygoteInit) moduleInstance).initZygote(param);
          }

          // 根据模块关心代码 Hook 还是资源 Hook 分别处理

          if (moduleInstance instanceof IXposedHookLoadPackage)
            // 注册到 sLoadedPackageCallbacks 中
            XposedBridge.hookLoadPackage(new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance));

          if (moduleInstance instanceof IXposedHookInitPackageResources)
            // 注册资源的 Xposed 模块回调
            XposedBridge.hookInitPackageResources(new IXposedHookInitPackageResources.Wrapper((IXposedHookInitPackageResources) moduleInstance));
        }

        // ...
      } catch (Throwable t) {
        Log.e(TAG, "    Failed to load class " + moduleClassName, t);
      }
    }
  } catch (IOException e) {
    Log.e(TAG, "  Failed to load module from " + apk, e);
  } finally {
    closeSilently(is);
    closeSilently(zipFile);
  }
}
```


上面代码首先从 conf/modules.list 文件加载所有 Xposed 模块的 APK 路径列表，然后通过读取每一个 Xposed 模块 APK 包中的 assets/xposed_init 文件获得 Xposed 模块的入口类名，最后将这个类通过 XposedBridge.hookLoadPackage 注册到前面的 XposedBridge.sLoadedPackageCallbacks 中。

// XposedBridge.java

public static void hookLoadPackage(XC_LoadPackage callback) {
  synchronized (sLoadedPackageCallbacks) {
    sLoadedPackageCallbacks.add(callback);
  }
}
1
2
3
4
5
6
7
那么当前面 Hook 的系统关键类流程被触发后，将会通过 sLoadedPackageCallbacks 回调每个 Xposed 模块的入口。

到这里 Xposed 模块的启动的核心逻辑就分析完了，主要是通过 Xposed 定制版的 zygote 加载 XposedBridge.jar，然后调用 XposedBridge#main 方法加载所有的 Xposed 模块，当一个进程通过 zygote 进程 clone 出来时，就会携带 XposedBridge.jar 的代码，同时在进程启动时回调所有的 Xposed 模块的入口，XposedBridge.jar 中还包含 Hook API，那么 Xposed 模块就可以通过这些 API 对应用程序进行 Hook 操作了。

接下来就是 Xposed 的方法 Hook 的实现代码分析了。


- https://blog.csdn.net/weixin_47883636/article/details/109018440









