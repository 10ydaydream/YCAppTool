#### 目录介绍
- 01.findAndHookMethod
- 02.hookMethod源码
- 03.hookMethodNative


### 01.findAndHookMethod
- 从 XposedHelpers.findAndHookMethod 方法开始，看 Xposed 是如何进行 Hook 的。
    ```
    // XposedHelpers.java
    public static XC_MethodHook.Unhook findAndHookMethod(Class<?> clazz, String methodName, Object... parameterTypesAndCallback) {
      if (parameterTypesAndCallback.length == 0 || !(parameterTypesAndCallback[parameterTypesAndCallback.length-1] instanceof XC_MethodHook))
        throw new IllegalArgumentException("no callback defined");
    
      XC_MethodHook callback = (XC_MethodHook) parameterTypesAndCallback[parameterTypesAndCallback.length-1];
      // 获取方法的反射表示对象
      Method m = findMethodExact(clazz, methodName, getParameterClasses(clazz.getClassLoader(), parameterTypesAndCallback));
    
      // 下一步
      return XposedBridge.hookMethod(m, callback);
    }
    ```
- 首先使用 findMethodExact 获取一个 Java 方法的反射表示对象 m：
    ```
    // XposedHelpers.java
    
    public static Method findMethodExact(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
      String fullMethodName = clazz.getName() + '#' + methodName + getParametersString(parameterTypes) + "#exact";
    
      if (methodCache.containsKey(fullMethodName)) {
        // 首先从缓存中取
        Method method = methodCache.get(fullMethodName);
        if (method == null)
          throw new NoSuchMethodError(fullMethodName);
        return method;
      }
    
      try {
        // 通过反射 API 取得 Method 对象
        Method method = clazz.getDeclaredMethod(methodName, parameterTypes);
        method.setAccessible(true);
        methodCache.put(fullMethodName, method);
        return method;
      } catch (NoSuchMethodException e) {
        methodCache.put(fullMethodName, null);
        throw new NoSuchMethodError(fullMethodName);
      }
    }
    ```
    - 这里也很简单，使用了缓存保存方法的反射对象



### 02.hookMethod源码
- 继续下一步，进入 XposedBridge#hookMethod 方法。
    ```
    // XposedBridge.java
    public static XC_MethodHook.Unhook hookMethod(Member hookMethod, XC_MethodHook callback) {
      // 只允许 Method 和 Constructor 类型，Constructor 类型为了支持 findAndHookConstructor
      if (!(hookMethod instanceof Method) && !(hookMethod instanceof Constructor<?>)) {
        throw new IllegalArgumentException("Only methods and constructors can be hooked: " + hookMethod.toString());
      } else if (hookMethod.getDeclaringClass().isInterface()) {
        throw new IllegalArgumentException("Cannot hook interfaces: " + hookMethod.toString());
      } else if (Modifier.isAbstract(hookMethod.getModifiers())) {
        throw new IllegalArgumentException("Cannot hook abstract methods: " + hookMethod.toString());
      }
    
      boolean newMethod = false;
      CopyOnWriteSortedSet<XC_MethodHook> callbacks;
      synchronized (sHookedMethodCallbacks) {
        callbacks = sHookedMethodCallbacks.get(hookMethod);
        if (callbacks == null) {
          // 创建 method 与 hook 回调列表关联的映射表
          callbacks = new CopyOnWriteSortedSet<>();
          sHookedMethodCallbacks.put(hookMethod, callbacks);
          newMethod = true;
        }
      }
      // 添加 hook 回调到和这个 method 关联的 hook 回调列表
      callbacks.add(callback);
    
      if (dnewMethod) {
        Clss<?> declaringClass = hookMethod.getDeclaringClass();
        int slot;
        Class<?>[] parameterTypes;
        Class<?> returnType;
        if (runtime == RUNTIME_ART) {
          slot = 0;
          parameterTypes = null;
          returnType = null;
        } else if (hookMethod instanceof Method) {
          // slot 在 Android 5.0 以下的系统，java.reflect.Method 类中的成员，
          // 它是 Dralvik 虚拟机中这个 Method 在虚拟机中的地址。
          // Android 5.0 开始正式使用了 ART 虚拟机，所以不存在这个成员
          slot = getIntField(hookMethod, "slot");
          parameterTypes = ((Method) hookMethod).getParameterTypes();
          returnType = ((Method) hookMethod).getReturnType();
        } else {
          // 处理 Constructor
          slot = getIntField(hookMethod, "slot");
          parameterTypes = ((Constructor<?>) hookMethod).getParameterTypes();
          returnType = null;
        }
    
        // 打包 Hook 回调相关信息，准备进入 Native 层
        AdditionalHookInfo additionalInfo = new AdditionalHookInfo(callbacks, parameterTypes, returnType);
        // 进入 Native 层代码，传入 method、class、slot、hook 回调等信息
        hookMethodNative(hookMethod, declaringClass, slot, additionalInfo);
      }
    
      return callback.new Unhook(hookMethod);
    }
    ```
- 上面主要是添加了 XC_MethodHook 类型的 Hook 回调，然后将相关信息全部传入了 Xposed native 层代码中。最后返回一个 Unhook 对象，是为了取消 Hook，它的 unhook 方法如下：
    ```
    // XC_MethodHook.java - class Unhook
    
    public void unhook() {
      XposedBridge.unhookMethod(hookMethod, XC_MethodHook.this);
    }
    
    // XposedBridge.java
    public static void unhookMethod(Member hookMethod, XC_MethodHook callback) {
      CopyOnWriteSortedSet<XC_MethodHook> callbacks;
      synchronized (sHookedMethodCallbacks) {
        callbacks = sHookedMethodCallbacks.get(hookMethod);
        if (callbacks == null)
          return;
      }
      callbacks.remove(callback);
    }
    ```
- 就是直接移除与这个 Java 方法相关的 Hook 处理回调。



### 03.hookMethodNative
- 下面查看 hookMethodNative 函数的实现，发现它是一个 JNI 方法：
    ```
    private native synchronized static void hookMethodNative(Member method, Class<?> declaringClass, int slot, Object additionalInfo);
    ```
- 它的实现在 libxposed_art.so 中，源代码在 Xposed 项目中。
    - 首先需要解决一个问题，这个动态库是什么时候加载的，它的 JNI 方法和 Java 层是什么时候关联的？
    - 它是在 Java 虚拟机中创建时加载的，同时关联的 JNI 方法。
    - 在 app_main2.cpp 中，Xposed 除了改写 app_process 的 main 函数，还改写了 AppRuntime::onVmCreated 函数：
    ```
    // app_main2.cpp
    namespace android {
    class AppRuntime : public AndroidRuntime
    {
    public:
        // ...
    
        virtual void onVmCreated(JNIEnv* env)
        {
            if (isXposedLoaded)
                xposed::onVmCreated(env);
    
            if (mClassName.isEmpty()) {
                return;
            }
    
            char* slashClassName = toSlashClassName(mClassName.string());
            mClass = env->FindClass(slashClassName);
            if (mClass == NULL) {
                ALOGE("ERROR: could not find class '%s'\n", mClassName.string());
                env->ExceptionDescribe();
            }
            free(slashClassName);
    
            mClass = reinterpret_cast<jclass>(env->NewGlobalRef(mClass));
        }
    
        // ...
        };
    }
    ```
- 回顾前面的内容，这个函数将在 Java 虚拟机创建后被回调：
    ```
    // AndroidRuntime.cpp
    
    void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
    {
      // ...
      if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
      }
      // 回调 Java 虚拟机创建
      onVmCreated(env);
      if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
      }
      // ...  
    }
    ```
- 进入 xposed::onVmCreated 函数：
    ```
    // xposed.cpp
    void onVmCreated(JNIEnv* env) {
        const char* xposedLibPath = NULL;
        // 首先确认 Xposed 库的路径是 ART 还是 Dalvik
        if (!determineRuntime(&xposedLibPath)) {
            ALOGE("Could not determine runtime, not loading Xposed");
            return;
        }
    
        // 打开 Xposed 动态库
        void* xposedLibHandle = dlopen(xposedLibPath, RTLD_NOW);
        if (!xposedLibHandle) {
            ALOGE("Could not load libxposed: %s", dlerror());
            return;
        }
    
        dlerror();
    
        // 调用初始化方法
        bool (*xposedInitLib)(XposedShared* shared) = NULL;
        *(void **) (&xposedInitLib) = dlsym(xposedLibHandle, "xposedInitLib");
        if (!xposedInitLib)  {
            ALOGE("Could not find function xposedInitLib");
            return;
        }
    
    #if XPOSED_WITH_SELINUX
        xposed->zygoteservice_accessFile = &service::membased::accessFile;
        xposed->zygoteservice_statFile   = &service::membased::statFile;
        xposed->zygoteservice_readFile   = &service::membased::readFile;
    #endif  // XPOSED_WITH_SELINUX
    
        if (xposedInitLib(xposed)) {
            // 调用绑定的 onVmCreated 回调函数
            xposed->onVmCreated(env);
        }
    }
    ```
- 首先是 determineRuntime 确认 Xposed 的库路径：
    ```
    // xposed.cpp
    static bool determineRuntime(const char** xposedLibPath) {
        FILE *fp = fopen("/proc/self/maps", "r");
        if (fp == NULL) {
            ALOGE("Could not open /proc/self/maps: %s", strerror(errno));
            return false;
        }
    
        bool success = false;
        char line[256];
        while (fgets(line, sizeof(line), fp) != NULL) {
            char* libname = strrchr(line, '/');
            if (!libname)
                continue;
            libname++;
    
            if (strcmp("libdvm.so\n", libname) == 0) {
                ALOGI("Detected Dalvik runtime");
                // #define XPOSED_LIB_DALVIK POSED_LIB_DIR "libxposed_dalvik.so"
                *xposedLibPath = XPOSED_LIB_DALVIK;
                success = true;
                break;
    
            } else if (strcmp("libart.so\n", libname) == 0) {
                ALOGI("Detected ART runtime");
                // #define XPOSED_LIB_ART XPOSED_LIB_DIR "libxposed_art.so"
                *xposedLibPath = XPOSED_LIB_ART;
                success = true;
                break;
            }
        }
    
        fclose(fp);
        return success;
    }
    ```
- 根据系统中是否存在 libdvm.so 或 libart.so，确认加载支持 ART 还是 Dalvik 版本的 Xposed 库，在 ART 上加载 libxposed_art.so。
    - 然后使用 dlopen 加载链接了这个动态库，那么它的符号就可以被正常访问了。后面又调用了 xposedInitLib 函数：
    ```
    // libxposed_art.cpp
    
    bool xposedInitLib(XposedShared* shared) {
        xposed = shared;
        xposed->onVmCreated = &onVmCreatedCommon;
        return true;
    }
    ```
- 指定了一个 xposed->onVmCreated 为 onVmCreatedCommon，看一下它的实现。
    ```
    // libxposed_common.cpp
    void onVmCreatedCommon(JNIEnv* env) {
        if (!initXposedBridge(env) || !initZygoteService(env)) {
            return;
        }
    
        if (!onVmCreated(env)) {
            return;
        }
    
        xposedLoadedSuccessfully = true;
        return;
    }
    ```
- 这里主要关注 initXposedBridge，它会进行 JNI 方法的注册。
```
// libxposed_common.cpp

bool initXposedBridge(JNIEnv* env) {
    // #define CLASS_XPOSED_BRIDGE  "de/robv/android/xposed/XposedBridge"
    classXposedBridge = env->FindClass(CLASS_XPOSED_BRIDGE);
    if (classXposedBridge == NULL) {
        ALOGE("Error while loading Xposed class '%s':", CLASS_XPOSED_BRIDGE);
        logExceptionStackTrace();
        env->ExceptionClear();
        return false;
    }
    classXposedBridge = reinterpret_cast<jclass>(env->NewGlobalRef(classXposedBridge));

    ALOGI("Found Xposed class '%s', now initializing", CLASS_XPOSED_BRIDGE);
    // 注册 XposedBridge 关联的 JNI 方法
    if (register_natives_XposedBridge(env, classXposedBridge) != JNI_OK) {
        ALOGE("Could not register natives for '%s'", CLASS_XPOSED_BRIDGE);
        logExceptionStackTrace();
        env->ExceptionClear();
        return false;
    }

    // 缓存 XposedBridge 的 handleHookedMethod 方法的 jmethodID
    methodXposedBridgeHandleHookedMethod = env->GetStaticMethodID(classXposedBridge, "handleHookedMethod",
        "(Ljava/lang/reflect/Member;ILjava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;");
    if (methodXposedBridgeHandleHookedMethod == NULL) {
        ALOGE("ERROR: could not find method %s.handleHookedMethod(Member, int, Object, Object, Object[])", CLASS_XPOSED_BRIDGE);
        logExceptionStackTrace();
        env->ExceptionClear();
        return false;
    }

    return true;
}
```



```
// libxposed_common.cpp

int register_natives_XposedBridge(JNIEnv* env, jclass clazz) {
    const JNINativeMethod methods[] = {
        NATIVE_METHOD(XposedBridge, hadInitErrors, "()Z"),
        NATIVE_METHOD(XposedBridge, getStartClassName, "()Ljava/lang/String;"),
        NATIVE_METHOD(XposedBridge, getRuntime, "()I"),
        NATIVE_METHOD(XposedBridge, startsSystemServer, "()Z"),
        NATIVE_METHOD(XposedBridge, getXposedVersion, "()I"),
        NATIVE_METHOD(XposedBridge, initXResourcesNative, "()Z"),
        // 注册 hookMethodNative 方法
        NATIVE_METHOD(XposedBridge, hookMethodNative, "(Ljava/lang/reflect/Member;Ljava/lang/Class;ILjava/lang/Object;)V"),
        // ...
    };
    return env->RegisterNatives(clazz, methods, NELEM(methods));
}
```


其中 NATIVE_METHOD 是一个宏，方便注册 JNI 方法：
```
// libxposed_common.h

#ifndef NATIVE_METHOD
#define NATIVE_METHOD(className, functionName, signature) \
  { #functionName, signature, reinterpret_cast<void*>(className ## _ ## functionName) }
#endif
```


现在回去，对 hookMethodNative 的具体实现进行分析，从这里开始就是真正开始实现方法 Hook 了。

由于这里是 Xposed 方法 Hook 的核心实现，所以同时分析一下基于 Dalvik 的实现。

Dalvik Hook 实现
首先看一下 libxposed_dalvik.so 中的实现，验证一下本文开头基于 Dalvik 的方法 Hook 的描述。
```
// libxposed_dalvik.cpp

void XposedBridge_hookMethodNative(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect,
            jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect) {
    if (declaredClassIndirect == NULL || reflectedMethodIndirect == NULL) {
        dvmThrowIllegalArgumentException("method and declaredClass must not be null");
        return;
    }

    // 获取 Dalvik 中表示 Java 类的 ClassObject 对象
    ClassObject* declaredClass = (ClassObject*) dvmDecodeIndirectRef(dvmThreadSelf(), declaredClassIndirect);
    // 利用 slot 变量从 ClassObject 中找到 Dalvik 中表示 Java 方法的 Method 对象
    Method* method = dvmSlotToMethod(declaredClass, slot);
    if (method == NULL) {
        dvmThrowNoSuchMethodError("Could not get internal representation for method");
        return;
    }

    // inline bool isMethodHooked(const Method* method) {
    //   return (method->nativeFunc == &hookedMethodCallback);
    // }
    if (isMethodHooked(method)) {
        // 此方法已经被 Hook，直接返回
        return;
    }

    // 保存原始方法的信息
    XposedHookInfo* hookInfo = (XposedHookInfo*) calloc(1, sizeof(XposedHookInfo));
    memcpy(hookInfo, method, sizeof(hookInfo->originalMethodStruct));
    hookInfo->reflectedMethod = dvmDecodeIndirectRef(dvmThreadSelf(), env->NewGlobalRef(reflectedMethodIndirect));
    hookInfo->additionalInfo = dvmDecodeIndirectRef(dvmThreadSelf(), env->NewGlobalRef(additionalInfoIndirect));

    // 将此 Java 方法增加 native 描述符，即 JNI 方法
    SET_METHOD_FLAG(method, ACC_NATIVE);
    // 设置 native 函数的处理函数，那么 Dalvik 解释执行这个方法时，
    // 首先判断会它是 JNI 方法，然后会跳转至 nativeFunc 进行执行
    method->nativeFunc = &hookedMethodCallback;
    method->insns = (const u2*) hookInfo;
    method->registersSize = method->insSize;
    method->outsSize = 0;

    if (PTR_gDvmJit != NULL) {
        char currentValue = *((char*)PTR_gDvmJit + MEMBER_OFFSET_VAR(DvmJitGlobals,codeCacheFull));
        if (currentValue == 0 || currentValue == 1) {
            MEMBER_VAL(PTR_gDvmJit, DvmJitGlobals, codeCacheFull) = true;
        } else {
            ALOGE("Unexpected current value for codeCacheFull: %d", currentValue);
        }
    }
}
```


这里 Xposed 基于 Dalvik 实现的方法 Hook 处理比较简单，就是先将这个 Java 方法修改为 native 方法，然后给它绑定一个 nativeFunc，当 Java 代码调用这个方法时，由于它是 JNI 方法，虚拟机就会跳转到 nativeFunc 进行执行。

Dalvik 虚拟机执行 Java 方法的实现如下：
```
// Stack.cpp
void dvmCallMethodV(Thread* self, const Method* method, Object* obj, bool fromJni, JValue* pResult, va_list args)
{
  // ...
  if (dvmIsNativeMethod(method)) {
    TRACE_METHOD_ENTER(self, method);
    // 如果是 native 方法，则跳转 nativeFunc 进行执行
    (*method->nativeFunc)((u4*)self->interpSave.curFrame, pResult, method, self);
    TRACE_METHOD_EXIT(self, method);
  } else {
      dvmInterpret(self, method, pResult);
  }
  // ...
}


// Object.h

INLINE bool dvmIsNativeMethod(const Method* method) {
  return (method->accessFlags & ACC_NATIVE) != 0;
}
```


可以看到，如果一个方法是 JNI 方法，那么 Dalvik 虚拟机就会调用它绑定的 nativeFunc 函数。

前面设置的 hookedMethodCallback 函数将会把被调用的 Java 方法的参数进行转发，最终会调用 Java 层 XposedBridge 的 handleHookedMethod 方法进行处理，就能够达到 Hook 的目的了，至于 hookedMethodCallback 函数的实现，这里不再详细分析，可以自己看一下。Java 层 handleHookedMethod 方法的实现和 ART 没有区别，都是在 XposedBridge.jar 中，在下面 ART 部分中会进行分析。

下面进入 libxposed_art.so 中的 hookMethodNative 函数实现：

ART Hook 实现
接下来关注 libxposed_art.so 中的实现。
```
// libxposed_art.cpp
void XposedBridge_hookMethodNative(JNIEnv* env, jclass, jobject javaReflectedMethod,
            jobject, jint, jobject javaAdditionalInfo) {
    ScopedObjectAccess soa(env);
    if (javaReflectedMethod == nullptr) {
#if PLATFORM_SDK_VERSION >= 23
        ThrowIllegalArgumentException("method must not be null");
#else
        ThrowIllegalArgumentException(nullptr, "method must not be null");
#endif
        return;
    }

    // ART 虚拟机中表示 Java 方法的 artMethod 对象
    ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaReflectedMethod);

    // fHook 这个方法
    artMethod->EnableXposedHook(soa, javaAdditionalInfo);
}
```

上面使用 Java 层方法的反射表示对象 javaReflectedMethod，获取了一个 ART 虚拟机中用来表示 Java 方法的 ArtMethod 对象，然后就直接进入 ArtMethod 的 EnableXposedHook 函数中了。

其中 FromReflectedMethod 是 ART 虚拟机本来就有的方法；ScopedObjectAccess 是一个工具类，需要借助 env 进行操作。

下面进入 ArtMethod 的 EnableXposedHook 函数中，从这里开始就进入 Xposed 修改过的 ART 虚拟机的项目 android_art 中了。

```
// art_method.cc

void ArtMethod::EnableXposedHook(ScopedObjectAccess& soa, jobject additional_info) {
  if (UNLIKELY(IsXposedHookedMethod())) {
    // 已被 Hook
    return;
  } else if (UNLIKELY(IsXposedOriginalMethod())) {
    // 是用于备份的 ArtMethod 对象，通常不应该走到这
    ThrowIllegalArgumentException(StringPrintf("Cannot hook the method backup: %s", PrettyMethod(this).c_str()).c_str());
    return;
  }

  // 获取 ClassLinker，它是链接器
  auto* cl = Runtime::Current()->GetClassLinker();
  // 获取线性分配器，用于分配内存，类似于 malloc 
  auto* linear_alloc = cl->GetAllocatorForClassLoader(GetClassLoader());
  // 创建一个新的 ArtMethod 对象，用于备份原始方法
  ArtMethod* backup_method = cl->CreateRuntimeMethod(linear_alloc);
  // 复制当前 ArtMethod 至 backup_method
  backup_method->CopyFrom(this, cl->GetImagePointerSize());
  // 添加 kAccXposedOriginalMethod 标记，说明是备份的方法
  backup_method->SetAccessFlags(backup_method->GetAccessFlags() | kAccXposedOriginalMethod);

  // 创建备份方法对应的反射对象
  mirror::AbstractMethod* reflected_method;
  if (IsConstructor()) {
    reflected_method = mirror::Constructor::CreateFromArtMethod(soa.Self(), backup_method);
  } else {
    reflected_method = mirror::Method::CreateFromArtMethod(soa.Self(), backup_method);
  }
  reflected_method->SetAccessible<false>(true);

  // 将备份的方法和一路从 Java 层传过来的 additional_info（包含处理 Hook 的回调）装到 XposedHookInfo 对象中
  XposedHookInfo* hook_info = reinterpret_cast<XposedHookInfo*>(linear_alloc->Alloc(soa.Self(), sizeof(XposedHookInfo)));
  hook_info->reflected_method = soa.Vm()->AddGlobalRef(soa.Self(), reflected_method);
  hook_info->additional_info = soa.Env()->NewGlobalRef(additional_info);
  hook_info->original_method = backup_method;

  ScopedThreadSuspension sts(soa.Self(), kSuspended);
  jit::ScopedJitSuspend sjs;
  gc::ScopedGCCriticalSection gcs(soa.Self(),
                                  gc::kGcCauseXposed,
                                  gc::kCollectorTypeXposed);
  ScopedSuspendAll ssa(__FUNCTION__);

  // 清除本方法的调用者信息
  cl->InvalidateCallersForMethod(soa.Self(), this);

  jit::Jit* jit = art::Runtime::Current()->GetJit();
  if (jit != nullptr) {
    // 将本方法的 CodeCache 中的内容移动到备份方法对象中
    // CodeCache 就是从 Dex 文件中解析到的类和方法的相关信息，
    // 缓存起来，方便直接取用，而不是每次都解析 Dex 文件
    jit->GetCodeCache()->MoveObsoleteMethod(this, backup_method);
  }

  // 将 hook_info 保存在用于原本用于存储 JNI 方法的内存地址上 
  SetEntryPointFromJniPtrSize(reinterpret_cast<uint8_t*>(hook_info), sizeof(void*));
  // 设置此方法对应的汇编代码的地址，一个 Java 方法经过编译器编译后会对应一段汇编代码，
  // 当虚拟机执行这个 Java 方法时，如果处于 AOT 模式，就会直接跳转到汇编代码执行机器指令
  SetEntryPointFromQuickCompiledCode(GetQuickProxyInvokeHandler());
  // 设置 dex 中此方法的偏移为 0，表示它是 native 或 abstract 方法，没有具体代码
  SetCodeItemOffset(0);

  // 清除以下标志
  const uint32_t kRemoveFlags = kAccNative | kAccSynchronized | kAccAbstract | kAccDefault | kAccDefaultConflict;
  // 添加 Xposed 自定义的 kAccXposedHookedMethod 标志，用来标识它是被 Hook 的方法
  // 添加后，IsXposedHookedMethod 函数就会返回 true
  SetAccessFlags((GetAccessFlags() & ~kRemoveFlags) | kAccXposedHookedMethod);

  MutexLock mu(soa.Self(), *Locks::thread_list_lock_);
  Runtime::Current()->GetThreadList()->ForEach(StackReplaceMethodAndInstallInstrumentation, this);
}
```


上面代码的主要工作是备份当前需要被 Hook 的方法，然后设置当前方法的汇编代码地址为 GetQuickProxyInvokeHandler()，此时就完成了 Hook 目的。

当这个 Java 方法被调用时，会跳转到上面设置的汇编代码地址处，Xposed 将会对这个 Java 方法的参数进行转发等处理，修改方法返回值，实现最终 Hook。

不过没有看到最终的处理，并不知道是怎么做的，下面继续分析。

首先看 GetQuickProxyInvokeHandler() 的返回值：
```
extern "C" void art_quick_proxy_invoke_handler();
static inline const void* GetQuickProxyInvokeHandler() {
  return reinterpret_cast<const void*>(art_quick_proxy_invoke_handler);
}
```


它是一个 art_quick_proxy_invoke_handler 函数的地址，这个函数是在其他地方实现的（有 extern 声明），经过了解，发现它是由汇编代码实现的，有 arm、arm64、mips、mips64、x86、x86_64 这几个指令集的实现，这里看一下 arm 上的实现：

```
// quick_entrypoints_arm.S

.extern artQuickProxyInvokeHandler
ENTRY art_quick_proxy_invoke_handler
    SETUP_REFS_AND_ARGS_CALLEE_SAVE_FRAME_WITH_METHOD_IN_R0
    // 传递相关参数
    mov     r2, r9                 @ pass Thread::Current
    mov     r3, sp                 @ pass SP
    // 跳转至 artQuickProxyInvokeHandler 函数
    blx     artQuickProxyInvokeHandler  @ (Method* proxy method, receiver, Thread*, SP)
    ldr     r2, [r9, #THREAD_EXCEPTION_OFFSET]  @ load Thread::Current()->exception_
    add     sp, #(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE)
    .cfi_adjust_cfa_offset -(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE)
    RESTORE_REFS_ONLY_CALLEE_SAVE_FRAME
    cbnz    r2, 1f                 @ success if no exception is pending
    vmov    d0, r0, r1             @ store into fpr, for when it's a fpr return...
    bx      lr                     @ return on success
1:
    DELIVER_PENDING_EXCEPTION
END art_quick_proxy_invoke_handler
```

art_quick_proxy_invoke_handler 跳转至了 artQuickProxyInvokeHandler 函数中，那么继续跟进。
```
// qucik_trampoline_entrypoints.cc
extern "C" uint64_t artQuickProxyInvokeHandler(
    ArtMethod* proxy_method, mirror::Object* receiver, Thread* self, ArtMethod** sp)
    SHARED_REQUIRES(Locks::mutator_lock_) {
  // bool IsXposedHookedMethod() {
  //   return (GetAccessFlags() & kAccXposedHookedMethod) != 0;
  // }
  const bool is_xposed = proxy_method->IsXposedHookedMethod();
  if (!is_xposed) {
    DCHECK(proxy_method->IsRealProxyMethod()) << PrettyMethod(proxy_method);
    DCHECK(receiver->GetClass()->IsProxyClass()) << PrettyMethod(proxy_method);
  }
  const char* old_cause = self->StartAssertNoThreadSuspension("Adding to IRT proxy object arguments");
  DCHECK_EQ((*sp), proxy_method) << PrettyMethod(proxy_method);
  self->VerifyStack();
  JNIEnvExt* env = self->GetJniEnv();
  ScopedObjectAccessUnchecked soa(env);
  ScopedJniEnvLocalRefState env_state(env);
  const bool is_static = proxy_method->IsStatic();
  jobject rcvr_jobj = is_static ? nullptr : soa.AddLocalReference<jobject>(receiver);

  ArtMethod* non_proxy_method = proxy_method->GetInterfaceMethodIfProxy(sizeof(void*));
  CHECK(is_xposed || !non_proxy_method->IsStatic()) << PrettyMethod(proxy_method) << " "
                                                    << PrettyMethod(non_proxy_method);
  std::vector<jvalue> args;
  uint32_t shorty_len = 0;
  const char* shorty = non_proxy_method->GetShorty(&shorty_len);
  BuildQuickArgumentVisitor local_ref_visitor(sp, is_static, shorty, shorty_len, &soa, &args);

  local_ref_visitor.VisitArguments();
  if (!is_static) {
    DCHECK_GT(args.size(), 0U) << PrettyMethod(proxy_method);
    args.erase(args.begin());
  }

  if (is_xposed) {
    jmethodID proxy_methodid = soa.EncodeMethod(proxy_method);
    self->EndAssertNoThreadSuspension(old_cause);
    // 处理 Hook 方法
    JValue result = InvokeXposedHandleHookedMethod(soa, shorty, rcvr_jobj, proxy_methodid, args);
    local_ref_visitor.FixupReferences();
    // 返回 Java 方法的返回值
    return result.GetJ();
  }

  // ...
}
```


可以大概看出来 artQuickProxyInvokeHandler 函数是用于处理动态代理方法的，不过 Xposed 对这个方法进行了修改，使其能够处理被 Hook 的方法，重点关注下面判断语句中的代码，如果是被 Xposed Hook 的方法，那么进入 InvokeXposedHandleHookedMethod 进行处理：

```
// entrypoint_utils.cc
JValue InvokeXposedHandleHookedMethod(ScopedObjectAccessAlreadyRunnable& soa, const char* shorty,
                                      jobject rcvr_jobj, jmethodID method,
                                      std::vector<jvalue>& args) {
  soa.Self()->AssertThreadSuspensionIsAllowable();
  jobjectArray args_jobj = nullptr;
  const JValue zero;
  int32_t target_sdk_version = Runtime::Current()->GetTargetSdkVersion();
  // ...

  // 取出 hook_info
  const XposedHookInfo* hook_info = soa.DecodeMethod(method)->GetXposedHookInfo();
  // 调用 Java 层的 XposedBridge.handleHookedMethod 方法
  jvalue invocation_args[5];
  invocation_args[0].l = hook_info->reflected_method;
  invocation_args[1].i = 1;
  invocation_args[2].l = hook_info->additional_info;
  // 方法的目标作用对象 this
  invocation_args[3].l = rcvr_jobj;
  // 参数保存传给方法的参数
  invocation_args[4].l = args_jobj;
  jobject result =
      soa.Env()->CallStaticObjectMethodA(ArtMethod::xposed_callback_class,
                                         ArtMethod::xposed_callback_method,
                                         invocation_args);

  if (UNLIKELY(soa.Self()->IsExceptionPending())) {
    return zero;
  } else {
    if (shorty[0] == 'V' || (shorty[0] == 'L' && result == nullptr)) {
      return zero;
    }
    size_t pointer_size = Runtime::Current()->GetClassLinker()->GetImagePointerSize();
    mirror::Class* result_type = soa.DecodeMethod(method)->GetReturnType(true /* resolve */, pointer_size);
    mirror::Object* result_ref = soa.Decode<mirror::Object*>(result);
    JValue result_unboxed;
    if (!UnboxPrimitiveForResult(result_ref, result_type, &result_unboxed)) {
      DCHECK(soa.Self()->IsExceptionPending());
      return zero;
    }
    return result_unboxed;
  }
}
```


这里就调用到了 Java 层 XposedBridge 的 handleHookedMethod 方法中。

// XposedBridge.java
```
private static Object handleHookedMethod(Member method, int originalMethodId, Object additionalInfoObj,
    Object thisObject, Object[] args) throws Throwable {
  // 取出 Hook 处理回调等信息
  AdditionalHookInfo additionalInfo = (AdditionalHookInfo) additionalInfoObj;

  if (disableHooks) {
    try {
      // 如果关闭 Hook，那么调用原始方法
      return invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes,
          additionalInfo.returnType, thisObject, args);
    } catch (InvocationTargetException e) {
      throw e.getCause();
    }
  }

  Object[] callbacksSnapshot = additionalInfo.callbacks.getSnapshot();
  final int callbacksLength = callbacksSnapshot.length;
  if (callbacksLength == 0) {
    try {
      // 没有处理 Hook 的回调，则调用原始方法
      return invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes,
          additionalInfo.returnType, thisObject, args);
    } catch (InvocationTargetException e) {
      throw e.getCause();
    }
  }

  MethodHookParam param = new MethodHookParam();
  param.method = method;
  param.thisObject = thisObject;
  param.args = args;

  int beforeIdx = 0;
  do {
    try {
      // 回调 beforeHookedMethod 方法，表示在 Hook 之前
      ((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param);
    } catch (Throwable t) {
      XposedBridge.log(t);

      param.setResult(null);
      param.returnEarly = false;
      continue;
    }

    if (param.returnEarly) {
      beforeIdx++;
      break;
    }
  } while (++beforeIdx < callbacksLength);

  // Hook 回调没有处理，则调用原始方法
  if (!param.returnEarly) {
    try {
      param.setResult(invokeOriginalMethodNative(method, originalMethodId,
          additionalInfo.parameterTypes, additionalInfo.returnType, param.thisObject, param.args));
    } catch (InvocationTargetException e) {
      param.setThrowable(e.getCause());
    }
  }

  int afterIdx = beforeIdx - 1;
  do {
    Object lastResult =  param.getResult();
    Throwable lastThrowable = param.getThrowable();

    try {
      // 调用 afterHookedMethod 方法，表示 Hook 之后
      ((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param);
    } catch (Throwable t) {
      XposedBridge.log(t);

      if (lastThrowable == null)
        param.setResult(lastResult);
      else
        param.setThrowable(lastThrowable);
    }
  } while (--afterIdx >= 0);

  // 如果有异常，则抛出异常，否则返回处理后的结果
  if (param.hasThrowable())
    throw param.getThrowable();
  else
    return param.getResult();
}
```


这里就能清晰的看到 Hook 最终处理了，至此就完成了 Hook。其中 invokeOriginalMethodNative 的实现如下：
```
// libxposed_art.cpp
jobject XposedBridge_invokeOriginalMethodNative(JNIEnv* env, jclass, jobject javaMethod,
            jint isResolved, jobjectArray, jclass, jobject javaReceiver, jobjectArray javaArgs) {
    ScopedFastNativeObjectAccess soa(env);
    if (UNLIKELY(!isResolved)) {
        // 从备份的方法中取得原始方法
        ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaMethod);
        if (LIKELY(artMethod->IsXposedHookedMethod())) {
            javaMethod = artMethod->GetXposedHookInfo()->reflected_method;
        }
    }
#if PLATFORM_SDK_VERSION >= 23
    // 调用虚拟机的执行方法调用原始方法逻辑
    return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs);
#else
    return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs, true);
#endif
}
```

还有最后一个问题，就是一个被 Hook 的方法的调用过程，上面只分析了处理过程，而没有正向的调用，下面开始分析。

调用过程
分析一个 Java 方法的调用，可以从 AndroidRuntime.start 中开始，Java 虚拟机执行的第一个类是 ZygoteInit 从此就进入了 Java 层，它使用的是 JNIEnv 提供的 CallStaticVoidMethod 方法，看一下它的实现。

```
// jni_internal.cc
static void CallStaticVoidMethod(JNIEnv* env, jclass, jmethodID mid, ...) {
  va_list ap;
  va_start(ap, mid);
  CHECK_NON_NULL_ARGUMENT_RETURN_VOID(mid);
  ScopedObjectAccess soa(env);
  InvokeWithVarArgs(soa, nullptr, mid, ap);
  va_end(ap);
}
```


调用了 InvokeWithVarArgs 函数：

// reflection.cc
```
JValue InvokeWithVarArgs(const ScopedObjectAccessAlreadyRunnable& soa, jobject obj, jmethodID mid,
                         va_list args)
    SHARED_REQUIRES(Locks::mutator_lock_) {
  // ...

  ArtMethod* method = soa.DecodeMethod(mid);
  bool is_string_init = method->GetDeclaringClass()->IsStringClass() && method->IsConstructor();
  if (is_string_init) {
    method = soa.DecodeMethod(WellKnownClasses::StringInitToStringFactoryMethodID(mid));
  }
  mirror::Object* receiver = method->IsStatic() ? nullptr : soa.Decode<mirror::Object*>(obj);
  uint32_t shorty_len = 0;
  const char* shorty = method->GetInterfaceMethodIfProxy(sizeof(void*))->GetShorty(&shorty_len);
  JValue result;
  ArgArray arg_array(shorty, shorty_len);
  arg_array.BuildArgArrayFromVarArgs(soa, receiver, args);
  // 调用 InvokeWithArgArray
  InvokeWithArgArray(soa, method, &arg_array, &result, shorty);
  if (is_string_init) {
    UpdateReference(soa.Self(), obj, result.GetL());
  }
  return result;
}
```



继续看 InvokeWithArgArray：
```
// reflection.cc

static void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable& soa,
                               ArtMethod* method, ArgArray* arg_array, JValue* result,
                               const char* shorty)
    SHARED_REQUIRES(Locks::mutator_lock_) {
  uint32_t* args = arg_array->GetArray();
  if (UNLIKELY(soa.Env()->check_jni)) {
    CheckMethodArguments(soa.Vm(), method->GetInterfaceMethodIfProxy(sizeof(void*)), args);
  }
  method->Invoke(soa.Self(), args, arg_array->GetNumBytes(), result, shorty);
}
```


最终是调用到了 ArtMethod 的 Invoke 函数：
```
// reflection.cc

void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,
                       const char* shorty) {
  // ...

  ManagedStack fragment;
  self->PushManagedStackFragment(&fragment);

  Runtime* runtime = Runtime::Current();
  if (UNLIKELY(!runtime->IsStarted() || Dbg::IsForcedInterpreterNeededForCalling(self, this))) {
    // ...
  } else {
    DCHECK_EQ(runtime->GetClassLinker()->GetImagePointerSize(), sizeof(void*));

    constexpr bool kLogInvocationStartAndReturn = false;
    bool have_quick_code = GetEntryPointFromQuickCompiledCode() != nullptr;
    if (LIKELY(have_quick_code)) {
      // ...

      if (!IsStatic()) {
        (*art_quick_invoke_stub)(this, args, args_size, self, result, shorty);
      } else {
        (*art_quick_invoke_static_stub)(this, args, args_size, self, result, shorty);
      }
      
      // ...
    } else {
      // ...
    }
  }

  self->PopManagedStackFragment(fragment);
}
```

根据 Java 方法类型是非静态还是静态，跳入 art_quick_invoke_stub 或 art_quick_invoke_static_stub，看一下 art_quick_invoke_stub：
```
// reflection.cc

extern "C" void art_quick_invoke_stub(ArtMethod* method, uint32_t* args, uint32_t args_size,
                                      Thread* self, JValue* result, const char* shorty) {
  quick_invoke_reg_setup<false>(method, args, args_size, self, result, shorty);
}
```

```
// reflection.cc

template <bool kIsStatic>
static void quick_invoke_reg_setup(ArtMethod* method, uint32_t* args, uint32_t args_size,
                                   Thread* self, JValue* result, const char* shorty) {
  uint32_t core_reg_args[4];
  uint32_t fp_reg_args[16];
  uint32_t gpr_index = 1;
  uint32_t fpr_index = 0;
  uint32_t fpr_double_index = 0;
  uint32_t arg_index = 0;
  const uint32_t result_in_float = kArm32QuickCodeUseSoftFloat ? 0 :
      (shorty[0] == 'F' || shorty[0] == 'D') ? 1 : 0;

  if (!kIsStatic) {
    core_reg_args[gpr_index++] = args[arg_index++];
  }

  for (uint32_t shorty_index = 1; shorty[shorty_index] != '\0'; ++shorty_index, ++arg_index) {
    char arg_type = shorty[shorty_index];
    if (kArm32QuickCodeUseSoftFloat) {
      arg_type = (arg_type == 'D') ? 'J' : arg_type;
      arg_type = (arg_type == 'F') ? 'I' : arg_type;
    }
    switch (arg_type) {
      case 'D': {
        fpr_double_index = std::max(fpr_double_index, RoundUp(fpr_index, 2));
        if (fpr_double_index < arraysize(fp_reg_args)) {
          fp_reg_args[fpr_double_index++] = args[arg_index];
          fp_reg_args[fpr_double_index++] = args[arg_index + 1];
        }
        ++arg_index;
        break;
      }
      case 'F':
        if (fpr_index % 2 == 0) {
          fpr_index = std::max(fpr_double_index, fpr_index);
        }
        if (fpr_index < arraysize(fp_reg_args)) {
          fp_reg_args[fpr_index++] = args[arg_index];
        }
        break;
      // ...
    }
  }

  // 进入下一步
  art_quick_invoke_stub_internal(method, args, args_size, self, result, result_in_float,
      core_reg_args, fp_reg_args);
}
```

最后是调用了 art_quick_invoke_stub_internal，它是汇编代码实现的：
```
// quick_entrypoints_arm.S

ENTRY art_quick_invoke_stub_internal
    SPILL_ALL_CALLEE_SAVE_GPRS             @ spill regs (9)
    mov    r11, sp                         @ save the stack pointer
    .cfi_def_cfa_register r11

    mov    r9, r3                          @ move managed thread pointer into r9

    add    r4, r2, #4                      @ create space for method pointer in frame
    sub    r4, sp, r4                      @ reserve & align *stack* to 16 bytes: native calling
    and    r4, #0xFFFFFFF0                 @ convention only aligns to 8B, so we have to ensure ART
    mov    sp, r4                          @ 16B alignment ourselves.

    mov    r4, r0                          @ save method*
    add    r0, sp, #4                      @ pass stack pointer + method ptr as dest for memcpy
    bl     memcpy                          @ memcpy (dest, src, bytes)
    mov    ip, #0                          @ set ip to 0
    str    ip, [sp]                        @ store null for method* at bottom of frame

    ldr    ip, [r11, #48]                  @ load fp register argument array pointer
    vldm   ip, {s0-s15}                    @ copy s0 - s15

    ldr    ip, [r11, #44]                  @ load core register argument array pointer
    mov    r0, r4                          @ restore method*
    add    ip, ip, #4                      @ skip r0
    ldm    ip, {r1-r3}                     @ copy r1 - r3

#ifdef ARM_R4_SUSPEND_FLAG
    mov    r4, #SUSPEND_CHECK_INTERVAL     @ reset r4 to suspend check interval
#endif

    ldr    ip, [r0, #ART_METHOD_QUICK_CODE_OFFSET_32]  @ get pointer to the code
    blx    ip                              @ call the method

    mov    sp, r11                         @ restore the stack pointer
    .cfi_def_cfa_register sp

    ldr    r4, [sp, #40]                   @ load result_is_float
    ldr    r9, [sp, #36]                   @ load the result pointer
    cmp    r4, #0
    ite    eq
    strdeq r0, [r9]                        @ store r0/r1 into result pointer
    vstrne d0, [r9]                        @ store s0-s1/d0 into result pointer

    pop    {r4, r5, r6, r7, r8, r9, r10, r11, pc}               @ restore spill regs
END art_quick_invoke_stub_internal
```



其中中间部分一行代码使用 ldr 指令设置 ip 寄存器的位置来指示指令地址，使用到了 ART_METHOD_QUICK_CODE_OFFSET_32 这个宏，它是 32，表示 EntryPointFromQuickCompiledCodeOffset 这个函数返回的成员的偏移，也就是 entry_point_from_quick_compiled_code_。

```
// asm_support.h

#define ART_METHOD_QUICK_CODE_OFFSET_32 32
ADD_TEST_EQ(ART_METHOD_QUICK_CODE_OFFSET_32,
            art::ArtMethod::EntryPointFromQuickCompiledCodeOffset(4).Int32Value())
// art_method.h

static MemberOffset EntryPointFromQuickCompiledCodeOffset(size_t pointer_size) {
  return MemberOffset(PtrSizedFieldsOffset(pointer_size) + OFFSETOF_MEMBER(
      PtrSizedFields, entry_point_from_quick_compiled_code_) / sizeof(void*) * pointer_size);
}
```


回到前面 Hook 时，使用了 SetEntryPointFromQuickCompiledCode，其实就是设置这个变量。
```
// art_method.h

void SetEntryPointFromQuickCompiledCode(const void* entry_point_from_quick_compiled_code) {
    SetEntryPointFromQuickCompiledCodePtrSize(entry_point_from_quick_compiled_code,
                                              sizeof(void*));
  }
  ALWAYS_INLINE void SetEntryPointFromQuickCompiledCodePtrSize(
      const void* entry_point_from_quick_compiled_code, size_t pointer_size) {
    DCHECK(Runtime::Current()->IsAotCompiler() || !IsXposedHookedMethod());
    SetNativePointer(EntryPointFromQuickCompiledCodeOffset(pointer_size),
                     entry_point_from_quick_compiled_code, pointer_size);
  }
```
那么下一步使用了 blx 跳转指令，代码就会跳转到这个地址上执行，进入 GetQuickProxyInvokeHandler 返回的地址 art_quick_proxy_invoke_handler 中， 最后执行 artQuickProxyInvokeHandler 函数，Xposed 在这个函数里面处理了 Hook，完成 Hook。

到这里就分析完了 Xposed 的实现，其实还有很多细节没有去分析，通过对比 ART 虚拟机的原始代码和 Xposed 修改后的代码，发现 Xposed 修改的地方还是很多的，大概有几百处，虽然每个文件修改的代码不多，但是足以说明 Xposed 作者对于 Android 系统原理和 ART 虚拟机的了解的深入程度。

总结
通过分析 Xposed 的实现原理，对于 Java 方法的 Hook 原理有了一些了解，同时回顾了 Android zygote 进程相关的内容，对于 ART 虚拟机执行方法的过程也有了一个大概的认识。


- https://blog.csdn.net/weixin_47883636/article/details/109018440
- https://www.cnblogs.com/boycelee/p/13418371.html
















