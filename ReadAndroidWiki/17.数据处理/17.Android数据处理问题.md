#### 目录介绍
- 17.0.0.1 序列化的概念是什么？序列化作用是什么？为什么要对数据进行序列化？说一下你的看法？
- 17.0.0.4 数据库中的事务了解吗？事务的特性有哪些，请说一说？数据库的3大范式和5大约束是指什么？
- 17.0.0.6 对于SharedPreferences你觉得有什么优缺点？请简单说一下你的看法和建议……
- 17.0.0.7 commit和apply区别是什么？Sp创建SharePreferencesImpl对象时做了什么？
- 17.0.0.8 是否做过sp存储效率对比的实验？创建多次Editor和创建一次Editor有何区别？
- 17.0.0.9 阅读sp源码后有哪些总结，说一下看法？put和get方法会阻塞线程吗？使用sp有哪些建议？


### 好消息
- 博客笔记大汇总【15年10月到至今】，包括Java基础及深入知识点，Android技术博客，Python学习笔记等等，还包括平时开发中遇到的bug汇总，当然也在工作之余收集了大量的面试题，长期更新维护并且修正，持续完善……开源的文件是markdown格式的！同时也开源了生活博客，从12年起，积累共计500篇[近100万字]，将会陆续发表到网上，转载请注明出处，谢谢！
- **链接地址：https://github.com/yangchong211/YCBlogs**
- 如果觉得好，可以star一下，谢谢！当然也欢迎提出建议，万事起于忽微，量变引起质变！



### 17.0.0.1 序列化的概念是什么？序列化作用是什么？为什么要对数据进行序列化？说一下你的看法？
- 序列化的概念是什么
    * 序列化是将Java对象转化成字节序列的过程
    * 反序列化是将字节序列恢复为Java对象的过程
    * 看到网上还有种说法：序列化的意思笼统的来说就是将对象转化成二进制，用于在文件或者网络上进行传输；反序列化就是相反，将序列化后的二进制转换成可以看懂的对象。
- 序列化作用是什么
    * 无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。
    * 从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。
    * 这样来说，数据序列化相当于是将我们原先的对象序列化概念做出了扩展，在对象序列化和反序列化中，我们熟知的有两种方法，其一是Java语言中提供的Serializable接口，其二是Android提供的Parcelable接口。而在这里，因为我们对这个概念做出了扩展，因此也需要考虑几种专门针对数据结构进行序列化的方法，如现在那些个开放API一般返回的数据都是JSON格式的，又或者是我们Android原生的SQLite数据库来实现数据的本地存储，从广义上来说，这些都可以算做是数据的序列化。
- 为什么要对数据进行序列化
    * （1）.永久的保存对象数据(将对象数据保存在文件当中,或者是磁盘中
    * （2）.通过序列化操作将对象数据在网络上进行传输(由于网络传输是以字节流的方式对数据进行传输的.因此序列化的目的是将对象数据转换成字节流的形式)
    * （3）.将对象数据在进程之间进行传递(Activity之间传递对象数据时,需要在当前的Activity中对对象数据进行序列化操作.在另一个Activity中需要进行反序列化操作讲数据取出)
    * （4）.Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长（即每个对象都在JVM中）但在现实应用中，就可能要停止JVM运行，但有要保存某些指定的对象，并在将来重新读取被保存的对象。这是Java对象序列化就能够实现该功能。（可选择入数据库、或文件的形式保存）
    * （5）.序列化对象的时候只是针对变量进行序列化,不针对方法进行序列化.
    * （6）.在Intent之间,基本的数据类型直接进行相关传递即可,但是一旦数据类型比较复杂的时候,就需要进行序列化操作了.


### 17.0.0.4 数据库中的事务了解吗？事务的特性有哪些，请说一说？数据库的3大范式和5大约束是指什么？
- 事务是并发控制的单位，是用户定义的一个操作序列。它指这些操作要么都做，要么都不做，以便服务器保持数据的完整性。事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。
- 事务的四大特性（ACID特性）：
    - 原子性（Atomicity）表示事务中包括的诸操作要么全做，要么全不做；
    - 一致性（Consistency）表示事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态；
    - 隔离性（Isolation）表示一个事务的执行不能被其他事务干扰；
    - 持续性（Durability）表示一个事务一旦提交，它对数据库中数据的改变就应该是永久性的
- 数据库的3大范式和5大约束是指什么？
    - 3大范式
        - 第一范式（1NF）：数据表中的每个字段必须是不可拆分的最小单元，即确保每一列的原子性
        - 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系
        - 第三范式（3NF）：必须先满足第二范式，要求表中的每一列只与主键直接相关而不是间接相关，即表中的每一列只能依赖于主键
    - 5大约束
        - 1.primary KEY:设置主键约束；
        - 2.UNIQUE：设置唯一性约束，不能有重复值；
        - 3.DEFAULT 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2
        - 4.NOT NULL：设置非空约束，该字段不能为空；
        - 5.FOREIGN key :设置外键约束。



#### 17.0.0.6 对于SharedPreferences你觉得有什么优缺点？请简单说一下你的看法和建议……
- 对于SharedPreferences你觉得有什么优缺点？
    - SharedPreferences，它是一个轻量级的存储类，特别适合用于保存软件配置参数  。
    - 优点：
        - 1.轻量级，以键值对的方式进行存储，使用方便，易于理解
        - 2.采用的是xml文件形式存储在本地，程序卸载后会也会一并被清除，不会残留信息
    - 缺点：
        - 1.有于是对文件IO读取，因此在IO上的瓶颈是个大问题，因为在每次进行get和commit时都要将数据从内存写入到文件中，或从文件中读取
        - 2.多线程场景下效率较低，在get操作时，会锁定SharedPreferences对象，互斥其他操作，而当put，commit时，则会锁定Editor对象，使用写入锁进行互斥，在这种情况下，效率会降低
        - 3.不支持跨进程通讯
        - 4.由于每次都会把整个文件加载到内存中，因此，如果SharedPreferences文件过大，或者在其中的键值对是大对象的json数据则会占用大量内存，读取较慢是一方面，同时也会引发程序频繁GC，导致的界面卡顿。
    - 基于以上缺点：
        - 1.建议不要存储较大数据或者较多数据到SharedPreferences中
        - 2.频繁修改的数据修改后统一提交，而不是修改过后马上提交
        - 3.在跨进程通讯中不去使用SharedPreferences
        - 4.键值对不宜过多



### 17.0.0.7 commit和apply区别是什么？Sp创建SharePreferencesImpl对象时做了什么？
- commit和apply区别是什么？
    - 两者：commit方法，每次执行时同步写入磁盘。apply方法，每次执行时在单线程池中加入写入磁盘Task，异步写入。
    - commit提交是同步过程，效率会比apply异步提交的速度慢，但是apply没有返回值，永远无法知道存储是否失败
    - apply的好处是不是在于:高并发情况下，apply两次，存入内存两次，但数据从内存存入磁盘只需要一次；而commit方法是等前一个完全存入磁盘后，才执行下一个commit方法，这样内存数据存入磁盘就有了两次。因此，apply更优化，这种分析思考一下，对么？看后面源码分析……
- Sp创建SharePreferencesImpl对象时做了什么？
    - 第一次创建sp时会去查缓存，如果缓存中没有对象，才构造SharedPreferences对象，也就是说，多次调用getSharedPreferences方法并不会对性能造成多大影响，因为又缓存机制。如果命中了缓存，并且参数mode使用了Context.MODE_MULTI_PROCESS，那么将会调用sp.startReloadIfChangedUnexpectedly()方法，在startReloadIfChangedUnexpectedly方法中，会判断是否由其他进程修改过这个文件，如果有，会重新从磁盘中读取文件加载数据。
    - 看SharedPreferencesImpl的构造方法，源码大概的意思是：
        - 将传进来的参数file以及mode分别保存在mFile以及mMode中
        - 创建一个.bak备份文件，当用户写入失败的时候会根据这个备份文件进行恢复工作
        - 将存放键值对的mMap初始化为null
        - 调用startLoadFromDisk()方法加载数据，这个是通过一个new Thread创建自线程进行的。所以不会阻塞主线程的。



### 17.0.0.8 是否做过sp存储效率对比的实验？创建多次Editor和创建一次Editor有何区别？
- 代码如下所示
    ```java
    long startA = System.currentTimeMillis();
    for (int i=0 ; i<200 ; i++){
        SharedPreferences preferences = this.getSharedPreferences("testA", 0);
        SharedPreferences.Editor edit = preferences.edit();
        edit.putString("yc"+i,"yangchong"+i);
        edit.commit();
    }
    long endA = System.currentTimeMillis();
    long a = endA - startA;
    Log.i("测试A","----"+a);
    
    
    long startB = System.currentTimeMillis();
    SharedPreferences preferencesB = this.getSharedPreferences("testB", 0);
    SharedPreferences.Editor editB = preferencesB.edit();
    for (int i=0 ; i<200 ; i++){
        editB.putString("yc"+i,"yangchong"+i);
    }
    editB.commit();
    long endB = System.currentTimeMillis();
    long b = endB - startB;
    Log.i("测试B","----"+b);
    
    
    long startC = System.currentTimeMillis();
    SharedPreferences.Editor editC = null;
    for (int i=0 ; i<200 ; i++){
        SharedPreferences preferencesC = this.getSharedPreferences("testC", 0);
        if (editC==null){
            editC = preferencesC.edit();
        }
        editC.putString("yc"+i,"yangchong"+i);
    }
    editC.commit();
    long endC = System.currentTimeMillis();
    long c = endC - startC;
    Log.i("测试C","----"+c);
    ```
- 然后开始执行操作
    - A操作和B操作，在代码逻辑上应该是一样的，都是想SP中写入200次不同字段的数据，区别只是在于，A操作每次都去获取新的Editor，而B操作是只使用一个Eidtor去存储。两个操作都分别执行两次。
    - A操作和C操作，在代码逻辑上应该是一样的，都是想SP中写入200次不同字段的数据，区别只是在于，A操作每次都去获取新的Editor，而C操作是只使用一个Editor去存储，并且只commit一次。两个操作都分别执行两次。
    - B和C的操作几乎都是一样的，唯一不同的是B操作只是获取一次preferencesB对象，而C操作则是获取200次preferencesC操作。
- 然后看一下执行结果
    ```java
    2019-08-30 15:08:16.982 3659-3659/com.cheoo.app I/测试A: ----105
    2019-08-30 15:08:17.035 3659-3659/com.cheoo.app I/测试B: ----52
    2019-08-30 15:08:17.069 3659-3659/com.cheoo.app I/测试C: ----34
    2019-08-30 15:08:20.561 3659-3659/com.cheoo.app I/测试A: ----25
    2019-08-30 15:08:20.562 3659-3659/com.cheoo.app I/测试B: ----1
    2019-08-30 15:08:20.564 3659-3659/com.cheoo.app I/测试C: ----2
    ```
- 结果分析
    - 通过A和B操作进行比较可知：使用commit()的方式，如果每次都使用sp.edit()方法获取一个新的Editor的话，新建和修改的执行效率差了非常的大。也就是说，存储一个从来没有用过的Key，和修改一个已经存在的Key，在效率上是有差别的。
    - 通过B和C操作进行比较可知：getSharedPreferences操作一次和多次其实是没有多大的区别，因为在有缓存，如果存在则从缓存中取。


### 17.0.0.9 阅读sp源码后有哪些总结，说一下看法？put和get方法会阻塞线程吗？使用sp有哪些建议？
- 阅读sp源码后有哪些总结，说一下看法？
    - 1，sp只在创建SharePreferencesImpl实例时，才会将磁盘的文件加载进内存；getXxx方法之所以能拿到最新的value，是因为在apply/commit时会先将删除，修改，添加的Key,value写入内存，然后才写入磁盘； 
    - 2，get操作时，应该是锁定一个Object对象（sdk28源码是这样）； 
    - 3，跨进程的操作，MODE_MULTI_PROCESS已过时，系统建议使用例如ContentProvider替换该操作； 
    - 4，sp只会读取一次，可以在应用初始化的时候创建SpImpl对象；例如json字符串加载进内存，会占用很多的内存空间，理论上GC的频发容易导致卡顿。
- put和get方法会阻塞线程吗？
    - 就以putString为例分析源码。通过sharedPreferences.edit()方法返回的SharedPreferences.Editor，所有我们对SharedPreferences的写操作都是基于这个Editor类的。在 Android 系统中，Editor是一个接口类，它的具体实现类是EditorImpl：
        - SharedPreferences的写操作是线程安全的，因为使用了synchronize关键字
        - 对键值对数据的增删记录保存在mModified中，而并不是直接对SharedPreferences.mMap进行操作（mModified会在commit/apply方法中起到同步内存SharedPreferences.mMap以及磁盘数据的作用）
    - getString方法代码很简单，其他的例如getInt，getFloat方法也是一样的原理，直接对这个疑问进行总结：
        - getXxx方法是线程安全的，因为使用了synchronize关键字
        - getXxx方法是直接操作内存的，直接从内存中的mMap中根据传入的key读取value
        - getXxx方法有可能会卡在awaitLoadedLocked方法，从而导致线程阻塞等待（什么时候会出现这种阻塞现象呢？前面我们分析过，第一次调用getSharedPreferences方法时，会创建一个线程去异步加载数据，那么假如在调用完getSharedPreferences方法之后立即调用getXxx方法，此时的mLoaded很有可能为false，这就会导致awaiteLoadedLocked方法阻塞等待，直到loadFromDisk方法加载完数据并且调用notifyAll来唤醒所有等待线程）
- 使用sp有哪些建议？
    - 不要使用SharedPreferences作为多进程通信手段。由于没有使用跨进程的锁，就算使用MODE_MULTI_PROCESS，SharedPreferences在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，SP 大约会有万分之一的损坏率每个 SP 
    - 文件不能过大。SharedPreference的文件存储性能与文件大小相关，我们不要将毫无关联的配置项保存在同一个文件中，同时考虑将频繁修改的条目单独隔离出来
    - 还是每个 SP 文件不能过大。在第一个getSharedPreferences时，会先加载 SP 文件进内存，过大的 SP 文件会导致阻塞，甚至会导致 ANR
    - 依旧是每个 SP 文件不能过大。每次apply或者commit，都会把全部的数据一次性写入磁盘, 所以 SP 文件不应该过大, 影响整体性能







### 17.0.1.1 序列化的方式有哪些？效率对比有何优势？如何做性能上分析的？
- 序列化的方式有哪些
    - Parcelable
        - Parcelable是Android特有的一个实现序列化的接口，在Parcel内部包装了可序列化的数据，可以在Binder中自由传输。序列化的功能由writeToParcel方法来完成，最终通过Parcel的一系列write方法完成。反序列化功能由CREAOR来完成，其内部标明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化的过程。
    - Serializable
        - Serializable是Java提供的一个序列化接口，是一个空接口，用于标示对象是否可以支持序列化，通过ObjectOutputStrean及ObjectInputStream实现序列化和反序列化的过程。注意可以为需要序列化的对象设置一个serialVersionUID，在反序列化的时候系统会检测文件中的serialVersionUID是否与当前类的值一致，如果不一致则说明类发生了修改，反序列化失败。因此对于可能会修改的类最好指定serialVersionUID的值。
