# Lru内存缓存
#### 目录介绍
- 01.基础概念介绍
- 02.常见思路和做法
- 03.Api调用说明
- 04.遇到的坑分析
- 05.其他问题说明



### 01.基础概念说明
#### 1.1 内存缓存介绍
- 内存缓存：
    - 通过预先消耗应用的一点内存来存储数据，便可快速的为应用中的组件提供数据，是一种典型的以空间换时间的策略。
- 内存缓存：存储在内存中，如果对象销毁则内存也会跟随销毁。如果是静态对象，那么进程杀死后内存会销毁。
    - Map，LruCache等等，其实可以想象集合存储的对象，就是一种有生命周期的内存缓存！


#### 1.2 缓存策略思考
- 缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。
    - 常见的策略有三种：先进先出策略 FIFO、最少使用策略 LFU、最近最少使用策略 LRU。


#### 1.3 LruCache核心思想
- LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。
    - ![image](https://img-blog.csdnimg.cn/20210207165359999.png)
- LruCache的淘汰策略简单说明
    - 将LinkedHashMap中的默认顺序设置为访问顺序，每次调用get，则将该对象移到链表的头部，调用put插入新的对象到链表头部。
    - 当内存缓存达到最大值时，就将链表尾部的对象移除。每次put或者remove，都需要判断缓存大小是否足够trimToSize。



### 02.常见思路和做法
#### 2.1 经典案例题分析
- 讨论一个经典的应用场景，那就是+LRU+缓存淘汰算法。
    - 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的+CPU+缓存、数据库缓存、浏览器缓存、图片缓存等等。
- 举一个实际案例
    - 假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？



### 03.Api调用说明
- 创建LruCache对象
    ``` java
    private SystemLruCache<String , String> lruCache = new SystemLruCache<>(100);
    ```
- LruCache常见Api说明
    ``` java
    //获取数据
    lruCache.get("lru");
    //判断是否包含数据
    lruCache.containsKey("lru");
    //移除数据
    lruCache.remove("lru");
    //最大的长度
    int i = lruCache.maxSize();
    //拷贝一份数据
    Map<String, String> snapshot = lruCache.snapshot();
    //清除数据
    lruCache.clear();
    //获取健值对
    Set<String> keySet = lruCache.keySet();
    ```


### 04.遇到的坑分析


### 05.其他问题说明








